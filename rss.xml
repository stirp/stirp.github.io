<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>2018-09-16</title><link>http://blog.shrp.me//2018-09-16.html</link><pubdate>2018-09-16</pubdate><content:encoded>&lt;p&gt;下边是09月16日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/u/3178270/blog/2045625"&gt;线程中断以及线程中断引发的那些问题 - 一个程序员的成长的个人空间 - 开源中国&lt;/a&gt; 我们在使用可中断的函数时，通常是没有判断线程是否中断的。这篇文章指出如果线程经中断，但是代码还要执行 sleep 的时候，就会直接报 InterruptedException 。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/zhangxufeng/blog/1976076"&gt;Spring事务事件监控 - 爱宝贝丶的个人空间 - 开源中国&lt;/a&gt; spring 事务的一个源码讲解，正好自己最近在用事务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/gejun123456/intellij-generateAllSetMethod"&gt;GitHub - gejun123456/intellij-generateAllSetMethod: Intellij plugin to generate call to setter method value for class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/alipay/sofa-ark"&gt;GitHub - alipay/sofa-ark: SOFAArk is a light-weight，java based classloader isolation framework.&lt;/a&gt; 这是蚂蚁金服开源的一款 classloader 隔离框架，看名字就知道是用于 SOFA 的。现在 SOFA 很火，大有取代 dubbo 的架势，可以看看源码，了解下实现的技术。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/alibaba/arthas"&gt;GitHub - alibaba/arthas: Alibaba Java诊断利器Arthas&lt;/a&gt;阿里现在开源的技术真多，这款线上观察和调试 JVM 的利器在特殊的时候一定能派上用场。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/QNJR-GROUP/EasyTransaction"&gt;GitHub - QNJR-GROUP/EasyTransaction: A distribute transaction solution（分布式事务） unified the usage of TCC , SAGA , reliable message, compensate and so on;&lt;/a&gt; dubbo rpc 上架构的一套分布式事务框架。国人出品，厉害了！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/TNSYpcqamfC3Sn6IMxti5Q"&gt;TCP ACK 延迟40ms&lt;/a&gt; 有时候生产的故障并不是 Java 开发的问题，但是 Java 开发如果不懂怎么找到问题，这个问题很可能是无法解决的。本文就找到了一个 tcp 应答包的响应问题&lt;/li&gt;
&lt;li&gt;&lt;a href="https://winworldpc.com/home"&gt;WinWorld: Welcome&lt;/a&gt; 一个专门提供旧操作系统及其相关软件的网站，我已经通过它安装了 Mac 9 虚拟器，还是有点意思。此外还有 OS2 这样的神奇系统，已经消失的莲花办公套件&lt;/li&gt;
&lt;li&gt;&lt;a href="https://archive.org"&gt;archive.org&lt;/a&gt; 这个是一个更专业的收藏站点，任何没有版权问题的都可以收藏，更是提供了网页运行 dos 程序的能力，真是很厉害。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bellard.org/jslinux/vm.html?url=https://bellard.org/jslinux/win2k.cfg&amp;amp;mem=192&amp;amp;graphic=1&amp;amp;w=1024&amp;amp;h=768"&gt;Windows 2000&lt;/a&gt;继win95之后，又一个可以在浏览器运行的微软操作系统。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tonybai.com/2018/09/10/setup-service-discovery-and-load-balance-based-on-consul/"&gt;基于consul实现微服务的服务发现和负载均衡 | Tony Bai&lt;/a&gt; 一个老程序员，老架构师对微服务的服务发现和负载的一个实现方案，可以借鉴。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-16.html</guid></item><item><title>2018-09-09</title><link>http://blog.shrp.me//2018-09-09.html</link><pubdate>2018-09-10</pubdate><content:encoded>&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.infoq.com/cn/articles/how-to-write-a-good-software-design-document"&gt;如何才能写出好的软件设计文档？&lt;/a&gt; 做了这么多年的 Java 开发，除了在恶补测试，我想最需要恶补的其实是设计。我们虽然没有设计也做了这么多年的系统，但是没有先行设计，总是缺乏对系统方向的把握。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html"&gt;哈希碰撞与生日攻击 - 阮一峰的网络日志&lt;/a&gt; 虽然不是 Java 语言，但是这个问题存在于任何语言的哈希算法之中，值得一看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://liuzhengyang.github.io/2017/07/27/jitwatch/"&gt;使用JITWatch查看JVM的JIT编译代码 | 刘正阳&lt;/a&gt; 有时候我们对程序 JIT 优化后的情况不太了解，这个工具&lt;a href="https://github.com/AdoptOpenJDK/jitwatch"&gt;GitHub - AdoptOpenJDK/jitwatch: Log analyser / visualiser for Java HotSpot JIT compiler. Inspect inlining decisions, hot methods, bytecode, and assembly. View results in the JavaFX user interface.&lt;/a&gt;正合适。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.momothink.com/wonderpen/"&gt;WonderPen | 妙笔 - momothink&lt;/a&gt;妙笔，一个新的文档编辑工具，支持多级目录，存储自动增加版本可以支持回退，可以增加笔记备份，有导出功能，作者的用户画像是勤于写作的作家，实际上需要整理笔记的程序员也很适合。缺点是还不支持 sequence 或者 graph 语法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://commons.apache.org/proper/commons-weaver/download_weaver.cgi"&gt;Commons Weaver – Download Apache Commons Weaver&lt;/a&gt; 通过在类中生成（"weaving"）字节码，提供一种简单的方法来增强已编译的 Java 类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/snail007/shadowtunnel"&gt;GitHub - snail007/shadowtunnel: secure tunnel which help you protecting your tcp traffic between your machine and your service on remote.&lt;/a&gt; goproxy 作者的又一力作，为已有代理增加一个加密的链路。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/redisson/redisson"&gt;GitHub - redisson/redisson: Redisson - distributed Java objects and services (Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Executor service, Tomcat Session Manager, Scheduler service, JCache API) on top of Redis server. State of the Art Redis client&lt;/a&gt; Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。【Redis官方推荐】Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/rwv/chinese-dos-games"&gt;GitHub - rwv/chinese-dos-games: 🎮 Chinese DOS games in browser.&lt;/a&gt; 游戏大概有版权问题，但是技术是之前就很火的 WebAssembly 技术。不过这个目前最大的问题是存储没法保留，关闭浏览器存档就丢了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.wturrell.co.uk/phpstorm-ideavim-not-working/"&gt;PhpStorm troubleshooting – ideaVim stops working – William Turrell&lt;/a&gt; 这个也是我最近遇到的一个情况，idea 使用的 vim 插件突然就不工作了，编辑器回到了原始的状态，但是看插件是安装的，没有任何问题。原来是插件有个工作开关，默认开关还有快捷键，而且这个快捷键跟 Mac 的粘贴非常接近，囧。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/news/99768/tracking-users-across-the-web-via-tls-session-resumption"&gt;研究发现：不靠 cookie，网站也能通过 TLS 协议追踪你 - 开源中国&lt;/a&gt; 这个新闻有点恐怖，居然可以不用 cookie 而是通过 TLS 协议进行客户端的识别——这个功能对正常的业务来说没什么帮助，客户说关闭浏览器就关闭了；但是对于广告功能来说，完全可以用来短期跟踪客户，甚至对于手机的浏览器来说，完全可以替代 cookie 的作用了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-09.html</guid></item><item><title>2018-09-01</title><link>http://blog.shrp.me//2018-09-01.html</link><pubdate>2018-09-01</pubdate><content:encoded>&lt;p&gt;下边是9月01日的每周分享：&lt;/p&gt;

&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-DirectByteBuffer/"&gt;JDK源码阅读-DirectByteBuffer | 木杉的博客&lt;/a&gt; 木杉大神的又一力作，让我们继续学习 JVM 里的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://my.oschina.net/zijingshanke/blog/1930333"&gt;Uber 开源分布式追踪工具：JVM Profiler - RiboseYim‘s OpenSource Blog - 开源中国&lt;/a&gt; Uber 的这次开源非常受欢迎，这篇文章就是关于这款 Profiler 的详细介绍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29591.html"&gt;一次Java内存泄漏调试的有趣经历 - ImportNew&lt;/a&gt; 虽然是个老外，但是讲述的问题是个好问题——长时间 fullGC 导致的超时问题。虽然技术问题本身不复杂，但是解决起来并没有想象中那么容易。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.codingnow.com/2018/08/lockstep.html"&gt;lockstep 网络游戏同步方案&lt;/a&gt; 云风大神的详细讲解对于我们这样行业外的人来说真是一篇上等的入门力作。在此之前我只能猜测即时游戏的互联方案，其实这个方案在其他需要协作的场景都可以使用。对于非游戏程序员力荐。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/ld/J2Cache"&gt;红薯/J2Cache: Java 两级缓存框架，可以让应用支持两级缓存框架 ehcache(Caffeine) + redis 。避免完全使用独立缓存系统所带来的网络IO开销问题&lt;/a&gt; J2Cache 是 OSChina 目前正在使用的两级缓存框架。第一级缓存使用 Ehcache，第二级缓存使用 Redis 。由于大量的缓存读取会导致 L2 的网络成为整个系统的瓶颈，因此 L1 的目标是降低对 L2 的读取次数。该缓存框架主要用于集群环境中。单机也可使用，用于避免应用重启导致的 Ehcache 缓存数据丢失。与其说是个 cache，不如说是个 cache 桥梁，用于解决多级缓存的过期和更新不错。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/uber-common/jvm-profiler"&gt;GitHub - uber-common/jvm-profiler: JVM Profiler Sending Metrics to Kafka, Console Output or Custom Reporter&lt;/a&gt; Uber 开源的 Profiler，上文有介绍，可以参考下。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/p/smart-doc"&gt;smart-doc首页、文档和下载 - Java Restful API 文档生成工具 - 开源中国社区&lt;/a&gt; 号称免注入文档生成工具，目标还是比较长远的。既然不涉及生产，用于自动维护文档是不错的，已经在跟同事准备使用起来了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://jobob.gitee.io/mp3doc/"&gt;MyBatis-Plus&lt;/a&gt; 这个工具大概不是特别新奇了，我看已经有很多人在关注它的 github 源码了&lt;a href="https://github.com/baomidou/mybatis-plus"&gt;GitHub - baomidou/mybatis-plus: An enhanced toolkit of Mybatis to simplify development&lt;/a&gt;其使用会比直接使用 mybatis 简单很多，但是对于复杂业务来说还是需要写代码的。原理比较简单，本身性能无需担心。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lsongiu/redis-shared-lock"&gt;qidianliusong/redis-shared-lock: 基于redis的分布式共享锁，使用注解的方式对方法加锁&lt;/a&gt; 一个基于 redis 的分布式共享锁，代码有点意思。由于开发历史不太久，最好不要直接用于生产。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/news/99299/windows95-open-source-project"&gt;经典不灭，开源项目带你在各平台上重温 Windows 95 - 开源中国&lt;/a&gt; 大概很多人都没有用过 Windows95，有人用 Electron 制作了这款 Win95的虚拟机的前端界面，目测虚拟机是 bochs 下载地址：&lt;a href="https://github.com/felixrieseberg/windows95/releases"&gt;Releases · felixrieseberg/windows95 · GitHub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/NamsJHwEOdF3GgGE5sM4gg"&gt;几个大型网站的Feeds(Timeline)设计简单对比&lt;/a&gt; 很抱歉，这个是我最近比较关注的话题，看起来也不是最新的文章了，但是多关注一下其他社区的设计对于我们自己的社区就会多一些思考。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-01.html</guid></item><item><title>2018-08-24</title><link>http://blog.shrp.me//2018-08-24.html</link><pubdate>2018-08-24</pubdate><content:encoded>&lt;p&gt;下边是8月24日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://hengyunabc.github.io/jvm-heap-dump-find-fd/"&gt;从JVM heap dump里查找没有关闭文件的引用&lt;/a&gt; 如果程序发布后长期持有一个本应该关闭的文件引用，一定是发生了引用的泄露，这种事情一般查起来是很费劲的，还得在代码里跟踪引用的传递。文章里的方法也可以用来找任意你怀疑泄露的资源，不过需要学会 OQL。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.csdn.net/u013096088/article/details/81161084"&gt;Java与单例模式 - CSDN博客&lt;/a&gt; 单例模式大家都见得多了，什么美国的枚举单利，在代码里谈笑风生。不过为什么不能改进原有代码，使得反序列化不会破坏单例呢？本文通过阅读Java源码，给出了一个可行的方案：readresolve。不过面对一些速度著称的json库时，不见得可以像Java库函数那么标准，枚举依然是最安全的选择。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://redkale.org/"&gt;redkale&lt;/a&gt;     Redkale(中文名: 红菜苔，湖北特产蔬菜)是基于Java 8全新的微服务开源框架， 包含HTTP、WebSocket、TCP/UDP、数据序列化、数据缓存、依赖注入等功能。 本框架致力于简化集中式和微服务架构的开发，在增强开发敏捷性的同时保持高性能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://oblac.github.io/jodd/"&gt;Jodd&lt;/a&gt; Jodd是个轻量的Java组件包，有基础工具，有mvc，有依赖注入，有web扩展。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lifei6671/mindoc"&gt;MinDoc&lt;/a&gt; Golang实现的基于beego框架的接口在线文档管理系统。一个好用的wiki系统真的是太重要了，不仅仅对于那些不差钱的大企业来说。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://lujun9972.github.io/blog/2018/08/18/%E8%AF%AF%E5%88%A0%E9%99%A4dev%E4%B8%8B%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E/"&gt;误删除dev下的文件怎么办&lt;/a&gt; 如果不小心删除了/dev/下的文件，也就意味着你电脑上的一些组件无法使用了。本文介绍了你如何可以恢复它们。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-24.html</guid></item><item><title>2018-08-19</title><link>http://blog.shrp.me//2018-08-19.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;这是我第一次编写每周分享。这个点子是受到阮一峰阮老师的每周分享启发，考虑到自己每周看了很多消息和工具，正好也能借助这个机会总结留下有价值的资讯。只要能帮助读者了解最新的研发消息，或者某天能用来总结查看，都算是没有白写每周分享。正常情况下我会在周五晚上发出这个系列的文章。（第一期就不正常……）&lt;/p&gt;

&lt;p&gt;我的每周分享会包括以下几点内容：本周内学会的一些Java最新的研发知识；发现的新工具；研发人员可能会关注的新闻。其中研发新闻是随缘项目，一方面我也不太关注没有生产力的新闻，一方面也没有太大的留存价值，只有特别关注到的新闻才会分享给大家。Warning：由于我的消息来源也包括阮老师，所以肯定有些内容是来自阮老师的网站，而且如果内容不带有阮老师的观点的话，来源会写真正的消息来源，而不是阮老师的网站；这主要是考虑读者不用多次跳转找出处，而非对阮老师的劳动不尊重，相信阮老师也会见谅的。&lt;/p&gt;

&lt;p&gt;下边是8月19日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/07/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ByteBuffer/"&gt;JDK源码阅读-ByteBuffer&lt;/a&gt;
&amp;nbsp;&amp;nbsp;木衫大神对 ByteBuffer 的理解。讲真的，当你开始从 Java 业务深入到底层技术的时候，Java 的 IO 系统始终会是需要关注和优化的一个点。这篇文章就是理解 ByteBuffer 设计的绝佳讲解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://blog.shrp.me/personal-understanding-of-async-and-blocking.html"&gt;JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解&lt;/a&gt; 由于之前跟同事对一段代码是否同步，是否阻塞的看法不一致，所以想深入了解一下同步异步，阻塞非阻塞究竟是什么。个人才疏学浅，也希望有大牛帮忙指正。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.cnblogs.com/lovesqcc/p/9271781.html"&gt;CR常见代码问题 - 琴水玉 - 博客园&lt;/a&gt; 很多人应该都对 CodeReview 不陌生，这是个非常好的提高能力的机会，也是代码拿出来让大家一起改进的好机会。但是有时候一次 CodeReview 包含的事情太多，没有重点，效果也不会太好。这篇文章就对 CodeReview 应该做什么进行了详细的说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/go-gitea/gitea/"&gt;gitea&lt;/a&gt; 有些人就是想自己搭建 git 服务器，但是又不想用 gitlab 这样重量级的产品。Gitea 就是这样一款产品，它的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。项目采用 Go 作为后端语言，只要生成一个可执行程序即可。并且它还支持跨平台，支持 Linux、 macOS 和 Windows 以及各种架构，除了x86、amd64，还包括 ARM 和 PowerPC 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/"&gt;PowerShell Core&lt;/a&gt; PowerShell 对于 Windows 用户应该并不陌生，但是这款 Core ，知道的可能就少了，更何况它是开源并且跨平台的。它是微软开源的一个跨平台 (Windows, Linux 和 OS X) 自动化和配置工具（框架），可以和已有的工具友好集成，特别优化用于处理结构化数据 (如 JSON, CSV, XML 等), REST APIs 以及对象模型。它包含一个命令行 Shell、一个关联的脚本语言以及一个用于处理 cmdlets 的框架。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29239.html"&gt;JVM 的 ASM 工具&lt;/a&gt; 在OpenJDK里有一个AsmTools项目，用来生成正确的或者不正确的java .class文件，主要用来测试和验证。可能对于普通开发人员来说这个工具没什么用，不过对于 JVM 语言开发来说可能很有价值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/kkk001/hp-reflect"&gt;kvn-wang/hp-reflect&lt;/a&gt;  hp-reflect 是一个高性能的反射工具。它使用字节码技术动态生成 access class。通过不同的 access class，可以高效的获取字段的值，或者调用方法，或者生成实例。 在基础框架中非常实用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lym51/AutoLink"&gt;苦叶子/AutoLink&lt;/a&gt; AutoLink是一个开源Web IDE自动化测试集成解决方案,可以帮助你轻易的构建 Web 自动化测试脚本、HTTP 接口自动化测试脚本以及移动自动化测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.jumpserver.org/"&gt;Jumpserver - 开源堡垒机 - 官网&lt;/a&gt;完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/snail007/goproxy"&gt;GitHub - snail007/goproxy&lt;/a&gt; goProxy是golang实现的高性能http,https,websocket,tcp,防污染DNS,socks5代理服务器,支持内网穿透,链式代理,通讯加密,智能HTTP,SOCKS5代理,域名黑白名单,跨平台,KCP协议支持,集成外部API。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;推荐一下我这周从阮老师那里看到的文章，&lt;a href="http://www.ruanyifeng.com/blog/2018/08/api-below.html"&gt;API 之下&lt;/a&gt;。乍看之下似乎是讲软件的，但是其实是猜测未来 AI 普及后财富分配的一个可能的后果，非常有见解。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-19.html</guid></item><item><title>JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解</title><link>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;最近在工作中跟同事讨论起了一个调用是否算是非阻塞、异步时，居然发现我们对同一段代码的定性是不一样的，于是就想写一篇文章把这个问题琢磨琢磨。由于这里涉及很多专有名词的含义，因此就先从字典开始研究。&lt;/p&gt;

&lt;h2 id=""&gt;名词字典&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;同步阻塞 IO——内核态阻塞 IO。这种 IO 模型的工作方式是这样的：用户空间的进程发起一个系统调用，这导致了用户空间的这个进程被阻塞，无法执行任何进程上的其它代码，直到系统调用返回。&lt;/li&gt;
&lt;li&gt;同步非阻塞 IO——内核态非阻塞 IO。这种 IO 的工作方式是这样的：用户空间的进程发起一个系统调用，进程并不会被阻塞，而是回到用户空间继续执行，但是会时不时通过系统调用回到内核检查之前的调用是否结束。如果没有结束，则返回用户空间继续执行，并且很快再次通过系统调用去检查结果，直到结果被返回。&lt;/li&gt;
&lt;li&gt;异步 IO——用户态 IO。这种 IO 的工作方式是这样的：用户空间的进程发起系统调用，进程不阻塞立刻回到用户空间继续执行，也不需要回到内核检查结果，而是内核在结果准备好后复制给用户进程，再通知进程数据已经准备好了。这样用户进程不需要到内核中进行 IO 操作，虽然真正的 IO 仍然是内核完成的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（如果对上述文字难以理解，可以参考&lt;a href="https://www.jianshu.com/p/486b0965c296"&gt;聊聊Linux 五种IO模型 - 简书&lt;/a&gt;这篇文章）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同步请求——调用方主动获取被调方的结果&lt;/li&gt;
&lt;li&gt;异步请求——调用方被动收到被调方的通知&lt;/li&gt;
&lt;li&gt;Java线程阻塞状态——blocked&lt;/li&gt;
&lt;li&gt;Java线程等待状态——waiting，timed waiting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Java 线程的状态，可以参考下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/n2U3N.png" alt="" title=""&gt;&lt;/p&gt;

&lt;h2 id=""&gt;我们到底在说的是哪个概念？&lt;/h2&gt;

&lt;p&gt;一般当我们在说同步异步，阻塞非阻塞的时候，我们说的到底是哪个概念呢？&lt;/p&gt;

&lt;p&gt;是系统内核 IO 类型吗？如果这样的话，根本是没有异步阻塞的说法的，因为 IO 只有异步模型，按照异步模型的行为，是不阻塞进程执行的。&lt;/p&gt;

&lt;p&gt;那么我们是在说字典里的4567这四条解释吗？看起来好像是的，当我们说同步请求的时候，确实是在等执行结束后才能得到结果，主动赋值给一个变量；异步请求的时候，通过 callback 或者 listener 调用回来修改数据 ；当我们说阻塞的时候，Java 线程的状态是……哎？Java 线程的状态可不是只有阻塞（blocked）一个这么简单，而是还有 Waiting、Timed Waiting 状态，表示线程没有继续执行，在等待条件成熟的手变成 Runable 或者 Blocked。难道这种情况算是非阻塞？&lt;/p&gt;

&lt;p&gt;原来，当我们说一个函数阻塞非阻塞的时候，并不是在按照上述的定义去解释的，而是按照线程执行的角度去解释的。也就是说，如果函数调用的时候线程在继续执行逻辑，就是非阻塞的；如果在等待调用结束不继续执行，就是阻塞的。也就是说，第六条和第七条都算是阻塞的。&lt;/p&gt;

&lt;h2 id=""&gt;为什么我们要按照这个定义去理解？&lt;/h2&gt;

&lt;p&gt;有人可能觉得不服气，怎么就不能按照执行过程中的 IO 类型来划分？
我是这么理解的：一个编程概念的提出，是有它的语境的。比如 IO 模型，很确定是发生在IO 时的事情，而我们讨论一个函数的同步异步，阻塞非阻塞，是为了研究这次函数调用对我的程序执行顺序的影响，而非其中的某次 IO，因为这次 IO 的类型不会影响我怎么写代码，这种类型差异在封装过程中就已经抹平了。在我看来，同步就是函数返回值，异步就是回调函数，阻塞就是不执行结束不继续执行后边的逻辑，非阻塞就是不等结果继续执行。这样的定义才能让使用函数的人不用看源码就能继续放心的开发下去。&lt;/p&gt;

&lt;h2 id=""&gt;可以举个例子吗？&lt;/h2&gt;

&lt;p&gt;嗯，光是在理论逻辑上去论证是很枯燥又难以理解的，不如我们看点例子吧。&lt;/p&gt;

&lt;p&gt;首先看一个最简单的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    public static Result test() throws ExecutionException, InterruptedException {
        final ExecutorService executorService = Executors.newFixedThreadPool(1);
        final Result result = new Result();
        final Future&amp;lt;String&amp;gt; submit = executorService.submit(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "test";
        });
        result.done = true;
        result.text = submit.get();
        executorService.shutdown();
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test函数是同步还是异步，阻塞还是非阻塞呢？有朋友看到这里有线程池，执行的结果是交由另一个线程来处理的，所以理所当然的认为是异步的；由于执行过程会被 &lt;code&gt;submit.get()&lt;/code&gt;所阻塞，所以是阻塞的。可是在我看来，这个函数你会起名为 asyncTest 吗？不会的。虽然&lt;code&gt;executorService.submit&lt;/code&gt;确实是异步执行，但是这个函数内还对 future 进行了 get 操作，使得整个函数结束后返回完整的应答，变成了同步的。因此这个函数可以说是同步阻塞的。&lt;/p&gt;

&lt;p&gt;再看一个的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    final static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static Result test(){
        final Result result = new Result();
        executorService.execute(() -&amp;gt;{
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result.done = true;
            result.text = "test";
        });
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println("doing sth in main");
        while (!test.done);
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个test 函数的声明看起来就是个普通函数，但是需要等 done 结束才能使用。这是同步的还是异步的呢？我认为这算是异步的，因为需要等待 done 被通知修改后才能完成整改逻辑。由于可以 doing sth in main，这个是异步非阻塞的。如果把 done 改成传入的一个回调函数，就更容易被确认为异步了；我认为这两个行为是没有差别的，因为远离都是提交出去的任务通过通知的方式给到了原有线程。&lt;/p&gt;

&lt;p&gt;啊，既然这么说来，如果想变成异步阻塞怎么办呢？就在 test 函数中阻塞一下，比如 join 提交的任务，这不就是传说中的异步阻塞了嘛。只是异步阻塞的编程大多数情况下没必要写，因为都已经阻塞了，异步跟同步对于原有线程的代码执行顺序都没有任何区别了，无非是主动发请求还是收通知。异步的写法比同步写法麻烦多了，也就不太需要异步阻塞了。我能想到一种异步阻塞的情况，就是提交的任务会周期性的执行，也就是不只一次通知原有线程，比如配置文件的 watch就是类似的情况，会写成&lt;code&gt;Config.watch(filename,listener)&lt;/code&gt;,在程序初始化的过程中，必须先执行 listener，得到配置文件内容才能继续初始化；初始化后，如果有人改了配置文件，listener 会被再一次触发，从而改变程序的行为。&lt;/p&gt;

&lt;p&gt;再来看一个例子，来自ConcurrentLinkedQueue：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public boolean offer(E e) {
        checkNotNull(e);
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

        for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
            Node&amp;lt;E&amp;gt; q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数在执行过程中的亮点在于 &lt;code&gt;p.casNext(null, newNode)&lt;/code&gt; 和 &lt;code&gt;casTail(t, newNode)&lt;/code&gt;，两个 CAS 操作不阻塞，又完成了并发条件下的 offer 函数，整个函数是同步的，又没有阻塞，因此是同步非阻塞。&lt;/p&gt;

&lt;h2 id=""&gt;总结&lt;/h2&gt;

&lt;p&gt;其实很多时候不同的看法是因为我们的定义不同。如果同步和异步是指通信方式，阻塞非阻塞是指线程执行与否，那么我们就可以顺利得到示例里的结论；如果指的是 Linux IO 模型，那么显然我示例都是与之无关的。&lt;/p&gt;

&lt;p&gt;但是不管怎样，只要你能够根据你使用的定义去理解程序的行为方式，并写出正确的调用代码，我想这才是最重要的。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</guid></item><item><title>搬瓦工免费换 ip</title><link>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</link><pubdate>2018-06-26</pubdate><content:encoded>&lt;p&gt;前两天我的搬瓦工突然被封禁了，一大票技术网站无法访问，实在不方便。登录搬瓦工想找地方换 IP，发现这个基础款的产品自己不支持换 IP 换机房。正在想实在不行就得还供应商的时候，突然搜到搬瓦工针对此情况专门提供了免费更换 IP 的功能，每十周换一次，还是挺爽的。&lt;/p&gt;

&lt;p&gt;这个功能就是当你确信你的机器被墙了，可以访问&lt;a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck"&gt;https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck&lt;/a&gt;，此时会提示检测 ip，&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Xnip2018-06-26_12-01-04.jpg" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;然后点击 Test Main IP，如果检测到被封禁，就会出现 next 按钮，自然点击 next 按钮更换 IP 就好啦。&lt;/p&gt;

&lt;p&gt;不过由于 IP 变化了，需要运行以下命令更新 iptables 记录：
&lt;code&gt;iptables -F; iptables -t nat -F; iptables-save &amp;gt; /etc/sysconfig/iptables&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后别忘记去域名管理把你服务器的域名 A 记录换掉哦！要不然域名还是无法访问的！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</guid></item><item><title>一个USB-C的时代</title><link>http://blog.shrp.me//An-Era-of-USB-Type-C.html</link><pubdate>2018-06-15</pubdate><content:encoded>&lt;p&gt;最近为了配合在家用电脑的显示器需求，买了一台联想的ThinkVision显示器——&lt;a href="https://item.jd.com/4702716.html"&gt;联想（ThinkVision）T27h 27英寸窄边框 &lt;/a&gt;，用了几天，颇有些感想。&lt;/p&gt;

&lt;p&gt;首先，这货有一个坏点。显然联想在显示器的品控并不太好，而且国家的政策里坏点是允许的，而且越大的屏幕坏点允许就越多。当然我可以按照京东7天无条件去退换，可是这款显示器推出快一年了，按照系统显示，它的库存不多了，按照二手东的情况，可能剩下的多少有点问题。这款是我唯一能够找到价格比较低，带有USB-Hub功能的USB-C可充电可旋转显示器了（其实还有一款三星的，但是为了老回，必须不买三星的）。还好的是一个坏点并不是太大的问题，如果你观察你自己的显示器，其实上边落满了灰尘，一个坏点的影响就像是一粒灰尘，并不太影响。事实上，当你打开游戏，打开电影的时候，这个坏点根本就看不到。所以这次为二手东接了盘，感觉也还可以接受。&lt;/p&gt;

&lt;p&gt;虽然显示器有个坏点，但是功能上来说，它真的非常适合我的情况。我目前手里有三套设备，一个台式机，一个新版MacBook Pro，一台GPD pocket。台式机是没有USB-Type C的接口的，视频走HDMI接口；但是苹果本和pocket都是支持Type C接口的。我的电脑桌桌面空间很紧凑，键鼠当然只能有一套，如何用这一套键鼠控制三台电脑，关键只能是怎么利用显示器的USB-Hub功能了。&lt;/p&gt;

&lt;p&gt;然而显示器的USB-Hub是Type-C接口是host，四个普通USB接口去接键鼠。这个原理就像是那些Type-C的转接器一样，只不过转接器的视频输出直接接入显示器的视频输入了而已。那么Pocket和苹果本天然就应该支持边充电边视频输出，并且接到显示器的键鼠也可以用。结果我试了一下，不论是用苹果还是绿联买的一根充电线，还是显示器自带的Type-C线，都只能让苹果本使用，Pocket只能充电，不能显示视频，也无法实现USB-Hub。不过我插上了一款&lt;a href="https://item.jd.com/10391831021.html"&gt;绿联的0.5米长的线&lt;/a&gt;时，奇迹发生了，Pocket也能边充电边显示视频，还能使用接入的键鼠了。Perfect！&lt;/p&gt;

&lt;p&gt;不过还有一个麻烦，就是台式机怎么接入呢？台式机没有Type-C接口，没法直接使用。最简单的方法是电脑用一根Type-C的数据线（一头是Type-A的公头，另一头是Type-C的公头）我之前设想的是买一款Type-C的延长线（一公头一母头）接到显示器，一根USB Type-A公头转USB Type-C公头的普通数据线来连接。当用台式机的时候，就是&lt;code&gt;台式机--A转C数据线--延长线--显示器&lt;/code&gt;；当用苹果本的时候，就是&lt;code&gt;苹果本--C双公头的数据线--延长线--显示器&lt;/code&gt;。结果这个方案失败了：延长线是有逻辑的，公头是host，母头是client。但是在我的设计里，延长线的母头被用来连接host电脑了，公头插到显示器上，跟设计的方向是反的，现在只能充电显示，USB-HUB功能不能用，三个设备都不能。不过我又心生一计，电脑上用一个USB Type-A公头转USB-Type-C母头的转换器，再连到显示器，是不是就可以把显示器当成是USB-Hub了呢？这个情况下的连接是&lt;code&gt;电脑--公A转母C--C双公头的数据线--显示器&lt;/code&gt;，跟苹果本切换的时候只要把“双公头的数据线”连到公A转母C就可以了啊。这个方案理论上可行，赶紧去京东下单买转接头了，大概明天才能验证。&lt;/p&gt;

&lt;p&gt;不过不管验证情况怎么说，Type-C开始在电脑和手机上引领的接口风暴，怕是会越来越激烈了。对于用户来说，一个统一的接口价值相当的重要。恐怕只有等无线连接到来的时候，Type-C才会被淘汰了吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//An-Era-of-USB-Type-C.html</guid></item><item><title>联通IPTV诺基亚贝尔机顶盒怎么安装第三方应用</title><link>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</link><pubdate>2018-04-06</pubdate><content:encoded>&lt;p&gt;由于旧的IPTV盒子坏了，今天抽空去联通换了个IPTV，是上海诺基亚贝尔的S-010W-AV2B机器。拿回来以后IPTV功能都正常，但是一个安卓机顶盒不装点其他应用，那多浪费啊。没想到U盘插上去，傻眼了：apk都不显示，这可咋安装啊？&lt;/p&gt;

&lt;p&gt;一般来说这个方法应该有很多种，比如同一网络下用悟空遥控去推送，比如用USB线连到电脑上安装，比如连上键盘，按快捷键打开网页下载apk。可是一一试过以后发现都不能用，adb没有开，快捷键也被关闭了。&lt;/p&gt;

&lt;p&gt;正手足无措的时候，发现系统点击官方的应用商城居然会下载一个apk安装。嗯？如果我劫持url，下载一个贝当市场，问题不就迎刃而解了吗？&lt;/p&gt;

&lt;p&gt;具体步骤如下：
1、找了个电脑，设置网络共享。我家的IPTV方案是机顶盒通过光猫的wifi上网的，那么我的网络共享就是电脑连光猫的wifi，把网络共享给自己的网线，通过网线连接到IPTV机顶盒。&lt;/p&gt;

&lt;p&gt;2、装上wireshark抓包&lt;/p&gt;

&lt;p&gt;3、在机顶盒点击联通自己的应用商城，成功在wireshark里抓到了http请求地址：http://210.13.0.175:7084/launcher/data/1522120317/CUTV_DSMClient_V4.5.apk&lt;/p&gt;

&lt;p&gt;4、在自己电脑上架设一个网站（要监听所有的设备哦），在相应的地址，相同的文件名放一个贝当应用商店的apk。但是ip地址怎么办？别担心，我在电脑上添加了一个虚拟网卡，地址设置为静态的210.13.0.175，这样请求上来的时候自动就被路由到自己的这个网卡上了。如果你的自建站点按照我的提示监听了电脑所有的网卡，那么这个时候通过你电脑访问的下载请求都会被指向自己的假冒apk了。&lt;/p&gt;

&lt;p&gt;5、把机顶盒的商店卸载掉，再点击安装，很快进度条就走完了，只不过99%的时候提示验证错误，大概是安装后有个验证流程，还需要劫持后修改下，不过不要紧，就算不修改，apk已经安装好了。&lt;/p&gt;

&lt;p&gt;6、最后记得把自己的电脑的网络共享关掉，机顶盒连到正常的网络下下载你想要的apk吧。需要看IPTV的时候，把机顶盒连到光猫的IPTV的wifi下，就可以正常看IPTV了；需要看网络电视的时候，就连到普通wifi下看第三方apk的视频啦。&lt;/p&gt;

&lt;p&gt;最后强调一下，每个人的机顶盒访问的地址不一定一样，因此你一定要自己抓个包，才可能有效。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</guid></item><item><title>HG220GS-U改桥接模式</title><link>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</link><pubdate>2018-04-05</pubdate><content:encoded>&lt;p&gt;前两天联通宽带续费升级，原来的百兆猫要换成千兆猫，新猫型号是HG220GS-U.我自己有需要把光猫后的路由器映射到公网去,因此一般都会做dmz或者端口映射.联通原来的猫就有bug,dmz设置不生效,必须要挨个做端口映射;这个新猫更过分,dmz和端口映射均不生效.还好在网上搜到老周的一篇教程&lt;a href="http://guanggai.org/thread-459-1-1.html"&gt;烽火HG220G-U E00L2.03M2000光猫改桥接教程&lt;/a&gt;,解决了问题.&lt;/p&gt;

&lt;p&gt;原文里也有点小问题,telnet节点不必打开,后续操作也用不上telnet,而且telnet一旦打开,从外网也可以telnet到的,用户名admin,密码admin,只怕没几分钟就已经被攻陷了.其他操作均与原文相同.&lt;/p&gt;

&lt;p&gt;为了防止原链接失效,简单讲过程记在下边:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;登录光猫管理页面&lt;a href="http://192.168.1.1/"&gt;http://192.168.1.1/&lt;/a&gt;,默认用户名user,密码在光猫背后.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录后访问&lt;a href="http://192.168.1.1/backupsettings.conf"&gt;http://192.168.1.1/backupsettings.conf&lt;/a&gt;,将现有的配置文件保存并且备份,不管什么时候都能轻易恢复原有配置了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用notepad++或者sublime编辑一个配置文件的副本,先找到&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括IPTV的那个配置,北京联通通常出现在&amp;lt;WANConnectionDevice instance="4"&amp;gt;下,可以看到该配置的X_BROADCOM_COM_IfName的属性是epon0.4.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再找到上网的配置,也就是&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括INTERNET的那个配置,通常是&amp;lt;WANConnectionDevice instance="2"&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除该配置节点内的删除&amp;lt;IdleDisconnectTime&amp;gt;120&amp;lt;/IdleDisconnectTime&amp;gt;一整行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改该配置节点内的ConnectionType属性,从IP_Routed改为PPPoE_Bridged.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的名字从2_INTERNET_R_VID_3961改成2_INTERNET_B_VID_3961(也就是R改成了B),这个改动不知道是否必须&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的X_BROADCOM_COM_IfName属性从ppp0.2改成epon0.2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在该配置节点X_BROADCOM_COM_IfName后新增节点&amp;lt;X_CU_IPMode&amp;gt;3&amp;lt;/X_CU_IPMode&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href="http://192.168.1.1/updatesettings.html"&gt;http://192.168.1.1/updatesettings.html&lt;/a&gt;,选择上传配置,然后路由会自动重启,重启后就是桥接模式了,需要光猫后边的路由器或者电脑自己拨号才能上网了.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS:旧版的HG220GS是可以通过网址&lt;a href="http://192.168.1.1/logoffaccount.html"&gt;http://192.168.1.1/logoffaccount.html&lt;/a&gt;打开隐藏账户的,然后就可以通过&lt;a href="http://192.168.1.1/cu.html"&gt;http://192.168.1.1/cu.html&lt;/a&gt;登录管理员账户,用户名CUAdmin,密码123qweasdzxc.但是我的这个网页是不能访问的.隐藏账户登录后可以关闭端口扫描的防御来打开DMZ和端口映射功能.&lt;/p&gt;

&lt;p&gt;但是又有人说这种情况可以通过&lt;a href="http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1"&gt;http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1&lt;/a&gt;访问来开启隐藏账户,这个我就没有尝试了,大家可以自行尝试.&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</guid></item></channel>
</rss>