<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>在Windows的Linux子系统使用Java</title><link>http://blog.shrp.me//Using-Java-in-Windows-subsystem.html</link><pubdate>2018-10-10</pubdate><content:encoded>&lt;p&gt;今天在我的Windows上调试一些程序，其中一些命令在Windows的终端里十分难受，最后采用安装Windows的Linux子系统来使用这些命令，并且安装了Cmder作为terminal。现在的Cmder也同样支持配置为guake一样的行为，只是高度和宽度有些问题，只好全屏控制；但是终于可以在Windows上用 快捷键呼出Linux命令行了。然后愉快的跑到项目目录里，执行mvn命令，结果出人意料失败了:找不到Java，也没设置有效的Java_Home。&lt;/p&gt;

&lt;p&gt;嗯？不对啊，我的Java就安装在C盘默认目录啊，怎么找不到。哦，对了，这是Linux嘛，环境Path变量跟Windows的不一样了，得重新配置。于是找到JDK安装目录，设置JAVA_HOME指向，一气呵成。这回总该对了吧，原来用CygWin都可以的。结果一执行mvn命令，居然又失败了。&lt;/p&gt;

&lt;p&gt;难道变量设置失败了？echo一下，没问题啊。百思不得其解的时候执行了一下java，嗯？找不到？
啊，原来Windows的Java安装目录里都是java.exe这样带有exe后缀的，在Linux子系统里并不是java命令。虽然可以使用java.exe执行，但是mvn里指向的却是没有exe后缀的java。对于Linux子系统来说，java命令和java.exe是两个命令，也就无怪乎认为Java没有安装了。&lt;/p&gt;

&lt;p&gt;于是用apt-get在Linux子系统里安装openjdk，再设置目录，再次执行mvn命令，终于成功了。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Using-Java-in-Windows-subsystem.html</guid></item><item><title>TCP 状态流转流程图</title><link>http://blog.shrp.me//TCP-State-Transition.html</link><pubdate>2018-10-06</pubdate><content:encoded>&lt;p&gt;受到 &lt;a href="http://www.hoohack.me/2018/09/27/webser-zero-to-hero-tcp-status?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io"&gt;［从0到1编写服务器］TCP连接建立与断开状态变化&lt;/a&gt; 启发，重新绘制了其中的网络接口状态流转图，以后服务器遇到连接未释放，就可以按图索骥了，知道到底是哪个信令没有发。&lt;/p&gt;

&lt;p&gt;重绘的图链接&lt;a href="https://www.processon.com/view/link/5bb8d537e4b0bd4db9569543"&gt;TCP 状态流转图 | ProcessOn免费在线作图,在线流程图,在线思维导图 |&lt;/a&gt;,图片如下：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.shrp.me/img/TCP%20%E7%8A%B6%E6%80%81%E6%B5%81%E8%BD%AC%E5%9B%BE.jpg" alt="" title=""&gt;&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//TCP-State-Transition.html</guid></item><item><title>每周分享的完结</title><link>http://blog.shrp.me//end-of-weekly-share.html</link><pubdate>2018-10-06</pubdate><content:encoded>&lt;p&gt;之前一直觉得自己不太会分享，看了不少有意思的东西，发到群里又没有多少人看，就想放在网站上，也算是对自己每周看过的东西做个总结。&lt;/p&gt;

&lt;p&gt;只是经过这一个多月的实践，发现一个阅读都没有；而阅读量比较高的，是&lt;a href="http://blog.shrp.me/EF-BF-BD-Caused-Bug.html"&gt;EF BF BD 引发的血案&lt;/a&gt;这样容易说清楚因果的文章。&lt;/p&gt;

&lt;p&gt;这说明我现在并不适合像阮老师那样去作分享，更何况每次看到他分享都是周五上午，应该是干活的时候发出的，显然不像是一个技术人才会做的事情，应该是赞助商帮忙所为。&lt;/p&gt;

&lt;p&gt;综上，每周分享停更，看到好玩的，有趣的技术和产品随时发文。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//end-of-weekly-share.html</guid></item><item><title>2018-09-16</title><link>http://blog.shrp.me//2018-09-16.html</link><pubdate>2018-09-16</pubdate><content:encoded>&lt;p&gt;下边是09月16日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/u/3178270/blog/2045625"&gt;线程中断以及线程中断引发的那些问题 - 一个程序员的成长的个人空间 - 开源中国&lt;/a&gt; 我们在使用可中断的函数时，通常是没有判断线程是否中断的。这篇文章指出如果线程经中断，但是代码还要执行 sleep 的时候，就会直接报 InterruptedException 。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/zhangxufeng/blog/1976076"&gt;Spring事务事件监控 - 爱宝贝丶的个人空间 - 开源中国&lt;/a&gt; spring 事务的一个源码讲解，正好自己最近在用事务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/gejun123456/intellij-generateAllSetMethod"&gt;GitHub - gejun123456/intellij-generateAllSetMethod: Intellij plugin to generate call to setter method value for class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/alipay/sofa-ark"&gt;GitHub - alipay/sofa-ark: SOFAArk is a light-weight，java based classloader isolation framework.&lt;/a&gt; 这是蚂蚁金服开源的一款 classloader 隔离框架，看名字就知道是用于 SOFA 的。现在 SOFA 很火，大有取代 dubbo 的架势，可以看看源码，了解下实现的技术。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/alibaba/arthas"&gt;GitHub - alibaba/arthas: Alibaba Java诊断利器Arthas&lt;/a&gt;阿里现在开源的技术真多，这款线上观察和调试 JVM 的利器在特殊的时候一定能派上用场。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/QNJR-GROUP/EasyTransaction"&gt;GitHub - QNJR-GROUP/EasyTransaction: A distribute transaction solution（分布式事务） unified the usage of TCC , SAGA , reliable message, compensate and so on;&lt;/a&gt; dubbo rpc 上架构的一套分布式事务框架。国人出品，厉害了！&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/TNSYpcqamfC3Sn6IMxti5Q"&gt;TCP ACK 延迟40ms&lt;/a&gt; 有时候生产的故障并不是 Java 开发的问题，但是 Java 开发如果不懂怎么找到问题，这个问题很可能是无法解决的。本文就找到了一个 tcp 应答包的响应问题&lt;/li&gt;
&lt;li&gt;&lt;a href="https://winworldpc.com/home"&gt;WinWorld: Welcome&lt;/a&gt; 一个专门提供旧操作系统及其相关软件的网站，我已经通过它安装了 Mac 9 虚拟器，还是有点意思。此外还有 OS2 这样的神奇系统，已经消失的莲花办公套件&lt;/li&gt;
&lt;li&gt;&lt;a href="https://archive.org"&gt;archive.org&lt;/a&gt; 这个是一个更专业的收藏站点，任何没有版权问题的都可以收藏，更是提供了网页运行 dos 程序的能力，真是很厉害。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bellard.org/jslinux/vm.html?url=https://bellard.org/jslinux/win2k.cfg&amp;amp;mem=192&amp;amp;graphic=1&amp;amp;w=1024&amp;amp;h=768"&gt;Windows 2000&lt;/a&gt;继win95之后，又一个可以在浏览器运行的微软操作系统。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://tonybai.com/2018/09/10/setup-service-discovery-and-load-balance-based-on-consul/"&gt;基于consul实现微服务的服务发现和负载均衡 | Tony Bai&lt;/a&gt; 一个老程序员，老架构师对微服务的服务发现和负载的一个实现方案，可以借鉴。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-16.html</guid></item><item><title>2018-09-09</title><link>http://blog.shrp.me//2018-09-09.html</link><pubdate>2018-09-10</pubdate><content:encoded>&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.infoq.com/cn/articles/how-to-write-a-good-software-design-document"&gt;如何才能写出好的软件设计文档？&lt;/a&gt; 做了这么多年的 Java 开发，除了在恶补测试，我想最需要恶补的其实是设计。我们虽然没有设计也做了这么多年的系统，但是没有先行设计，总是缺乏对系统方向的把握。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html"&gt;哈希碰撞与生日攻击 - 阮一峰的网络日志&lt;/a&gt; 虽然不是 Java 语言，但是这个问题存在于任何语言的哈希算法之中，值得一看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://liuzhengyang.github.io/2017/07/27/jitwatch/"&gt;使用JITWatch查看JVM的JIT编译代码 | 刘正阳&lt;/a&gt; 有时候我们对程序 JIT 优化后的情况不太了解，这个工具&lt;a href="https://github.com/AdoptOpenJDK/jitwatch"&gt;GitHub - AdoptOpenJDK/jitwatch: Log analyser / visualiser for Java HotSpot JIT compiler. Inspect inlining decisions, hot methods, bytecode, and assembly. View results in the JavaFX user interface.&lt;/a&gt;正合适。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.momothink.com/wonderpen/"&gt;WonderPen | 妙笔 - momothink&lt;/a&gt;妙笔，一个新的文档编辑工具，支持多级目录，存储自动增加版本可以支持回退，可以增加笔记备份，有导出功能，作者的用户画像是勤于写作的作家，实际上需要整理笔记的程序员也很适合。缺点是还不支持 sequence 或者 graph 语法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://commons.apache.org/proper/commons-weaver/download_weaver.cgi"&gt;Commons Weaver – Download Apache Commons Weaver&lt;/a&gt; 通过在类中生成（"weaving"）字节码，提供一种简单的方法来增强已编译的 Java 类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/snail007/shadowtunnel"&gt;GitHub - snail007/shadowtunnel: secure tunnel which help you protecting your tcp traffic between your machine and your service on remote.&lt;/a&gt; goproxy 作者的又一力作，为已有代理增加一个加密的链路。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/redisson/redisson"&gt;GitHub - redisson/redisson: Redisson - distributed Java objects and services (Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Executor service, Tomcat Session Manager, Scheduler service, JCache API) on top of Redis server. State of the Art Redis client&lt;/a&gt; Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。【Redis官方推荐】Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/rwv/chinese-dos-games"&gt;GitHub - rwv/chinese-dos-games: 🎮 Chinese DOS games in browser.&lt;/a&gt; 游戏大概有版权问题，但是技术是之前就很火的 WebAssembly 技术。不过这个目前最大的问题是存储没法保留，关闭浏览器存档就丢了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.wturrell.co.uk/phpstorm-ideavim-not-working/"&gt;PhpStorm troubleshooting – ideaVim stops working – William Turrell&lt;/a&gt; 这个也是我最近遇到的一个情况，idea 使用的 vim 插件突然就不工作了，编辑器回到了原始的状态，但是看插件是安装的，没有任何问题。原来是插件有个工作开关，默认开关还有快捷键，而且这个快捷键跟 Mac 的粘贴非常接近，囧。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/news/99768/tracking-users-across-the-web-via-tls-session-resumption"&gt;研究发现：不靠 cookie，网站也能通过 TLS 协议追踪你 - 开源中国&lt;/a&gt; 这个新闻有点恐怖，居然可以不用 cookie 而是通过 TLS 协议进行客户端的识别——这个功能对正常的业务来说没什么帮助，客户说关闭浏览器就关闭了；但是对于广告功能来说，完全可以用来短期跟踪客户，甚至对于手机的浏览器来说，完全可以替代 cookie 的作用了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-09.html</guid></item><item><title>2018-09-01</title><link>http://blog.shrp.me//2018-09-01.html</link><pubdate>2018-09-01</pubdate><content:encoded>&lt;p&gt;下边是9月01日的每周分享：&lt;/p&gt;

&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-DirectByteBuffer/"&gt;JDK源码阅读-DirectByteBuffer | 木杉的博客&lt;/a&gt; 木杉大神的又一力作，让我们继续学习 JVM 里的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://my.oschina.net/zijingshanke/blog/1930333"&gt;Uber 开源分布式追踪工具：JVM Profiler - RiboseYim‘s OpenSource Blog - 开源中国&lt;/a&gt; Uber 的这次开源非常受欢迎，这篇文章就是关于这款 Profiler 的详细介绍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29591.html"&gt;一次Java内存泄漏调试的有趣经历 - ImportNew&lt;/a&gt; 虽然是个老外，但是讲述的问题是个好问题——长时间 fullGC 导致的超时问题。虽然技术问题本身不复杂，但是解决起来并没有想象中那么容易。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.codingnow.com/2018/08/lockstep.html"&gt;lockstep 网络游戏同步方案&lt;/a&gt; 云风大神的详细讲解对于我们这样行业外的人来说真是一篇上等的入门力作。在此之前我只能猜测即时游戏的互联方案，其实这个方案在其他需要协作的场景都可以使用。对于非游戏程序员力荐。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/ld/J2Cache"&gt;红薯/J2Cache: Java 两级缓存框架，可以让应用支持两级缓存框架 ehcache(Caffeine) + redis 。避免完全使用独立缓存系统所带来的网络IO开销问题&lt;/a&gt; J2Cache 是 OSChina 目前正在使用的两级缓存框架。第一级缓存使用 Ehcache，第二级缓存使用 Redis 。由于大量的缓存读取会导致 L2 的网络成为整个系统的瓶颈，因此 L1 的目标是降低对 L2 的读取次数。该缓存框架主要用于集群环境中。单机也可使用，用于避免应用重启导致的 Ehcache 缓存数据丢失。与其说是个 cache，不如说是个 cache 桥梁，用于解决多级缓存的过期和更新不错。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/uber-common/jvm-profiler"&gt;GitHub - uber-common/jvm-profiler: JVM Profiler Sending Metrics to Kafka, Console Output or Custom Reporter&lt;/a&gt; Uber 开源的 Profiler，上文有介绍，可以参考下。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/p/smart-doc"&gt;smart-doc首页、文档和下载 - Java Restful API 文档生成工具 - 开源中国社区&lt;/a&gt; 号称免注入文档生成工具，目标还是比较长远的。既然不涉及生产，用于自动维护文档是不错的，已经在跟同事准备使用起来了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://jobob.gitee.io/mp3doc/"&gt;MyBatis-Plus&lt;/a&gt; 这个工具大概不是特别新奇了，我看已经有很多人在关注它的 github 源码了&lt;a href="https://github.com/baomidou/mybatis-plus"&gt;GitHub - baomidou/mybatis-plus: An enhanced toolkit of Mybatis to simplify development&lt;/a&gt;其使用会比直接使用 mybatis 简单很多，但是对于复杂业务来说还是需要写代码的。原理比较简单，本身性能无需担心。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lsongiu/redis-shared-lock"&gt;qidianliusong/redis-shared-lock: 基于redis的分布式共享锁，使用注解的方式对方法加锁&lt;/a&gt; 一个基于 redis 的分布式共享锁，代码有点意思。由于开发历史不太久，最好不要直接用于生产。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/news/99299/windows95-open-source-project"&gt;经典不灭，开源项目带你在各平台上重温 Windows 95 - 开源中国&lt;/a&gt; 大概很多人都没有用过 Windows95，有人用 Electron 制作了这款 Win95的虚拟机的前端界面，目测虚拟机是 bochs 下载地址：&lt;a href="https://github.com/felixrieseberg/windows95/releases"&gt;Releases · felixrieseberg/windows95 · GitHub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://mp.weixin.qq.com/s/NamsJHwEOdF3GgGE5sM4gg"&gt;几个大型网站的Feeds(Timeline)设计简单对比&lt;/a&gt; 很抱歉，这个是我最近比较关注的话题，看起来也不是最新的文章了，但是多关注一下其他社区的设计对于我们自己的社区就会多一些思考。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-01.html</guid></item><item><title>2018-08-24</title><link>http://blog.shrp.me//2018-08-24.html</link><pubdate>2018-08-24</pubdate><content:encoded>&lt;p&gt;下边是8月24日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://hengyunabc.github.io/jvm-heap-dump-find-fd/"&gt;从JVM heap dump里查找没有关闭文件的引用&lt;/a&gt; 如果程序发布后长期持有一个本应该关闭的文件引用，一定是发生了引用的泄露，这种事情一般查起来是很费劲的，还得在代码里跟踪引用的传递。文章里的方法也可以用来找任意你怀疑泄露的资源，不过需要学会 OQL。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.csdn.net/u013096088/article/details/81161084"&gt;Java与单例模式 - CSDN博客&lt;/a&gt; 单例模式大家都见得多了，什么美国的枚举单利，在代码里谈笑风生。不过为什么不能改进原有代码，使得反序列化不会破坏单例呢？本文通过阅读Java源码，给出了一个可行的方案：readresolve。不过面对一些速度著称的json库时，不见得可以像Java库函数那么标准，枚举依然是最安全的选择。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://redkale.org/"&gt;redkale&lt;/a&gt;     Redkale(中文名: 红菜苔，湖北特产蔬菜)是基于Java 8全新的微服务开源框架， 包含HTTP、WebSocket、TCP/UDP、数据序列化、数据缓存、依赖注入等功能。 本框架致力于简化集中式和微服务架构的开发，在增强开发敏捷性的同时保持高性能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://oblac.github.io/jodd/"&gt;Jodd&lt;/a&gt; Jodd是个轻量的Java组件包，有基础工具，有mvc，有依赖注入，有web扩展。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lifei6671/mindoc"&gt;MinDoc&lt;/a&gt; Golang实现的基于beego框架的接口在线文档管理系统。一个好用的wiki系统真的是太重要了，不仅仅对于那些不差钱的大企业来说。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://lujun9972.github.io/blog/2018/08/18/%E8%AF%AF%E5%88%A0%E9%99%A4dev%E4%B8%8B%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E/"&gt;误删除dev下的文件怎么办&lt;/a&gt; 如果不小心删除了/dev/下的文件，也就意味着你电脑上的一些组件无法使用了。本文介绍了你如何可以恢复它们。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-24.html</guid></item><item><title>2018-08-19</title><link>http://blog.shrp.me//2018-08-19.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;这是我第一次编写每周分享。这个点子是受到阮一峰阮老师的每周分享启发，考虑到自己每周看了很多消息和工具，正好也能借助这个机会总结留下有价值的资讯。只要能帮助读者了解最新的研发消息，或者某天能用来总结查看，都算是没有白写每周分享。正常情况下我会在周五晚上发出这个系列的文章。（第一期就不正常……）&lt;/p&gt;

&lt;p&gt;我的每周分享会包括以下几点内容：本周内学会的一些Java最新的研发知识；发现的新工具；研发人员可能会关注的新闻。其中研发新闻是随缘项目，一方面我也不太关注没有生产力的新闻，一方面也没有太大的留存价值，只有特别关注到的新闻才会分享给大家。Warning：由于我的消息来源也包括阮老师，所以肯定有些内容是来自阮老师的网站，而且如果内容不带有阮老师的观点的话，来源会写真正的消息来源，而不是阮老师的网站；这主要是考虑读者不用多次跳转找出处，而非对阮老师的劳动不尊重，相信阮老师也会见谅的。&lt;/p&gt;

&lt;p&gt;下边是8月19日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/07/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ByteBuffer/"&gt;JDK源码阅读-ByteBuffer&lt;/a&gt;
&amp;nbsp;&amp;nbsp;木衫大神对 ByteBuffer 的理解。讲真的，当你开始从 Java 业务深入到底层技术的时候，Java 的 IO 系统始终会是需要关注和优化的一个点。这篇文章就是理解 ByteBuffer 设计的绝佳讲解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://blog.shrp.me/personal-understanding-of-async-and-blocking.html"&gt;JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解&lt;/a&gt; 由于之前跟同事对一段代码是否同步，是否阻塞的看法不一致，所以想深入了解一下同步异步，阻塞非阻塞究竟是什么。个人才疏学浅，也希望有大牛帮忙指正。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.cnblogs.com/lovesqcc/p/9271781.html"&gt;CR常见代码问题 - 琴水玉 - 博客园&lt;/a&gt; 很多人应该都对 CodeReview 不陌生，这是个非常好的提高能力的机会，也是代码拿出来让大家一起改进的好机会。但是有时候一次 CodeReview 包含的事情太多，没有重点，效果也不会太好。这篇文章就对 CodeReview 应该做什么进行了详细的说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/go-gitea/gitea/"&gt;gitea&lt;/a&gt; 有些人就是想自己搭建 git 服务器，但是又不想用 gitlab 这样重量级的产品。Gitea 就是这样一款产品，它的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。项目采用 Go 作为后端语言，只要生成一个可执行程序即可。并且它还支持跨平台，支持 Linux、 macOS 和 Windows 以及各种架构，除了x86、amd64，还包括 ARM 和 PowerPC 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/"&gt;PowerShell Core&lt;/a&gt; PowerShell 对于 Windows 用户应该并不陌生，但是这款 Core ，知道的可能就少了，更何况它是开源并且跨平台的。它是微软开源的一个跨平台 (Windows, Linux 和 OS X) 自动化和配置工具（框架），可以和已有的工具友好集成，特别优化用于处理结构化数据 (如 JSON, CSV, XML 等), REST APIs 以及对象模型。它包含一个命令行 Shell、一个关联的脚本语言以及一个用于处理 cmdlets 的框架。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29239.html"&gt;JVM 的 ASM 工具&lt;/a&gt; 在OpenJDK里有一个AsmTools项目，用来生成正确的或者不正确的java .class文件，主要用来测试和验证。可能对于普通开发人员来说这个工具没什么用，不过对于 JVM 语言开发来说可能很有价值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/kkk001/hp-reflect"&gt;kvn-wang/hp-reflect&lt;/a&gt;  hp-reflect 是一个高性能的反射工具。它使用字节码技术动态生成 access class。通过不同的 access class，可以高效的获取字段的值，或者调用方法，或者生成实例。 在基础框架中非常实用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lym51/AutoLink"&gt;苦叶子/AutoLink&lt;/a&gt; AutoLink是一个开源Web IDE自动化测试集成解决方案,可以帮助你轻易的构建 Web 自动化测试脚本、HTTP 接口自动化测试脚本以及移动自动化测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.jumpserver.org/"&gt;Jumpserver - 开源堡垒机 - 官网&lt;/a&gt;完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/snail007/goproxy"&gt;GitHub - snail007/goproxy&lt;/a&gt; goProxy是golang实现的高性能http,https,websocket,tcp,防污染DNS,socks5代理服务器,支持内网穿透,链式代理,通讯加密,智能HTTP,SOCKS5代理,域名黑白名单,跨平台,KCP协议支持,集成外部API。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;推荐一下我这周从阮老师那里看到的文章，&lt;a href="http://www.ruanyifeng.com/blog/2018/08/api-below.html"&gt;API 之下&lt;/a&gt;。乍看之下似乎是讲软件的，但是其实是猜测未来 AI 普及后财富分配的一个可能的后果，非常有见解。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-19.html</guid></item><item><title>JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解</title><link>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;最近在工作中跟同事讨论起了一个调用是否算是非阻塞、异步时，居然发现我们对同一段代码的定性是不一样的，于是就想写一篇文章把这个问题琢磨琢磨。由于这里涉及很多专有名词的含义，因此就先从字典开始研究。&lt;/p&gt;

&lt;h2 id=""&gt;名词字典&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;同步阻塞 IO——内核态阻塞 IO。这种 IO 模型的工作方式是这样的：用户空间的进程发起一个系统调用，这导致了用户空间的这个进程被阻塞，无法执行任何进程上的其它代码，直到系统调用返回。&lt;/li&gt;
&lt;li&gt;同步非阻塞 IO——内核态非阻塞 IO。这种 IO 的工作方式是这样的：用户空间的进程发起一个系统调用，进程并不会被阻塞，而是回到用户空间继续执行，但是会时不时通过系统调用回到内核检查之前的调用是否结束。如果没有结束，则返回用户空间继续执行，并且很快再次通过系统调用去检查结果，直到结果被返回。&lt;/li&gt;
&lt;li&gt;异步 IO——用户态 IO。这种 IO 的工作方式是这样的：用户空间的进程发起系统调用，进程不阻塞立刻回到用户空间继续执行，也不需要回到内核检查结果，而是内核在结果准备好后复制给用户进程，再通知进程数据已经准备好了。这样用户进程不需要到内核中进行 IO 操作，虽然真正的 IO 仍然是内核完成的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（如果对上述文字难以理解，可以参考&lt;a href="https://www.jianshu.com/p/486b0965c296"&gt;聊聊Linux 五种IO模型 - 简书&lt;/a&gt;这篇文章）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同步请求——调用方主动获取被调方的结果&lt;/li&gt;
&lt;li&gt;异步请求——调用方被动收到被调方的通知&lt;/li&gt;
&lt;li&gt;Java线程阻塞状态——blocked&lt;/li&gt;
&lt;li&gt;Java线程等待状态——waiting，timed waiting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Java 线程的状态，可以参考下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/n2U3N.png" alt="" title=""&gt;&lt;/p&gt;

&lt;h2 id=""&gt;我们到底在说的是哪个概念？&lt;/h2&gt;

&lt;p&gt;一般当我们在说同步异步，阻塞非阻塞的时候，我们说的到底是哪个概念呢？&lt;/p&gt;

&lt;p&gt;是系统内核 IO 类型吗？如果这样的话，根本是没有异步阻塞的说法的，因为 IO 只有异步模型，按照异步模型的行为，是不阻塞进程执行的。&lt;/p&gt;

&lt;p&gt;那么我们是在说字典里的4567这四条解释吗？看起来好像是的，当我们说同步请求的时候，确实是在等执行结束后才能得到结果，主动赋值给一个变量；异步请求的时候，通过 callback 或者 listener 调用回来修改数据 ；当我们说阻塞的时候，Java 线程的状态是……哎？Java 线程的状态可不是只有阻塞（blocked）一个这么简单，而是还有 Waiting、Timed Waiting 状态，表示线程没有继续执行，在等待条件成熟的手变成 Runable 或者 Blocked。难道这种情况算是非阻塞？&lt;/p&gt;

&lt;p&gt;原来，当我们说一个函数阻塞非阻塞的时候，并不是在按照上述的定义去解释的，而是按照线程执行的角度去解释的。也就是说，如果函数调用的时候线程在继续执行逻辑，就是非阻塞的；如果在等待调用结束不继续执行，就是阻塞的。也就是说，第六条和第七条都算是阻塞的。&lt;/p&gt;

&lt;h2 id=""&gt;为什么我们要按照这个定义去理解？&lt;/h2&gt;

&lt;p&gt;有人可能觉得不服气，怎么就不能按照执行过程中的 IO 类型来划分？
我是这么理解的：一个编程概念的提出，是有它的语境的。比如 IO 模型，很确定是发生在IO 时的事情，而我们讨论一个函数的同步异步，阻塞非阻塞，是为了研究这次函数调用对我的程序执行顺序的影响，而非其中的某次 IO，因为这次 IO 的类型不会影响我怎么写代码，这种类型差异在封装过程中就已经抹平了。在我看来，同步就是函数返回值，异步就是回调函数，阻塞就是不执行结束不继续执行后边的逻辑，非阻塞就是不等结果继续执行。这样的定义才能让使用函数的人不用看源码就能继续放心的开发下去。&lt;/p&gt;

&lt;h2 id=""&gt;可以举个例子吗？&lt;/h2&gt;

&lt;p&gt;嗯，光是在理论逻辑上去论证是很枯燥又难以理解的，不如我们看点例子吧。&lt;/p&gt;

&lt;p&gt;首先看一个最简单的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    public static Result test() throws ExecutionException, InterruptedException {
        final ExecutorService executorService = Executors.newFixedThreadPool(1);
        final Result result = new Result();
        final Future&amp;lt;String&amp;gt; submit = executorService.submit(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "test";
        });
        result.done = true;
        result.text = submit.get();
        executorService.shutdown();
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test函数是同步还是异步，阻塞还是非阻塞呢？有朋友看到这里有线程池，执行的结果是交由另一个线程来处理的，所以理所当然的认为是异步的；由于执行过程会被 &lt;code&gt;submit.get()&lt;/code&gt;所阻塞，所以是阻塞的。可是在我看来，这个函数你会起名为 asyncTest 吗？不会的。虽然&lt;code&gt;executorService.submit&lt;/code&gt;确实是异步执行，但是这个函数内还对 future 进行了 get 操作，使得整个函数结束后返回完整的应答，变成了同步的。因此这个函数可以说是同步阻塞的。&lt;/p&gt;

&lt;p&gt;再看一个的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    final static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static Result test(){
        final Result result = new Result();
        executorService.execute(() -&amp;gt;{
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result.done = true;
            result.text = "test";
        });
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println("doing sth in main");
        while (!test.done);
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个test 函数的声明看起来就是个普通函数，但是需要等 done 结束才能使用。这是同步的还是异步的呢？我认为这算是异步的，因为需要等待 done 被通知修改后才能完成整改逻辑。由于可以 doing sth in main，这个是异步非阻塞的。如果把 done 改成传入的一个回调函数，就更容易被确认为异步了；我认为这两个行为是没有差别的，因为远离都是提交出去的任务通过通知的方式给到了原有线程。&lt;/p&gt;

&lt;p&gt;啊，既然这么说来，如果想变成异步阻塞怎么办呢？就在 test 函数中阻塞一下，比如 join 提交的任务，这不就是传说中的异步阻塞了嘛。只是异步阻塞的编程大多数情况下没必要写，因为都已经阻塞了，异步跟同步对于原有线程的代码执行顺序都没有任何区别了，无非是主动发请求还是收通知。异步的写法比同步写法麻烦多了，也就不太需要异步阻塞了。我能想到一种异步阻塞的情况，就是提交的任务会周期性的执行，也就是不只一次通知原有线程，比如配置文件的 watch就是类似的情况，会写成&lt;code&gt;Config.watch(filename,listener)&lt;/code&gt;,在程序初始化的过程中，必须先执行 listener，得到配置文件内容才能继续初始化；初始化后，如果有人改了配置文件，listener 会被再一次触发，从而改变程序的行为。&lt;/p&gt;

&lt;p&gt;再来看一个例子，来自ConcurrentLinkedQueue：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public boolean offer(E e) {
        checkNotNull(e);
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

        for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
            Node&amp;lt;E&amp;gt; q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数在执行过程中的亮点在于 &lt;code&gt;p.casNext(null, newNode)&lt;/code&gt; 和 &lt;code&gt;casTail(t, newNode)&lt;/code&gt;，两个 CAS 操作不阻塞，又完成了并发条件下的 offer 函数，整个函数是同步的，又没有阻塞，因此是同步非阻塞。&lt;/p&gt;

&lt;h2 id=""&gt;总结&lt;/h2&gt;

&lt;p&gt;其实很多时候不同的看法是因为我们的定义不同。如果同步和异步是指通信方式，阻塞非阻塞是指线程执行与否，那么我们就可以顺利得到示例里的结论；如果指的是 Linux IO 模型，那么显然我示例都是与之无关的。&lt;/p&gt;

&lt;p&gt;但是不管怎样，只要你能够根据你使用的定义去理解程序的行为方式，并写出正确的调用代码，我想这才是最重要的。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</guid></item><item><title>搬瓦工免费换 ip</title><link>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</link><pubdate>2018-06-26</pubdate><content:encoded>&lt;p&gt;前两天我的搬瓦工突然被封禁了，一大票技术网站无法访问，实在不方便。登录搬瓦工想找地方换 IP，发现这个基础款的产品自己不支持换 IP 换机房。正在想实在不行就得还供应商的时候，突然搜到搬瓦工针对此情况专门提供了免费更换 IP 的功能，每十周换一次，还是挺爽的。&lt;/p&gt;

&lt;p&gt;这个功能就是当你确信你的机器被墙了，可以访问&lt;a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck"&gt;https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck&lt;/a&gt;，此时会提示检测 ip，&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Xnip2018-06-26_12-01-04.jpg" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;然后点击 Test Main IP，如果检测到被封禁，就会出现 next 按钮，自然点击 next 按钮更换 IP 就好啦。&lt;/p&gt;

&lt;p&gt;不过由于 IP 变化了，需要运行以下命令更新 iptables 记录：
&lt;code&gt;iptables -F; iptables -t nat -F; iptables-save &amp;gt; /etc/sysconfig/iptables&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后别忘记去域名管理把你服务器的域名 A 记录换掉哦！要不然域名还是无法访问的！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</guid></item></channel>
</rss>