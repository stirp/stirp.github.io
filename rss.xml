<?xml version="1.0" encoding="utf-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>temp</title><link>http://blog.shrp.me//temp.html</link><pubdate>2016-02-19</pubdate><content:encoded>&lt;pre class=" language-java"&gt;&lt;code class=" language-java"&gt;
&lt;span class="token keyword"&gt;package&lt;/span&gt; com&lt;span class="token punctuation"&gt;.&lt;/span&gt;woqu&lt;span class="token punctuation"&gt;.&lt;/span&gt;crm&lt;span class="token punctuation"&gt;.&lt;/span&gt;server&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;io&lt;span class="token punctuation"&gt;.&lt;/span&gt;UnsupportedEncodingException&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;util&lt;span class="token punctuation"&gt;.&lt;/span&gt;LinkedList&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;util&lt;span class="token punctuation"&gt;.&lt;/span&gt;List&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token comment" spellcheck="true"&gt;/**
 * Created by shangrenpeng on 16/2/18.
 */&lt;/span&gt;
&lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;class&lt;/span&gt; &lt;span class="token class-name"&gt;PHPUrlDecoder&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token function"&gt;decode&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;String s&lt;span class="token punctuation"&gt;,&lt;/span&gt; String enc&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;throws&lt;/span&gt; UnsupportedEncodingException &lt;span class="token punctuation"&gt;{&lt;/span&gt;

        &lt;span class="token keyword"&gt;int&lt;/span&gt; numChars &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;length&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;LinkedList&lt;/span&gt;&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;&amp;gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;enc&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;length&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;throw&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;UnsupportedEncodingException&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token string"&gt;"URLDecoder: empty string enc parameter"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

        &lt;span class="token keyword"&gt;char&lt;/span&gt; c&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes &lt;span class="token operator"&gt;=&lt;/span&gt; null&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            c &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;charAt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token keyword"&gt;switch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                &lt;span class="token keyword"&gt;case&lt;/span&gt; &lt;span class="token string"&gt;'+'&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                    &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;' '&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                &lt;span class="token keyword"&gt;case&lt;/span&gt; &lt;span class="token string"&gt;'%'&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                &lt;span class="token comment" spellcheck="true"&gt;/*
                 * Starting with this instance of %, process all
                 * consecutive substrings of the form %xy. Each
                 * substring %xy will yield a byte. Convert all
                 * consecutive  bytes obtained this way to whatever
                 * character(s) they represent in the provided
                 * encoding.
                 */&lt;/span&gt;

                    &lt;span class="token keyword"&gt;try&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;!&lt;/span&gt;&lt;span class="token function"&gt;canParse&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s &lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
                            &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

                       &lt;span class="token comment" spellcheck="true"&gt; // (numChars-i)/3 is an upper bound for the number
&lt;/span&gt;                       &lt;span class="token comment" spellcheck="true"&gt; // of remaining bytes
&lt;/span&gt;                        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;bytes &lt;span class="token operator"&gt;==&lt;/span&gt; null&lt;span class="token punctuation"&gt;)&lt;/span&gt;
                            bytes &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;numChars&lt;span class="token operator"&gt;-&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;/3&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token keyword"&gt;int&lt;/span&gt; pos &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

                        &lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;i&lt;span class="token number"&gt;+2&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                                &lt;span class="token punctuation"&gt;(&lt;/span&gt;c&lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token string"&gt;'%'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;

                            &lt;span class="token keyword"&gt;int&lt;/span&gt; v &lt;span class="token operator"&gt;=&lt;/span&gt; Integer&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;parseInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;substring&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token number"&gt;+1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token number"&gt;+3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;,16&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;
//                            if (v &amp;lt; 0){
&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;//                                throw new IllegalArgumentException("URLDecoder: Illegal hex characters in escape (%) pattern - negative value");
&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;//                            }
&lt;/span&gt;
                            bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;pos&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; v&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            i&lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 3&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt;
                                c &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;charAt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
                        &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;,&lt;/span&gt;pos&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;catch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token class-name"&gt;NumberFormatException&lt;/span&gt; e&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                        &lt;span class="token keyword"&gt;throw&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;IllegalArgumentException&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;
                                &lt;span class="token string"&gt;"URLDecoder: Illegal hex characters in escape (%) pattern - "&lt;/span&gt;
                                        &lt;span class="token operator"&gt;+&lt;/span&gt; e&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getMessage&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                &lt;span class="token keyword"&gt;default&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                    &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token punctuation"&gt;}&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

        &lt;span class="token keyword"&gt;final&lt;/span&gt; Byte&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; ret &lt;span class="token operator"&gt;=&lt;/span&gt; sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;toArray&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;Byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;size&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

        &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token function"&gt;toPrimitive&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;ret&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; EMPTY_BYTE_ARRAY &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token number"&gt;[0&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token function"&gt;toPrimitive&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;Byte&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; array&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;array &lt;span class="token operator"&gt;==&lt;/span&gt; null&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; null&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length &lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; EMPTY_BYTE_ARRAY&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; result &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

            &lt;span class="token keyword"&gt;for&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token operator"&gt;++&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                result&lt;span class="token punctuation"&gt;[&lt;/span&gt;i&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; array&lt;span class="token punctuation"&gt;[&lt;/span&gt;i&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;byteValue&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token punctuation"&gt;}&lt;/span&gt;

            &lt;span class="token keyword"&gt;return&lt;/span&gt; result&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; pos&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; j &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; pos&lt;span class="token punctuation"&gt;;&lt;/span&gt; j&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;add&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;j&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; j &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;;&lt;/span&gt; j&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;add&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;j&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;boolean&lt;/span&gt; &lt;span class="token function"&gt;canParse&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; String s&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;try&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;int&lt;/span&gt; v &lt;span class="token operator"&gt;=&lt;/span&gt; Integer&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;parseInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;substring&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token number"&gt;+1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token number"&gt;+3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;,16&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token boolean"&gt;true&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;catch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token class-name"&gt;Exception&lt;/span&gt; e&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token boolean"&gt;false&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;</content:encoded><guid>http://blog.shrp.me//temp.html</guid></item><item><title>重新学习C的领悟</title><link>http://blog.shrp.me//Understanding-Of-Restudy-C.html</link><pubdate>2011-04-25</pubdate><content:encoded>&lt;h4 id="1scanfcchr"&gt;1. 为了跳过之前的回车，可以使用&lt;code&gt;scanf(“空格%c”,&amp;amp;chr);&lt;/code&gt;，其中的空格可以跳过零个或者若干个空白字符，包括换行、换页、行制表符、列制表符、空格&lt;/h4&gt;

&lt;h4 id="22fg"&gt;2. 为了打印出小数点后两位数字，"%.2f"来输出。为了打印出自然书写格式的的浮点数字，可以用%g。&lt;/h4&gt;

&lt;h4 id="3001770x0x7fffintlu"&gt;3. 整型常量：八进制和十六进制没有负数常量。书写为：八进制：0开头，如0177；十六进制：0x开头，如0x7fff。默认属于int型，可以在后边添加L、U表示长整型、无符号型。为了输出负数八进制或十六进制，可以用下列方法：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt; i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"-%x"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;-&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%x"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="4fllongdoubledoublelfflongdoublelf"&gt;4. 浮点型常量：默认以双精度浮点形式存储。后缀F、L表示单精度浮点型或者long double型。在读取double型时用%lf，输出时%f；读取或者输出long double型时用%Lf。&lt;/h4&gt;

&lt;h4 id="533033escx1bx"&gt;5. 转义序列：连续的??要用\?来输出问号，否则会认为是三字符序列。八进制转义序列用\33或者\033表示ESC；十六进制转义序列用\x1B。x必须小写。&lt;/h4&gt;

&lt;h4 id="6charsignedunsigned128"&gt;6. 如果用char来存储较小的整型时，必须用signed或者unsigned来声明是否带有符号位。（否则会在自动扩展时出现问题，比如大于128的数字变成负数）&lt;/h4&gt;

&lt;h4 id="7"&gt;7.&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;getchar&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;!=&lt;/span&gt; &lt;span class="token string"&gt;'\n'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;\&lt;span class="token operator"&gt;*&lt;/span&gt;来跳过一行的输入\&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;

&lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;getchar&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token string"&gt;' '&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;\&lt;span class="token operator"&gt;*&lt;/span&gt;来跳过空格的输入\&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;``
&lt;/code&gt;&lt;/pre&gt;scanf()后边如果再使用getchar时要注意，scanf后边输入的\n是会被getchar所读取的，一般是所不希望的。

####8. sizeof()运算符一定要将所求目标用括号选中，否则容易出错。（sizeof运算符的优先等级高于二元运算符）。另一方面，返回值为无符号整型，容易在赋值到整型时溢出。

####9. 同样，-10&amp;lt;(unsigned int) 10的结果是假。

####10. 运算时溢出，即便结果是由更大范围的类型来保存依然会溢出。如：

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;long&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token number"&gt;1000&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
i &lt;span class="token operator"&gt;=&lt;/span&gt; j &lt;span class="token operator"&gt;*&lt;/span&gt; j&lt;span class="token comment" spellcheck="true"&gt;;//先溢出，再转换类型
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="11100"&gt;11. 使用数组的时候一定要避免从1开始。能从0开始就一定要从0开始，否则容易产生难以察觉的错误。&lt;/h4&gt;

&lt;h4 id="12aibib1a2"&gt;12. 数组下标使用++等带有作用的运算时要小心。如a[i] = b[i++]在不同电脑的实现是不同的，可能会成为b[1] = a[2]。&lt;/h4&gt;

&lt;h4 id="13memcpyabsizeofastringh"&gt;13. 数组间的赋值：&lt;code&gt;memcpy(a, b, sizeof(a));&lt;/code&gt;它比循环速度快。来自&lt;string.h&gt;。&lt;/string.h&gt;&lt;/h4&gt;

&lt;h4 id="14"&gt;14. 函数不能返回数组。&lt;/h4&gt;

&lt;h4 id="15unsignedlongint"&gt;15. 如果函数返回的类型非常长（如unsigned long int），那么有必要把返回类型单独放在一行&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;unsigned&lt;/span&gt; &lt;span class="token keyword"&gt;long&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt;
&lt;span class="token function"&gt;average&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;float&lt;/span&gt; a&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;float&lt;/span&gt; b&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt; a &lt;span class="token operator"&gt;+&lt;/span&gt; b&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;/&lt;/span&gt; &lt;span class="token number"&gt;2&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="16voidprintfhimmmmn"&gt;16. 在有返回值的函数需要丢弃返回值时，可以强制转换来明确表示丢弃，比如&lt;code&gt;(void) printf(”Hi,MMMM……\n“);&lt;/code&gt;来表示丢弃返回值。&lt;/h4&gt;

&lt;h4 id="17voidreturn"&gt;17. 在void 引导的函数中可以用&lt;code&gt;return;&lt;/code&gt;来随时退出函数。&lt;/h4&gt;

&lt;h4 id="18"&gt;18. 每个函数定义前都要有盒型注释，要求给出函数名、函数的目的、讨论每个形式参数的含义、描述返回值和罗列任何的副作用。（如会改变某个参数等）&lt;/h4&gt;

&lt;h4 id="19constconstvoidfconstintppvoidfintconstpppvoidfconstintconstpconstvoidfintaa"&gt;19. 函数中用const来保护不需要修改的参数。在指针、数组类型中使用const要注意，如&lt;code&gt;void f(const int *p)&lt;/code&gt;表示p所指向的数字不能改变。如果是&lt;code&gt;void f(int * const p)&lt;/code&gt;则表示p指向的数字可以改变，但是p不可以改变。可以出现void f(const int * const p)来表示指针和指针指向的数字都不可变。如果不用const，即便是void f(int a[])中a也相当于指针，也可以改变的。&lt;/h4&gt;

&lt;h4 id="20pa10p5a5"&gt;20. 指针可以当作数组名使用。如&lt;code&gt;*p = a[10]&lt;/code&gt;,则p[5] 等价于 a[5]；&lt;/h4&gt;

&lt;h4 id="21a1010aa"&gt;21. 多维数组名作为指针时要小心。如a[10][10]中a相当于 **a。&lt;/h4&gt;

&lt;h4 id="22inta10i5aiiaaaa"&gt;22. Int a[10],i = 5；使用时a[i]和i[a]是一样的，但是千万别混着使用。函数参数中a[]和*a是一样的，但是*a更为通用。&lt;/h4&gt;

&lt;h4 id="23printfppp"&gt;23. 可以用printf("%p",p);来显示p指针地址。&lt;/h4&gt;

&lt;h4 id="2412341234316"&gt;24. 字符串里面的转义序列要小心使用。比如八进制的转义序列在三个数字或者第一个非八进制数字处结束，\1234 实际是\123和4。十六进制数的转义序列不限制为3个数字，而是到第一个非16进制数字截至。&lt;/h4&gt;

&lt;h4 id="25"&gt;25.  如果字符串太长，不能在一行内放置，可以使用\来延长。\要求之后没有除回车外的字符，下一行要顶头开始。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;“Put a \
disk into drive a\n”&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过会打乱缩进。还好C语言标准规定，只要两个字符串中间都是空白字符，则将两个字符串合并，如：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Put a "&lt;/span&gt;

    &lt;span class="token string"&gt;"disk into drive a\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="26cabc1"&gt;26. C语言允许对字符串加下标，如"abc"[1]。这个特性使得字符串常量也可能改变，如&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;p &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"abc"&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token operator"&gt;*&lt;/span&gt;p &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;'x'&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;但是这种特性会对程序造成不可预知的后果（如果编译器对同样的字符串是压缩存储，这将导致其它字符串可能变化）。但是下标还有一个很好的使用方法，如：``return "0123456789ABCDEF"[digit];``这句话可以简单地将十进制的数字转化为十六进制的字符。

####27. 如果初始化字符串的长度和其本身长度一致时，编译器不会在后边加上'0'，也就不会破坏之后的数据。如：``Char str[7] = "srpsrp!",ch;``中，
Ch的值是不确定的，而不是'\0'。这条仅知道即可。

####28. 如果只显示字符串的一部分，则使用%.xs。如：

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; str&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"123456789"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%.3s"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;str&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将显示123。&lt;/p&gt;

&lt;h4 id="29putsstr"&gt;29. &lt;code&gt;puts(str);&lt;/code&gt;将在输出字符串后强制输出一个换行。&lt;/h4&gt;

&lt;h4 id="30scanfgets"&gt;30. 用scanf输入的字符永远不包括空白字符(空格、回车、换行、换页、换表格等)。gets则到回车才停止，并忽略回车。&lt;/h4&gt;

&lt;h4 id="31scanfnsn"&gt;31. scanf天生不是安全的，它可能会溢出数组。使用％ns会更安全，n指读入的最大字符数。&lt;/h4&gt;

&lt;h4 id="32strcpystrcpystr2strcpystr11234"&gt;32. strcpy 的返回值在较大的表达式中比较有用。如strcpy(str2,strcpy(str1,”1234”));&lt;/h4&gt;

&lt;h4 id="33charplanetsmercuryvenusearthmarsjupitersaturnuranusneptuneplutoplanets981mars"&gt;33. 在空间敏感的程序中使用字符数组，可以使用&lt;code&gt;char *planets[] = {"Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Pluto"},&lt;/code&gt;这样里面每一个字符串都只有本身的长度，而不是定长的。如果是定长数组（planets[9][81]），那会浪费不少空间，如Mars后边会空很多。&lt;/h4&gt;

&lt;h4 id="34cargvargc"&gt;34. C程序的命令行中始终有一个空指针，即argv[argc]。&lt;/h4&gt;

&lt;h4 id="35printfscanf"&gt;35. printf和scanf的第一个参数是字符串，并不只是字符串常量。因此可以实现下面的代码：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; fmt &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"%d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;fmt&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此可以读入fmt，然后再用fmt作为格式化串输入。&lt;/p&gt;

&lt;h4 id="36"&gt;36. #运算符在预处理时可以将宏的参数转换为字符串字面量。比如:&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;#define PRINT_INT(x)  printf(#x " = %d\n",x)&lt;/code&gt;,将使PRINT_INT(var)输出为&lt;code&gt;var = 13\n&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id="37definemk_idninintmk_id1mk_id2inti1i2"&gt;37. ##运算符在预处理时可以将两个记号合成一个记号。如&lt;code&gt;#define MK_ID(n) i##n&lt;/code&gt;在&lt;code&gt;int MK_ID(1), MK_ID(2)&lt;/code&gt;中等同于&lt;code&gt;int i1, i2&lt;/code&gt;。&lt;/h4&gt;

&lt;h4 id="38c"&gt;38. 在宏定义中缺少圆括号会导致C语言中最让人讨厌的错误。程序通常仍然可以编译通过，而且宏似乎也可以正常工作，但在某些情况下会出错。&lt;/h4&gt;

&lt;h4 id="39"&gt;39. 一些预定义的宏：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;__LINE__    被编译的文件的行数

__FILE__    被编译的文件的名字

__DATE__    编译的日期

__TIME__    编译的时间

__STDC__    如果编译器接受标准C，那么为1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="40defined10ififdefineddebugendif"&gt;40. defined运算符引用于标识符时，如果标识符是一个定义过的宏返回1，否则返回0。通常与if结合使用，如 &lt;code&gt;#if defined(DEBUG)…#endif&lt;/code&gt;。条件编译常用于保护头文件以避免重复包含。&lt;/h4&gt;

&lt;h4 id="41linelinenn132767linen__line__"&gt;41. #line指令用来给程序代码编号。如&lt;code&gt;#line n&lt;/code&gt;(n介于1和32767)，&lt;code&gt;#line n "文件名"&lt;/code&gt;。它可以改变&lt;code&gt;__LINE__&lt;/code&gt;宏。&lt;/h4&gt;

&lt;h4 id="42"&gt;42. 宏的使用必须谨慎小心，建议仅在常量不止一次使用，或者常量可能的使用方式变化的时候使用。&lt;/h4&gt;

&lt;h4 id="43defineconcatxyxyconcatabconcataconcatbcaconcatbcabcaconcat"&gt;43. ##运算符不能嵌套使用。比如&lt;code&gt;#define CONCAT(x,y) x##y&lt;/code&gt;在&lt;code&gt;CONCAT(a,b)&lt;/code&gt;时可以用，但是在&lt;code&gt;CONCAT(a,CONCAT(b,c));&lt;/code&gt;时将成为&lt;code&gt;aCONCAT(b,c)&lt;/code&gt;,而不是abc，因为没有名为&lt;code&gt;aCONCAT&lt;/code&gt;的宏。&lt;/h4&gt;

&lt;h4 id="44externintiii"&gt;44. &lt;code&gt;extern int i;&lt;/code&gt;提示编译器i是程序中其他位置定义的，因此不为i分配空间。&lt;/h4&gt;

&lt;h4 id="45ifndefendif"&gt;45. 为了防止头文件多次包含，用&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;把文件的内容括起来，来保护。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;boolean&lt;span class="token punctuation"&gt;.&lt;/span&gt;h
&lt;span class="token property"&gt;#ifndef    BOOLEAN_H&lt;/span&gt;
&lt;span class="token property"&gt;#define    BOOLEAN_H&lt;/span&gt;
&lt;span class="token property"&gt;#define    TRUE    1&lt;/span&gt;
&lt;span class="token property"&gt;#define    FALSE   0&lt;/span&gt;
&lt;span class="token keyword"&gt;typedef&lt;/span&gt;    &lt;span class="token keyword"&gt;int&lt;/span&gt; Bool&lt;span class="token punctuation"&gt;;&lt;/span&gt;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="46"&gt;46. 划分源文件的规则：&lt;/h4&gt;

&lt;p&gt;把每组函数的集合放入单独的源文件，在与源文件同名的头文件中放置函数原型（以及使用这些函数所需要的定义和头文件），每个调用源文件的文件都要包括相应的头文件，这样编译器就可以检验原型和定义是否一致。&lt;/p&gt;

&lt;h4 id="47structpart2part1"&gt;47. Struct可以使用赋值运算：&lt;code&gt;part2 = part1&lt;/code&gt;。通常利用这个特性来实现数组的赋值：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt;a1&lt;span class="token punctuation"&gt;,&lt;/span&gt;a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;
a1 &lt;span class="token operator"&gt;=&lt;/span&gt; a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是不能使用a1 == a2来判断两者是否相等。&lt;/p&gt;

&lt;h4 id="48"&gt;48. 为了能对两个结构使用=赋值，两者不仅仅需要定义一致，还需要结构标记一致或者使用共同的类型。比如&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt; example&lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; a1&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
&lt;span class="token keyword"&gt;struct&lt;/span&gt; example a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 &lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;typedef&lt;/span&gt; &lt;span class="token keyword"&gt;struct&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; example&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
example a1&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
example a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（a1 和 a2可以是出现在不同位置的结构，如两个函数中。为了使用=，但是定义位置不同，所以要用上述两种方法解决问题）。&lt;/p&gt;

&lt;h4 id="49"&gt;49.&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt; Struct part &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; a1&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; part&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;是合法的，但是为了避免结构体part和整型变量part混淆，尽量不要使用。

####50. 在结构中使用联合可以节省大量空间。比如同一个数组保存三类不同物品的信息时，可以将三类物品的定义整合为联合。为了区别表示其中保存的物品，可以在结构定义一个枚举变量来表明联合中存储的类型。如

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token keyword"&gt;enum&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;INT_KIND&lt;span class="token punctuation"&gt;,&lt;/span&gt;FLOAT_KIND&lt;span class="token punctuation"&gt;)&lt;/span&gt; kind&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;union&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token keyword"&gt;float&lt;/span&gt; t&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; u&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt; number&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过number.kind确定存储的是整形还是实型变量，再提取number.u.i或者number.u.t。&lt;/p&gt;

&lt;h4 id="51mallocmallocsizeofmallocsizeofstruct"&gt;51. 使用malloc来动态分配结构时，不要使用&lt;code&gt;malloc(sizeof(结构指针))&lt;/code&gt;，而是&lt;code&gt;malloc(sizeof(struct 名字))&lt;/code&gt;；&lt;/h4&gt;

&lt;h4 id="52"&gt;52. 对于结构体不能使用==的一点补充，就是不可以对结构体按字节来对比。因为结构内部可能有空洞，对于它们而言，内部可以储存不同的数字。因此相同的结构按字节对比的结果可能不同，必须使用按成员的方式对比。&lt;/h4&gt;

&lt;h4 id="53pelementpp"&gt;53. 使用结构联合和枚举类型的指针时，访问子元素时一定要用(*p).element。包括当被指向的单元自增时使用(*p)++，指针自加使用p++。&lt;/h4&gt;

&lt;h4 id="54callocmalloccalloc1calloc"&gt;54. calloc函数会清除分配的内存，而malloc不会。有时需要用calloc为非空数组分配空间。通过调用1为第一个实际参数的calloc函数，可以为任何类型数据项分配空间：&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;p = calloc(1，sizeof(struct point));&lt;/code&gt;&lt;/p&gt;

&lt;h4 id="55reallocmalloccallocrealloc"&gt;55. realloc的指针参数必须是来自malloc，calloc或者realloc生成的指针。如果不是这样，程序可能会行为异常。&lt;/h4&gt;

&lt;h4 id="56realloc"&gt;56. realloc的准则：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;realloc不会初始化扩展的内存空间。&lt;/li&gt;
&lt;li&gt;如果realloc不能扩展，原指针会变空指针。&lt;/li&gt;
&lt;li&gt;如果realloc函数调用时以空指针作为第一个实际参数，那么行为就像malloc。&lt;/li&gt;
&lt;li&gt;realloc函数的第二个参数如果是0，那么行为如同free。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="57reallocrealloc"&gt;57. 一旦realloc函数返回，需要将指向本内存块的所有指针进行更新，因为realloc函数可能把原内存空间移动到了其他地方的内存。&lt;/h4&gt;

&lt;h4 id="58"&gt;58. 释放内存块时一定要谨慎小心，避免几个指针都指向同一个内存块，此时很容易有悬空指针。&lt;/h4&gt;

&lt;h4 id="59structnodenew_nodenew_nodemallocsizeofstructnodenew_nodemallocsizeofnew_node"&gt;59. 如果有&lt;code&gt;struct node *new_node;&lt;/code&gt;要分配空间时要使用&lt;code&gt;new_node = malloc(sizeof (struct node));&lt;/code&gt;而不是&lt;code&gt;new_node = malloc(sizeof (new_node));&lt;/code&gt;,后者只分配了一个指针的空间，而不是一个结构的空间。&lt;/h4&gt;

&lt;h4 id="60intpintpppp"&gt;60.&lt;code&gt;int *p(...)&lt;/code&gt;和&lt;code&gt;int (*p)(....)&lt;/code&gt;不同，前者是返回指针的函数，后者是指向函数的指针。需要后者指向某个函数时，简单的使用&lt;code&gt;p= 函数名&lt;/code&gt;（当函数名后边没有括号时，编译器将产生指向函数的指针来代替函数。）;调用时，可以用&lt;code&gt;(*p)(参数)&lt;/code&gt;，或者&lt;code&gt;p(参数)&lt;/code&gt;。&lt;/h4&gt;

&lt;h4 id="61voidfile_cmdvoidnew_cmdopen_cmdclose_cmdexit_cmdfile_cmd"&gt;61. 利用指向函数的指针可以用来产生菜单项。&lt;code&gt;void(*file_cmd[])(void) = {new_cmd,open_cmd,close_cmd,exit_cmd};&lt;/code&gt;就是一个菜单函数的封装实例。通过对file_cmd进行下标操作就可以调用相应的函数。&lt;/h4&gt;

&lt;h4 id="62qsortstrcmp"&gt;62. qsort不可以直接调用strcmp进行排序，因此需要下列函数进行辅助：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;Int &lt;span class="token function"&gt;compare_strings&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;p&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;q&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    Return &lt;span class="token function"&gt;strcmp&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; p&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;q&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="63static"&gt;63. static有三个用法：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;声明变量和函数当前文件内有效；&lt;/li&gt;
&lt;li&gt;函数内的变量得以保留并在下次调用时使用；&lt;/li&gt;
&lt;li&gt;使变量初始化为0。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="64externinttoupperinttoupper"&gt;64. 可以用&lt;code&gt;extern int toupper(int);&lt;/code&gt;来强制使用函数版本的toupper。&lt;/h4&gt;

&lt;h4 id="65malloccallocfreefree"&gt;65. malloc、calloc要和free封装在一个函数内，否则容易在free的时候跳出&lt;/h4&gt;

&lt;h4 id="66assertassertdebugrelease"&gt;66. assert用在函数检查参数的时候非常方便。如果该函数需要保证参数输入的条件，用assert，这样保证输入参数有问题的时候可以在debug的时候发现，而release版又不会产生性能上的影响。&lt;/h4&gt;

&lt;h4 id="67autostatic"&gt;67. 函数不能返回auto型的变量，但是可以返回static声明的静态变量。&lt;/h4&gt;

&lt;h4 id="68rigister"&gt;68. rigister类型只对块内的变量有效，由于没有地址，因此取地址运算符&amp;amp;是无效的。&lt;/h4&gt;

&lt;h4 id="69externstatic"&gt;69. 函数的类型只有extern 和static两种，前者加与不加是一样的，后者使得函数只能在本文件内调用。&lt;/h4&gt;

&lt;h4 id="70externintii"&gt;70. 对于某个文件内的全局变量，在另一个文件的函数内可以使用extern int i来获得之前的定义的变量。但是此时i在该文件中只有该函数的作用域。&lt;/h4&gt;

&lt;h4 id="71intx10void"&gt;71. 处理复杂的声明时：始终从内向外读声明；做选择时，始终先[]和（）后是*，越先选取的，就越是它的本质。如：&lt;code&gt;int *(*x[10])(void);&lt;/code&gt;是&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;x[10],数组；&lt;/li&gt;
&lt;li&gt;*，指向函数的指针数组；&lt;/li&gt;
&lt;li&gt;void，指向无参数函数的指针数组；&lt;/li&gt;
&lt;li&gt;int *，指向返回整型指针的无参数函数的指针数组。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以利用typedef来定义中间类型，简化理解过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;typedef int *Fcn(void);&lt;/li&gt;
&lt;li&gt;typedef Fcn *Fcn_ptr;&lt;/li&gt;
&lt;li&gt;typedef Fcn_ptr Fcn_ptr_array[10];&lt;/li&gt;
&lt;li&gt;Fcn_ptr_array x;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意不能出现以下情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int f(int)[];(函数不能返回数组)&lt;/li&gt;
&lt;li&gt;int g(int)(int);（函数不能返回函数）&lt;/li&gt;
&lt;li&gt;int a[10](int);（函数型数组不存在）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="72"&gt;72. 可以用下列技巧来在一个工程中合理的分配公有私有的函数：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token property"&gt;#define PUBLIC &lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;/*empty*/&lt;/span&gt;
&lt;span class="token property"&gt;#define PRIVATE static&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在声明函数的时候用上述修饰符来声明函数的定义范围了。&lt;/p&gt;

&lt;h4 id="73ijiji0i"&gt;73. i&amp;gt;&amp;gt;j的值是i右移j位的结果。如果i是无符号数或非负值，左端补0；i是负值，则由实现定义的。因此最好仅对无符号数移位。&lt;/h4&gt;

&lt;h4 id="74t01"&gt;74. ~0可以得到一个全部数位为1的数字。&lt;/h4&gt;

&lt;h4 id="75"&gt;75. &amp;amp;^|优先级低于判等和关系运算符，因此一般使用位运算符都用括号。&lt;/h4&gt;

&lt;h4 id="76"&gt;76. 位运算惯用法：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置位 &lt;code&gt;i |= 0x0010&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;位清0 &lt;code&gt;i &amp;amp;= ~0x0010&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;测试位 &lt;code&gt;if (i &amp;amp; 0x0010)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="77structdateunsignedintday5month4year7scanf0"&gt;77. 结构体中可以在变量声明的时候在后边加冒号和数字来声明一个位域，如&lt;code&gt;struct date { unsigned int day:5 ,month: 4, year:7}&lt;/code&gt;.但是使用的时候位域不可以使用&amp;amp;来取地址，因此scanf要先读入到普通变量后再赋值。也可以在位域声明的时候不起名字，起到占位的作用。长度为0的位域则强制下一个位域放在一个存储单元的起始位置(用于对齐)。&lt;/h4&gt;

&lt;h4 id="78unionint_dateunsignedintistructdatefddatesizeintdateiint"&gt;78. 联合常常用来用多种形式显示数字。比如&lt;code&gt;union int_date {unsigned int i; struct date fd;};&lt;/code&gt;其中date结构体是代码中已经声明过的，size等同int。这样按照date类型存储后可以通过i得到一个int型的数字。&lt;/h4&gt;

&lt;h4 id="79byteppbyte0x1000dosbytefarppmk_fpsegmentoffset"&gt;79. 指定一个指针的地址：如果计算机的指针和长整型一致，则可以直接赋值：&lt;code&gt;BYTE *p; p = (BYTE*) 0x1000;&lt;/code&gt;如果是实模式的dos程序，则使用&lt;code&gt;BYTE far *p; p = MK_FP(segment, offset);&lt;/code&gt;&lt;/h4&gt;

&lt;h4 id="80volatilevolatilep"&gt;80. 对于直接从用户输入缓冲得到的字符，需要用volatile 限定符声明中间变量。否则循环中中间变量没有变化过，可能被编译器优化后，使得每次读取中间变量时都是读取第一次的值。用volatile声明后编译器就会强制每次读取p的值时都从内存中重新获取。如：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;while (缓冲区未满) 
{
 等待输入;
 buffer[i] = *p;
 if (buffer[i++] == '\n') break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处的p就需要用volatile 声明。&lt;/p&gt;

&lt;h4 id="81isprintdefineisprintcundefisprintc"&gt;81. 系统库里的很多函数都用宏重新封装过，如isprint()函数被重新定义为&lt;code&gt;#define isprint(c)&lt;/code&gt;宏。要使用函数版本而不是宏的时候（比如函数指针），可以用#undef 宏名来取消它的宏定义；也可以用(isprint)(c)来强制个别调用时是函数。&lt;/h4&gt;

&lt;h4 id="82offsetofstructscharaintb2floatcoffsetstructsa0"&gt;82. 宏offsetof参数是类型、指定成员，会计算起点到指定成员的字节数。如&lt;code&gt;struct s {char a;int b[2]; float c;} offset(struct s,a)&lt;/code&gt;的结果为0。&lt;/h4&gt;

&lt;h4 id="83fflushfpfpcommitfflushnullcommit0eoffp12"&gt;83. 可以用fflush(fp)来强制让fp指针的状态commit到硬盘。fflush(NULL)可以把所有的文件指针commit。没有错误返回0，有错返回EOF。fp必须处于（1）输出打开（2）为更新打开并且流的最后操作不是读，也就是说，是用来“清理”输出流的。&lt;/h4&gt;

&lt;h4 id="84setvbufstream"&gt;84. 使用setvbuf函数必须在stream的任何操作之前使用。&lt;/h4&gt;

&lt;h4 id="85rawfflush"&gt;85. r+、a+、w+在转换读或者写的时候，必须用文件定位函数将读转为写，或者用fflush或文件定位函数将写转为读。&lt;/h4&gt;

&lt;h4 id="86filenametmpnamnulltmpnamfilename"&gt;86. &lt;code&gt;filename = tmpnam(NULL);&lt;/code&gt;或者 &lt;code&gt;tmpnam(filename)&lt;/code&gt;都可以生成临时的文件名。&lt;/h4&gt;

&lt;h4 id="87printf"&gt;87. Printf类函数完整说明：&lt;/h4&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;&lt;td&gt;标志&lt;/td&gt;&lt;td&gt;最小字段宽度&lt;/td&gt;&lt;td&gt;精度&lt;/td&gt;&lt;td&gt;长度修饰符&lt;/td&gt;&lt;td&gt;转换说明符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;#0&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;.5&lt;/td&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;g&lt;/td&gt;
&lt;/tr&gt;   
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;标志&lt;/em&gt;：可选项，允许多余一个。所有标志如下：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;标志&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;&lt;td&gt;在字段内左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;&lt;td&gt;以+开头的正符号数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空格&lt;/td&gt;&lt;td&gt;空格取代正符号数的+号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;&lt;td&gt;以0开头的八进制数，以0x开头的16进制数。浮点数始终是十进制。不能删除g或者G输出数的尾部0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0(零)&lt;/td&gt;&lt;td&gt;用前导0填充宽度。如果是制定了精度的d、i、o、u、x，则忽略前导0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;最小字段宽度&lt;/em&gt;：可选项。如果字符数太少达不到字段宽度最小值，则对字符数量扩充（默认在左侧添加空格）。如果超过字段宽度，则完整的显示。如果宽度是*，则宽度由下一个参数决定。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;精度&lt;/em&gt;：可选项。精度含义依赖于转换说明符：如果转换说明符是d、i、o、u、x、X，则精度表示最少数字位数，少于时左侧加0；如果是e、E、f，那么精度是小数点后的数位；如果是g、G，则表示最大有效位数；如果是s，则表示最大字符数；如果只有小数点，则精度为0；如果是*，则由下一个参数决定。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;长度修饰符&lt;/em&gt;：可选项，h说明是short型的，l是long型的，L说明是long double型的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;转换说明符&lt;/em&gt;：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明符&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d、i&lt;/td&gt;&lt;td&gt;有符号整数的十进制形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O、u、x、X&lt;/td&gt;&lt;td&gt;8进制、10进制、或16进制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;&lt;td&gt;十进制double型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E、e&lt;/td&gt;&lt;td&gt;科学计数法的double型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G、g&lt;/td&gt;&lt;td&gt;自动选择f还是e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;&lt;td&gt;自动选择f还是e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;&lt;td&gt;字符串输出，达到精度时或者遇到结尾时停止。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;&lt;td&gt;void *型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;&lt;td&gt;匹配的实参必须是指向int的指针。可以和h和l搭配。会将输出的字符数量存储到指针指向的地址而不输出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;字符%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;：（。表示空格）&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对123的结果&lt;/td&gt;&lt;td&gt;对-123的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8d&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-8d&lt;/td&gt;&lt;td&gt;123。。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%+8d&lt;/td&gt;&lt;td&gt;。。。。+123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;% 8d&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%08d&lt;/td&gt;&lt;td&gt;00000123&lt;/td&gt;&lt;td&gt;-。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-+8d&lt;/td&gt;&lt;td&gt;+123。。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%- 8d&lt;/td&gt;&lt;td&gt;。123。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%+08d&lt;/td&gt;&lt;td&gt;+0000123&lt;/td&gt;&lt;td&gt;-0000123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;% 08d&lt;/td&gt;&lt;td&gt;。0000123&lt;/td&gt;&lt;td&gt;-0000123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对123的结果&lt;/td&gt;&lt;td&gt;对123.0的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8o&lt;/td&gt;&lt;td&gt;。。。。。173&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8o&lt;/td&gt;&lt;td&gt;。。。。0173&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8x&lt;/td&gt;&lt;td&gt;。。。。。。7b&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8x&lt;/td&gt;&lt;td&gt;。。。。0x7b&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8X&lt;/td&gt;&lt;td&gt;。。。。。。7B&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8X&lt;/td&gt;&lt;td&gt;。。。。0X7B&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8g&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8g&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。123。000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8G&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8G&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。123。000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对"bogus"的结果&lt;/td&gt;&lt;td&gt;对"buzzword"的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%6s&lt;/td&gt;&lt;td&gt;。bogus&lt;/td&gt;&lt;td&gt;buzzword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-6s&lt;/td&gt;&lt;td&gt;bogus。&lt;/td&gt;&lt;td&gt;buzzword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%.4s&lt;/td&gt;&lt;td&gt;bogu&lt;/td&gt;&lt;td&gt;buzz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%6.4s&lt;/td&gt;&lt;td&gt;。。bogu&lt;/td&gt;&lt;td&gt;。。buzz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-6.4s&lt;/td&gt;&lt;td&gt;bogu。。&lt;/td&gt;&lt;td&gt;buzz。。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;数&lt;/td&gt;&lt;td&gt;对%.4g产生的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;123456&lt;/td&gt;&lt;td&gt;1.235e+05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12345.6&lt;/td&gt;&lt;td&gt;1.235e+04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1234.56&lt;/td&gt;&lt;td&gt;1235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;123.456&lt;/td&gt;&lt;td&gt;123.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12.3456&lt;/td&gt;&lt;td&gt;12.35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.23456&lt;/td&gt;&lt;td&gt;1.235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.123456&lt;/td&gt;&lt;td&gt;0.1235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0123456&lt;/td&gt;&lt;td&gt;0.01235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.00123456&lt;/td&gt;&lt;td&gt;0.001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.000123456&lt;/td&gt;&lt;td&gt;0.0001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0000123456&lt;/td&gt;&lt;td&gt;0.00001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.00000123456&lt;/td&gt;&lt;td&gt;0.000001235&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;其它&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;printf("%6.4d",i)等价于printf("%*.4d",6,i);printf("%6.*d",4,i);printf("%*.*d",6,4,i);&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;printf("%d%n",123,&amp;amp;len);&lt;/td&gt;&lt;td&gt;输出123&lt;/td&gt;&lt;td&gt;输出后len==3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h4 id="88scanf"&gt;88. scanf类完整说明：&lt;/h4&gt;

&lt;p&gt;scanf类函数在输入失败或者匹配失败的时候会提前返回。返回值是读入并赋值给实参的数据数量。因此可以用&lt;code&gt;while (scanf("%d",&amp;amp;i) == 1){...}&lt;/code&gt;来循环读取，直到读取失败为止。&lt;/p&gt;

&lt;p&gt;格式化串的组成：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;字符*&lt;/em&gt;：可选项。*出现意味着赋值屏蔽：读入此项，但是不赋值。*匹配的数据项不计入scanf类函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;最大字段宽度&lt;/em&gt;：可选项。限制了输入项字符的数量。如果开始时跳过了空白字符，对空白字符不进行统计。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;h、l和L&lt;/em&gt;：同printf类函数的含义。&lt;/p&gt;

&lt;p&gt;转换说明符：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明符&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;&lt;td&gt;匹配十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;&lt;td&gt;匹配整数，假定数是十进制的，除非0开头（8进制），或0x开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;&lt;td&gt;匹配八进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;&lt;td&gt;匹配十进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X、x&lt;/td&gt;&lt;td&gt;匹配十六进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E、e、f、g、G&lt;/td&gt;&lt;td&gt;匹配float型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;&lt;td&gt;匹配一序列非空字符串，并在末尾加'\0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;&lt;td&gt;匹配来自扫描集合的非空字符序列，然后在末尾添'\0'。可以是%[集合]或者%[^集合]，前者匹配集合内的字符，后者匹配集合外的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;&lt;td&gt;匹配其字段宽度的字符数，如果没有字段宽度，则匹配1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;&lt;td&gt;匹配printf输出相同的指针值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;&lt;td&gt;将目前为止的读入字符数存入此int指针指向的变量，没有输入会匹配，scanf的返回值也不受影响。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;匹配%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;示例：（。表示空格）&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;scanf的调用&lt;/td&gt;&lt;td&gt;输入&lt;/td&gt;&lt;td&gt;变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。&lt;/del&gt;，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d,%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12&lt;/del&gt;。，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d。,%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。，。34&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d,。%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12&lt;/del&gt;。，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*d%d",&amp;amp;i);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。34&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:1;i:34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*s%s", str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;My。Fair&lt;/del&gt;。Lady'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"Fair"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%1d%2d%3d",&amp;amp;i,&amp;amp;j,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12345&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:1;j:23;k:45;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%2d%2s%2d",&amp;amp;i,str,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;123456&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:12;str:"34";k:56;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%i%i%i",&amp;amp;i,&amp;amp;j,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。012。0x12&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:12;j:10;k:18;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[0123456789]",str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;123&lt;/del&gt;abc'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"123";&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[0123456789]",str);&lt;/td&gt;&lt;td&gt;abc123'\n'&lt;/td&gt;&lt;td&gt;n:0;str:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[^0123456789]",str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;abc&lt;/del&gt;123'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"abc";&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*d%d%n",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;10。20&lt;/del&gt;。30'\n'&lt;/td&gt;&lt;td&gt;n:1;i:20;j:5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h4 id="89scanfnstr"&gt;89. 如上所述，&lt;code&gt;scanf ("%[^\n]",str);&lt;/code&gt;可以轻松得到一行文字。&lt;/h4&gt;

&lt;h4 id="90ungetcchfpgetcungetcgetcintchgetcfpeof"&gt;90. &lt;code&gt;ungetc(ch,fp);&lt;/code&gt;可以轻松回退一次上次的getc操作，只保证第一次ungetc的调用是成功的。注意，getc所保存的应当是int型数据，否则&lt;code&gt;(ch = getc(fp)) ！= EOF&lt;/code&gt; 可能会导致错误的结果。&lt;/h4&gt;

&lt;h4 id="91ftellfpfp"&gt;91. ftell(fp)函数中fp如果是文本流，则返回的值不一定是字节计数，因此最好不要进行算术运算。&lt;/h4&gt;

&lt;h4 id="92sprintfsscanfsprintfstrdisscanf"&gt;92. 可以用sprintf和sscanf对字符串进行读写操作。比如&lt;code&gt;sprintf(str,"%d",i);&lt;/code&gt;sscanf则实现了对一次输入的多重检测读取，如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;sscanf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"%d /%d/%d"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token number"&gt;3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Month: %d, day: %d, year: %d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;sscanf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"%d -%d -%d"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token number"&gt;3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Month: %d, day: %d, year: %d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Date not in the proper form.\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="93printfnum1dapplesdapplenum"&gt;93. 可以将格式化串和问号表达式一起用，比如printf(num &amp;gt; 1 ? "%d apples.":"%d apple.",num);&lt;/h4&gt;

&lt;h4 id="94ltfloathgtltlimitshgtltmathhgterrnofmod552211"&gt;94. 库的宏定义范围：&amp;lt;float.h&amp;gt;浮点型的特性；&amp;lt;limits.h&amp;gt;整值类型的大小；&amp;lt;math.h&amp;gt;数学计算（出错时多数会写入errno变量中），其中包含fmod（5.5,2.2） = 1.1；&lt;/h4&gt;

&lt;h4 id="95size_tstrxfrmchars1constchars2size_tns2s1"&gt;95. size_t strxfrm(char *s1, const char *s2, size_t n);该函数将s2转换后存在s1，返回转换后的字符数量。一般都是用两次：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;size_t len&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;transformed&lt;span class="token punctuation"&gt;;&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strxfrm&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt; original&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
transformed &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;malloc&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;len&lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;strxfrm&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;transformed&lt;span class="token punctuation"&gt;,&lt;/span&gt; original&lt;span class="token punctuation"&gt;,&lt;/span&gt; len&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="96strpbrkstrspnstrcspnsize_tstrspnstrcspn"&gt;96. strpbrk函数用来查找第一个参数中与第二个参数中任意一个字符相匹配的最左边的一个字符；strspn和strcspn会返回一个表示字符串中特定位置的整数(size_t类型)，strspn返回第一个不属于给定字符集的字符下标；strcspn函数返回第一个属于给定字符集中的字符下标，如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;size_t len&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;char&lt;/span&gt; str&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"Form follows function."&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;"morF"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=4*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;" \t\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=0*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strcspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;"morF"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=0*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strcspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;" \t\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=4*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="97memset0memset0"&gt;97. memset可以将数组全初始化为0，但是对于浮点数、结构体等，不是memset可以完全置0；&lt;/h4&gt;

&lt;h4 id="98ltasserthgtdefinenodebugassert"&gt;98. &amp;lt;assert.h&amp;gt;可以使用#define NODEBUG禁用assert&lt;/h4&gt;

&lt;h4 id="99lterrnohgterrnoedomerange"&gt;99. &amp;lt;errno.h&amp;gt;errno变量用来存储数学函数错误。EDOM表示定义域错误，ERANGE表示值域错误，通常是太大。&lt;/h4&gt;

&lt;h4 id="100ltsignalhgtvoidsignalintsigvoidfuncintintfuncsigabortraisesignalsigabrtsigfpesignalsigsegv"&gt;100. &amp;lt;signal.h&amp;gt;&lt;code&gt;void (*signal(int sig, void (*func)(int)))(int);&lt;/code&gt;作用是用自定义的func函数替换原先与sig相对性的函数。返回值是原先的函数指针。除非是abort或者raise函数引发的signal，否则不要用库函数，或者试图使用一个静态存储期限的变量。从处理函数返回时程序将从信号发生点继续运行，除了信号SIGABRT（终止程序），和SIGFPE（未定义）。信号处理完毕后，除非处理函数重新安装，否则该信号不会被同一函数再次处理。因此可以在返回之前再用signal函数重新安装。SIGSEGV表示段错误，调试时应该很有用。&lt;/h4&gt;

&lt;h4 id="101"&gt;101. 在字符串中小心放置??。如果要放置??，可以用?\?来代替。否则会被认为是三字符序列。&lt;/h4&gt;

&lt;h4 id="102setlocalelc_allcsetlocalelc_allnullllabc"&gt;102. 任意程序开始时都隐含执行&lt;code&gt;setlocale(LC_ALL,"C");&lt;/code&gt;如果运行&lt;code&gt;setlocale(LC_ALL,NULL);&lt;/code&gt;则会返回当前区域设置。对于宽字符常量需要用L修饰，如L"abc"。&lt;/h4&gt;

&lt;h4 id="103"&gt;103. 用来检测多字符和宽字符：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; mbcheck`&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;s&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;mblen&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; s &lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token operator"&gt;=&lt;/span&gt; n&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;n &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;mblen&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;,&lt;/span&gt; MB_CUR_MAX&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;wccheck&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;wchar_t &lt;span class="token operator"&gt;*&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;char&lt;/span&gt; buf&lt;span class="token punctuation"&gt;[&lt;/span&gt;MB_LEN_MAX&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;for&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;wctomb &lt;span class="token punctuation"&gt;(&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token operator"&gt;++&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;
        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;n &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;wactomb&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;buf&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;buf&lt;span class="token punctuation"&gt;[&lt;/span&gt;n &lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token string"&gt;'\0'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;wctomb (NULL,0)&lt;/code&gt;这个函数是用来初始化多字符状态的。&lt;/p&gt;

&lt;p&gt;mbstowcs和wcstombs可以转换字符串，返回修改字符串的个数。&lt;/p&gt;

&lt;h4 id="104ltstdarghgt"&gt;104. &amp;lt;stdarg.h&amp;gt;提供的三种宏可以视为三个函数：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;va_start&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;,&lt;/span&gt; parmN&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
类型 &lt;span class="token function"&gt;va_arg&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;,&lt;/span&gt; 类型&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;va_end&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过第一个函数设置valist的可变参数是从哪里开始；第二个函数是从valist中返回下一个参数（不必手动增加，每次调用会自增），其类型为指定类型；第三个参数结束参数的调用，此时方可返回。声明函数时使用&lt;code&gt;int max(int n,...)&lt;/code&gt;即可。&lt;/p&gt;

&lt;h4 id="105ltstdlibhgtsrandrand1"&gt;105. &amp;lt;stdlib.h&amp;gt;对于相同的种子，srand()将生成相同的随机数列。rand()函数获得随机数列的下一个值。选择1作为种子值和没有指明种子值是一样的。&lt;/h4&gt;

&lt;h4 id="106atexit"&gt;106. 可以通过atexit(函数名)来指定退出时自动调用的方法。&lt;/h4&gt;

&lt;h4 id="107getenvpathsystem0"&gt;107. getenv函数会返回指定字串在操作系统中某个字符串的意义，比如PATH。该结果储存在静态空间中，稍后函数调用时会改变。system用来执行外部命令，如果命令为空指针，则对命令环境测试，如果命令处理程序有效，则返回非0值。&lt;/h4&gt;

&lt;h4 id="108"&gt;108. 搜索和排序：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token function"&gt;bsearch&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;key&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;base&lt;span class="token punctuation"&gt;,&lt;/span&gt;size_t nmemb&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t size&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;compar&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token keyword"&gt;void&lt;/span&gt; qsort &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;base&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t nmemb&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t size&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;compar&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="109divldivdiv_tquotrem"&gt;109. /和%与实现有关，因此可以用div和ldiv代替，前者用于整型，后者用于长整型。返回div_t类型，可用quot和rem求商和余数。效率是使用它们而不是/和%的原因，因为可以在一个指令里计算出两个结果。&lt;/h4&gt;</content:encoded><guid>http://blog.shrp.me//Understanding-Of-Restudy-C.html</guid></item><item><title>C语言研究：编写一个函数，返回一个指向另一个函数的指针</title><link>http://blog.shrp.me//C-Study-A-Method-That-Return-A-Pointer-Point-To-An-Other-Method.html</link><pubdate>2011-04-24</pubdate><content:encoded>&lt;p&gt;有函数int func(int a);
要求编写函数，返回指向func的函数指针。
实现：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token property"&gt;#include &lt;span class="token property"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="token property"&gt;#include &lt;span class="token property"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;func&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; a&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token function"&gt;wishedFunc&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; func&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;main&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;test&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    test &lt;span class="token operator"&gt;=&lt;/span&gt; func&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;test&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token function"&gt;wishedFunc&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"OK!\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded><guid>http://blog.shrp.me//C-Study-A-Method-That-Return-A-Pointer-Point-To-An-Other-Method.html</guid></item><item><title>到底应该怎样打造一支健康的软件团队？（语文写作课上的遐想）</title><link>http://blog.shrp.me//How-To-Build-A-Healthy-SoftWare-Team.html</link><pubdate>2011-03-12</pubdate><content:encoded>&lt;p&gt;　　软件工程是一门年轻的科学，很多概念、方法，至今都在摸索之中。比如说，如何形成一支健康的、易于成功的软件团队，依然是那些顶级的秘密，即便是有过上百次成功经验的项目经理、团队管理者，依然会说这种成功的过程建立在团队当时情况之上的，是不可复制的。&lt;/p&gt;

&lt;p&gt;　　到底为什么呢？&lt;/p&gt;

&lt;p&gt;　　我们经常看到软件领域的两种比喻：很多老师、方法、软件组织的管理者都把做软件比作是盖楼房，要有人设计、制造，要有良好的接口，要易于维护，等等。唯有这样，才能工业化大规模生产。也有很多组织中的程序员把写程序比作写作文，要写代码，就要想写作文一样，避免打扰，专心致志，还要有灵感，才能才思泉涌。&lt;/p&gt;

&lt;p&gt;　　我们要注意两个问题：一，这两类比喻有着行为学和方法论上的差别，是不能同时存在于一个团队中的；二，第一类说的是做软件，第二类说的是写程序。我相信，正是管理层和执行层概念的差别才是造成软件团队问题的根源。大家都在各说各话，怎么能统一步伐走向共同的目标呢？&lt;/p&gt;

&lt;p&gt;　　做软件和写程序有区别吗？或者说，软件和程序有区别吗？&lt;/p&gt;

&lt;p&gt;　　程序（program）是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。 软件是一系列按照特定顺序组织的计算机数据和指令的集合。（以上来自百度百科）说实话，我之前的概念来自于课堂，就是程序是小的、个人性质的玩意，而软件则是带有商业目的的一套产品；而看了百度百科，反倒好像两者一样了。&lt;/p&gt;

&lt;p&gt;　　那如果两者一样，为什么会有差异如此大的两种方法呢？&lt;/p&gt;

&lt;p&gt;　　那么就应该是看问题角度导致的差异了吧。管理层，作为现代经济体中的获益方，势必会想办法融入成熟的现代商业模式中，自然而然的把问题想成像是工业化大生产的模式，因为这样个人对于公司的影响就很小了，不可能出现一个普通的人事变动对公司造成大的影响。然而程序员作为决策的执行者，却时刻感受到工业化生产和编码过程方法论的不同，造成实际上的执行力低下。最明显的是我第一次实训的时候，虽然模块、功能都划分好了，让大家按部就班，但是结果很多人不能按时完成规定的任务，很多功能都堆到了最后。当然，这个问题最直接的原因是课业负担，但是我认为根本问题是想用工业化的方法来安排软件流程是必然不能顺利的。&lt;/p&gt;

&lt;p&gt;　　那么完全按照写作文的方法呢？小峰做组长的时候我觉得就是这样的方法，但是也没成功。他的方法是规划了某个这个模块后，模块负责人要发挥自己的主观能动性，完全自觉自动的完成这个模块。虽然完全交由组员了，却使得控制力失去了。&lt;/p&gt;

&lt;p&gt;　　由此我觉得这次实训我再次作为组长，方法要改一改。首先在大体上要自己规划，但是小块上边，除了接口外，剩下的要由他们自己实现。对于时间上边我要求每次任务都有时间的约束，每次耽误时间的交付都将扣除一定的分数直到及格线。一旦被扣到及格线，该名同学也就不必继续完成任务。他对于集体就不再负有责任了。交付的时候是有提交标准的，比如，要在测试用例里面编译通过（最基本要求），要有一定的质量。编译不过比没有交付好一些，不过少扣些分数而已。&lt;/p&gt;

&lt;p&gt;　　总之，就是大体上，是个工业化分工合作的过程；在细节上，是个人比较自由的创作时间。或许这样可以打造一个比较成功的团队。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//How-To-Build-A-Healthy-SoftWare-Team.html</guid></item><item><title>使用GtkBuilder设计Gtk+界面</title><link>http://blog.shrp.me//Using-GTKBuilder-design-UI.html</link><pubdate>2011-03-08</pubdate><content:encoded>&lt;p&gt;1、使用glade设计Gtk+界面,保存为gtkbuilder文件,比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0"?&amp;gt;
&amp;lt;!--Generated with glade3 3.4.5 on Sun Nov 29 12:39:11 2009 --&amp;gt;
&amp;lt;interface&amp;gt;
  &amp;lt;object class="GtkWindow" id="window1"&amp;gt;
    &amp;lt;child&amp;gt;
      &amp;lt;object class="GtkVBox" id="vbox1"&amp;gt;
        &amp;lt;property name="visible"&amp;gt;True&amp;lt;/property&amp;gt;
        &amp;lt;child&amp;gt;
          &amp;lt;object class="GtkImage" id="image1"&amp;gt;
            &amp;lt;property name="visible"&amp;gt;True&amp;lt;/property&amp;gt;
            &amp;lt;property name="pixbuf"&amp;gt;stallman.jpg&amp;lt;/property&amp;gt;
          &amp;lt;/object&amp;gt;
        &amp;lt;/child&amp;gt;
        &amp;lt;child&amp;gt;
          &amp;lt;object class="GtkLabel" id="label1"&amp;gt;
            &amp;lt;property name="visible"&amp;gt;True&amp;lt;/property&amp;gt;
            &amp;lt;property name="label" translatable="yes"&amp;gt;Richard Stallman&amp;lt;/property&amp;gt;
          &amp;lt;/object&amp;gt;
          &amp;lt;packing&amp;gt;
            &amp;lt;property name="position"&amp;gt;1&amp;lt;/property&amp;gt;
          &amp;lt;/packing&amp;gt;
        &amp;lt;/child&amp;gt;
      &amp;lt;/object&amp;gt;
    &amp;lt;/child&amp;gt;
  &amp;lt;/object&amp;gt;
&amp;lt;/interface&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、编写程序，调用GtkBuilder&lt;/p&gt;

&lt;pre class=" language-cpp"&gt;&lt;code class=" language-cpp"&gt;&lt;span class="token property"&gt;#include &amp;lt;gtk/gtk.h&amp;gt;&lt;/span&gt;

&lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;window_close&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;GtkWidget &lt;span class="token operator"&gt;*&lt;/span&gt;widget&lt;span class="token punctuation"&gt;,&lt;/span&gt;gpointer data&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
  &lt;span class="token function"&gt;gtk_main_quit&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;main&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; argc&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;argv&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
  GtkBuilder &lt;span class="token operator"&gt;*&lt;/span&gt;builder &lt;span class="token operator"&gt;=&lt;/span&gt; NULL&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  GError &lt;span class="token operator"&gt;*&lt;/span&gt;error &lt;span class="token operator"&gt;=&lt;/span&gt; NULL&lt;span class="token punctuation"&gt;;&lt;/span&gt;     &lt;span class="token comment" spellcheck="true"&gt; //注意要初始化变量！！！
&lt;/span&gt;  GtkWidget &lt;span class="token operator"&gt;*&lt;/span&gt;window &lt;span class="token operator"&gt;=&lt;/span&gt; NULL&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token function"&gt;gtk_init&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;argc&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;argv&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  builder&lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token function"&gt;gtk_builder_new&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token function"&gt;gtk_builder_add_from_file&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;builder&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"fsf.ui"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;error&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
 window&lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token function"&gt;GTK_WIDGET&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token function"&gt;gtk_builder_get_object&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;builder&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"window1"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token function"&gt;g_object_unref&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token function"&gt;G_OBJECT&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;builder&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
 &lt;span class="token function"&gt;g_signal_connect&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;window&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"destroy"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token function"&gt;G_CALLBACK&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;window_close&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token function"&gt;gtk_widget_show_all&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;window&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token function"&gt;gtk_main&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
  &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、用cb编译运行，OK！ &lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Using-GTKBuilder-design-UI.html</guid></item><item><title>打造在windows下边的跨平台C语言代码编译环境</title><link>http://blog.shrp.me//Cross-PlantForm-C-compilation-in-windows.html</link><pubdate>2011-03-08</pubdate><content:encoded>&lt;p&gt;　　这几天下来实在是为了这套系统折腾了不少，今天写下来，不仅仅是为了总结这几天的经验，更重要的是为了后来的人更好的搭建工作平台。&lt;/p&gt;

&lt;p&gt;　　如今最受欢迎的跨平台开源C语言IDE就是code::blocks了，目前版本10.05。虽然它自己带有minGW，但是那个安装包稍微有点大，而且版本稍微低了点。因此首先我们安装gcc，提供的版本是4.4.4。一路顺风安装下去。安装后检查下系统路径（我的电脑，属性，高级，环境变量，系统变量，path，在最后添加gcc的路径）&lt;/p&gt;

&lt;p&gt;　　gcc安装好了就安装code::blocks，一路下一步。先别急启动，打开安装目录，将汉化补丁放在【CodeBlocks主目录】\share\CodeBlocks\locale下边。第一次启动时会询问默认编译器，应该是找不到gcc的，不过可以点gcc，默认。进入程序后打开设置，environment，view，选择Chinese，重启程序。再打开设置，编译器和调试器，可执行工具链，根据你的gcc安装路径配置一下gcc安装；路径和程序文件。其中有几个文件名字跟原先的程序不同名，不过还是很容易找到相应的程序的。至此，大部分人的跨平台IDE就已经可以使用了。&lt;/p&gt;

&lt;p&gt;　　但是总有一些高级的要求，比如说，cunit进行单元测试。这个东东很有意思，我现在也没弄明白怎么玩，不过要用是没有问题的。首先下载cunit2.1.0（不要选用2.1.2，在windows安装有问题，也不好跟code::blocks集成），解压到你的工程目录下。进入CUnit，CUnit，用code::blocks打开CUnit.dsp,编译。编译后把生成的libCUnit.a改名为CUnit。然后向上，到Examples下边，把ExampleTests.c和ExampleTests.h添加到每个测试文件夹下边，然后把用code::blocks打开每个文件夹下边的dsp文件，根据引用的关系，把CUnit相应缺失的文件复制过来，添加到工程中。之后想要进行C的单元测试，直接打开这样的工程，将相应的测试加入exampletests.c就好了。也可以直接下砸我修改好的包。&lt;/p&gt;

&lt;p&gt;　　此外还有GUI库。一个常用C++GUI库是wxwidget，可以用wxFormBuilder制作界面，很好很强大，除了是c++以外真是没有缺点了。可惜我不会C++ （T_T）,但是还是要推荐出来。这个安装也不算麻烦，打开安装包，安装到一个位置，用cmd进入安装目录下的build\msw，执行make -f makefile.gcc BUILD=release SHARED=1 UNICODE=1 ，经过漫长的等待，终于编译好了。打开cb，在设置，全局变量的wx中设置wx安装目录，ok，新建一个，是不是能用了？嘿嘿。&lt;/p&gt;

&lt;p&gt;　　不过对于我来说，最常用的GUI库是GTK，谁让我只会C呢，没办法（囧）。GTK可以直接安装glade的包，因为做界面很多人用glade，直接安装很方便(如果不行，请下载gtk多合一解压缩即解即用包，覆盖即可)。这个就不用编译了，在cb的全局变量里面加入gtk和相应的全局变量就搞定了。更加简单了吧？&lt;/p&gt;

&lt;p&gt;　　ok，所有的测试代码均由cb自动生成，一试便知。诸位晚安。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Cross-PlantForm-C-compilation-in-windows.html</guid></item><item><title>Virtualbox NAT模式下配置端口映射</title><link>http://blog.shrp.me//Virtualbox-NAT-port-forwarding.html</link><pubdate>2011-03-07</pubdate><content:encoded>&lt;p&gt;在VirtualBox NAT网络模式下面，Guest系统对Host系统和局域网内其他的机器都是不可见的，所以Guest上面的任何服务都不能被外界访问到。这样很多情况下，是不能接受的，比如想在Guest系统为Ubuntu的虚拟机上面开启SSH服务，怎么办呢？两个方法，1、把网络连接方式改成Bridge模式，这样虚拟机的Guest系统就有了自己的IP地址，相当于局域网内的一台主机，这样Host系统和局域网内的其他机器都可以访问他了。2、在NAT网络模式下，开启端口映射。需要什么服务就映射什么端口数据。今天我以VirtualBox的guest系统Ubuntu系统开启SSH服务为例来介绍怎么配置端口映射。&lt;/p&gt;

&lt;p&gt;首先介绍一下NAT网络模式下端口映射的优点，首先节省一个IP地址（有些情况下，IP地址资源比较宝贵）；其次，这样可以避免Server暴露过多的接口，提供什么服务暴露什么接口，这样保证Server安全性。当然这种方式也有一定的局限性，服务的端口必须是固定的，假如服务的端口是动态的，那么这种方式就没有办法了，比如NFS服务就不能用端口映射来实现。&lt;/p&gt;

&lt;p&gt;下面介绍怎样在VirtualBox的Guest系统Ubuntu中启用SSH服务，Host系统为Windows。SSH服务的端口是22端口，理论上可以把Host系统Windows的22端口映射到Ubuntu的22端口。这样做不好，假如有一天Host系统Windows也要在22端口上提供服务就没有办法了，所以我们准备用Host系统的2222端口，映射到Ubuntu的22端口。&lt;/p&gt;

&lt;h5 id="1virtualbox"&gt;1. 首先从命令行进入到VirtualBox安装目录。&lt;/h5&gt;

&lt;h5 id="2vboxmanageexevirtualbox32"&gt;2. 在安装目录下面，目录下面有VBoxManage.exe程序。如果你的VirtualBox版本是3.2之前的版本，请执行如下的命令：&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;VBoxManage setextradata "Linux Guest" "VBoxInternal/Devices/pcnet/0/LUN#0/Config/guestssh/Protocol" TCP

VBoxManage setextradata "Linux Guest" "VBoxInternal/Devices/pcnet/0/LUN#0/Config/guestssh/GuestPort" 22

VBoxManage setextradata "Linux Guest" "VBoxInternal/Devices/pcnet/0/LUN#0/Config/guestssh/HostPort" 2222
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中“Linux Guest”是你虚拟机Ubuntu系统的名称，pcnet表示Ubuntu选的是PCNet的网卡，0表示第一块网卡，guestssh是自定义的名字。TCP表示只映射TCP协议的数据，当然也可以设置成UDP协议数据映射的。&lt;/p&gt;

&lt;p&gt;通过以上命令就可以完成Host Windows系统2222端口到Guest Ubuntu系统的端口映射了。当然需要三个命令来完成端口映射挺麻烦的，Oracle公司也这样认为。在最新的3.2版本中，VirtualBox简化了端口映射的步骤，只要一条命令就可以了。
&lt;code&gt;VBoxManage modifyvm "VM name" --natpf1 "guestssh,tcp,,2222,,22"&lt;/code&gt;
“VM name”就是Guest系统的名字，guestssh还是用户自定义的名字。你可能发现第三个参数和第五个参数空白了，是什么意思呢？当Host系统有多块网卡的时候，通过第三个参数指定那款网卡的2222端口映射；如果Host系统有多块网卡时，通过第五个参数指定那个网卡的22端口接收数据。
&lt;code&gt;VBoxManage modifyvm "VM name" --natpf1 "guestssh,tcp,,2222,10.0.2.19,22"&lt;/code&gt;
以上的命令式将Host系统2222端口的数据映射到Guest系统的10.0.2.10网卡的22端口。&lt;/p&gt;

&lt;h5 id="3ubuntusshserver"&gt;3. 已经设置好了端口映射，现在登录到Ubuntu中，安装SSH server。&lt;/h5&gt;

&lt;p&gt;sudo apt-get install openssh-server4、在Windows平台下面用ssh工具，通过2222端口登录到Ubuntu就可以了。也可以从局域网内的机器上，用SSH工具，通过Host机器的2222端口登录到Ubuntu的ssh服务。&lt;/p&gt;

&lt;p&gt;至此，Ubuntu的SSH服务已经暴露在局域网了。通过上面的描述可以看到在VirtualBox3.2版本中端口映射已经做得比较简单，并且非常完善了。&lt;/p&gt;

&lt;p&gt;如有错误欢迎指正。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Virtualbox-NAT-port-forwarding.html</guid></item><item><title>目标达成</title><link>http://blog.shrp.me//goal-achieved.html</link><pubdate>2011-03-07</pubdate><content:encoded>&lt;p&gt;电脑上的盗版软件一扫而空，心情不由得开始舒畅起来，哈哈。如果说有遗憾，那就是virtual box性能确实不如vmware好，好像也没有端口映射，以后ubuntu怎么远程连接又是个麻烦事了。&lt;/p&gt;

&lt;p&gt;project据说有个gantt什么东西可以画，visio也有类似的在线软件。还要继续寻找。&lt;/p&gt;

&lt;p&gt;此外还有一些微软的powertools还没有装，但是为了避免移动硬盘也成为shadowUser的还原目标，明天用pe开机拷贝吧。&lt;/p&gt;

&lt;p&gt;下一步的目标是给新浪写一个简历，看看能不能得到实习机会。然后把网站按照前几天的计划改进一下。然后把C语言最后几章的习题做了，拖了将近一年了，真囧。&lt;/p&gt;

&lt;p&gt;这样就可以总结一篇C语言的心得，嘿嘿。&lt;/p&gt;

&lt;p&gt;加油，继续前进，goon！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//goal-achieved.html</guid></item><item><title>自己的下一个目标</title><link>http://blog.shrp.me//my-next-goal.html</link><pubdate>2011-03-06</pubdate><content:encoded>&lt;p&gt;将系统中的盗版软件基本全部清理。&lt;/p&gt;

&lt;p&gt;之所以是基本，是因为我的xp是盗版（虽然有正版xp，不过却给小笔记本装了）。不过好在我还有正版vista，而且是闲置不用，就当是把授权转给xp吧。&lt;/p&gt;

&lt;p&gt;还有就是office无可替代，尤其是visio、project。这个专业要用，没有办法了。&lt;/p&gt;

&lt;p&gt;连同写网页的phpdesigner也是盗版，很惭愧，今后用gvim吧。&lt;/p&gt;

&lt;p&gt;服务器也是盗版（汗……）只不过实在需要虚拟路径。等赚钱后再买正版的支持下，呵呵。&lt;/p&gt;

&lt;p&gt;其它软件，就参照-·」&lt;a href="http://blog.sina.com.cn/s/blog_46dac66f0100003u.html"&gt;http://blog.sina.com.cn/s/blog_46dac66f0100003u.html&lt;/a&gt;这个来替换吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//my-next-goal.html</guid></item><item><title>网站下一步开发方向</title><link>http://blog.shrp.me//next-develop-of-my-site.html</link><pubdate>2011-03-06</pubdate><content:encoded>&lt;p&gt;添加多图办法：先制作8个网页，分别是添加0-7个图片。这下就可以图文并茂了。&lt;/p&gt;

&lt;p&gt;添加删除文章办法，这个有点麻烦，可以是修改到文章就像从来没有一样，也可以做到添加删除线。这个慢慢考虑吧。&lt;/p&gt;

&lt;p&gt;文章后加留言，不用翻页。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//next-develop-of-my-site.html</guid></item></channel>
</rss>