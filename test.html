<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
test

~~~~{cpp}

//#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cctype>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

int iRead()
{
	int ret = 0;
	int ch;
	while(!isdigit(ch = getchar()) && ch != '-');
	bool bm = (ch == '-'); if(bm) ch = getchar();
	while(ret = ret * 10 + (ch - '0'), isdigit(ch = getchar()));
	return bm ? -ret : ret;
}

const int N = 300003;
const int STP = 100000;
struct iT;
iT *q[N];
struct iT
{
    iT *fa, *ch[2];
    int val, s;
    bool rev;
    #define iDir(c) ((c)->fa->ch[1] == (c))
    void up()
    {
        s = 1 + 
            (ch[0] ? ch[0]->s : 0) + 
            (ch[1] ? ch[1]->s : 0);
    }
    void down()
    {
        if(!rev) return;
        rev = 0;
        swap(ch[0], ch[1]);
        if(ch[0]) ch[0]->rev ^= 1;
        if(ch[1]) ch[1]->rev ^= 1;
    }
    void rot() // 把this转到fa的位置 
    {
        iT *f = fa;
        if(f->fa) f->fa->ch[iDir(f)] = this;
        int dr = iDir(this);
        fa = f->fa, f->fa = this;
        if(ch[!dr]) ch[!dr]->fa = f;
        f->ch[dr] = ch[!dr], ch[!dr] = f;
        f->up(), up();      // !!!! 此时f已经是this的孩子了 
    }
    iT *splay(iT *tag = NULL) // 把this转到tag下，返回this 
    {
        iT **p = q;
        for(iT *i = this; i != tag; i = i->fa)
            *p++ = i;
        while(p != q)
            (*--p)->down();
        for(; fa != tag; rot())
            if(fa->fa != tag)   // 双旋的情况 
                (iDir(this) == iDir(fa) ? fa : this)->rot();
        return this;
    }
    iT *select(int k) // 取rank k 从0开始 
    {
        down();
        int sl = ch[0] ? ch[0]->s : 0;
        if(sl == k)
            return this;
        else if(k < sl)
            return ch[0]->select(k);
        else
            return ch[1]->select(k - sl - 1);
    }
    iT *min()
    {
        iT *c = this;
        while(c->down(), c->ch[0])
            c = c->ch[0];
        return c;
    }
}ss[N], *sp = ss;
int arr[N];

// 建[l,r)的高度平衡splay 像线段树一样 感觉快一点 当然也可以一个个insert & splay 
iT *iMake(int l, int r, iT *f = NULL)
{
    if(l >= r) return NULL;
    int m = (l + r) >> 1;
    iT *c = sp++;
    *c = (iT){
        f, 
        {iMake(l, m, c), iMake(m + 1, r, c)}, 
        arr[m], r - l, false
    };
    return c;
}

int n;

int main()
{
    n = iRead();
    for(int i = 0; i < n; ++i)
        arr[i] = iRead();
    iT *rt = iMake(0, n);
    int i;
	for(i = 0; i <= STP; ++i)
	{
        int c = rt->min()->val;
        if(c == 1)
            break;
        if(c == n)          // !!!! 特判翻转全部的情况 
            rt->rev ^= 1;   // 否则下面会select(n) 然后炸掉 
        else
        {
            rt = rt->select(c)->splay(); // splay完，根已经换了 
            rt->ch[0]->rev ^= 1;
        }
	}
	printf("%d\n", i <= STP ? i : -1);
	fclose(stdout);
	return 0;
}

~~~~
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>test</p>

<p>~~~~{cpp}</p>

<p>//#include <iostream></iostream></p>

<h1 id="includecstdio">include <cstdio></cstdio></h1>

<h1 id="includecstdlib">include <cstdlib></cstdlib></h1>

<h1 id="includecstring">include <cstring></cstring></h1>

<h1 id="includecmath">include <cmath></cmath></h1>

<h1 id="includealgorithm">include <algorithm></algorithm></h1>

<h1 id="includecctype">include <cctype></cctype></h1>

<p>using namespace std;
typedef long long ll;
typedef unsigned long long ull;</p>

<p>int iRead()
{
    int ret = 0;
    int ch;
    while(!isdigit(ch = getchar()) &amp;&amp; ch != '-');
    bool bm = (ch == '-'); if(bm) ch = getchar();
    while(ret = ret * 10 + (ch - '0'), isdigit(ch = getchar()));
    return bm ? -ret : ret;
}</p>

<p>const int N = 300003;
const int STP = 100000;
struct iT;
iT <em>q[N];
struct iT
{
    iT *fa, *ch[2];
    int val, s;
    bool rev;
    #define iDir(c) ((c)-&gt;fa-&gt;ch[1] == (c))
    void up()
    {
        s = 1 + 
            (ch[0] ? ch[0]-&gt;s : 0) + 
            (ch[1] ? ch[1]-&gt;s : 0);
    }
    void down()
    {
        if(!rev) return;
        rev = 0;
        swap(ch[0], ch[1]);
        if(ch[0]) ch[0]-&gt;rev ^= 1;
        if(ch[1]) ch[1]-&gt;rev ^= 1;
    }
    void rot() // 把this转到fa的位置 
    {
        iT *f = fa;
        if(f-&gt;fa) f-&gt;fa-&gt;ch[iDir(f)] = this;
        int dr = iDir(this);
        fa = f-&gt;fa, f-&gt;fa = this;
        if(ch[!dr]) ch[!dr]-&gt;fa = f;
        f-&gt;ch[dr] = ch[!dr], ch[!dr] = f;
        f-&gt;up(), up();      // !!!! 此时f已经是this的孩子了 
    }
    iT *splay(iT *tag = NULL) // 把this转到tag下，返回this 
    {
        iT *</em>p = q;
        for(iT <em>i = this; i != tag; i = i-&gt;fa)
            *p++ = i;
        while(p != q)
            (</em>--p)-&gt;down();
        for(; fa != tag; rot())
            if(fa-&gt;fa != tag)   // 双旋的情况 
                (iDir(this) == iDir(fa) ? fa : this)-&gt;rot();
        return this;
    }
    iT *select(int k) // 取rank k 从0开始 
    {
        down();
        int sl = ch[0] ? ch[0]-&gt;s : 0;
        if(sl == k)
            return this;
        else if(k &lt; sl)
            return ch[0]-&gt;select(k);
        else
            return ch[1]-&gt;select(k - sl - 1);
    }
    iT *min()
    {
        iT *c = this;
        while(c-&gt;down(), c-&gt;ch[0])
            c = c-&gt;ch[0];
        return c;
    }
}ss[N], *sp = ss;
int arr[N];</p>

<p>// 建[l,r)的高度平衡splay 像线段树一样 感觉快一点 当然也可以一个个insert &amp; splay 
iT *iMake(int l, int r, iT *f = NULL)
{
    if(l &gt;= r) return NULL;
    int m = (l + r) &gt;&gt; 1;
    iT *c = sp++;
    *c = (iT){
        f, 
        {iMake(l, m, c), iMake(m + 1, r, c)}, 
        arr[m], r - l, false
    };
    return c;
}</p>

<p>int n;</p>

<p>int main()
{
    n = iRead();
    for(int i = 0; i &lt; n; ++i)
        arr[i] = iRead();
    iT *rt = iMake(0, n);
    int i;
    for(i = 0; i &lt;= STP; ++i)
    {
        int c = rt-&gt;min()-&gt;val;
        if(c == 1)
            break;
        if(c == n)          // !!!! 特判翻转全部的情况 
            rt-&gt;rev ^= 1;   // 否则下面会select(n) 然后炸掉 
        else
        {
            rt = rt-&gt;select(c)-&gt;splay(); // splay完，根已经换了 
            rt-&gt;ch[0]-&gt;rev ^= 1;
        }
    }
    printf("%d\n", i &lt;= STP ? i : -1);
    fclose(stdout);
    return 0;
}</p>

<p>~~~~</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "test.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
