<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>搬瓦工免费换 ip</title><link>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</link><pubdate>2018-06-26</pubdate><content:encoded>&lt;p&gt;前两天我的搬瓦工突然被封禁了，一大票技术网站无法访问，实在不方便。登录搬瓦工想找地方换 IP，发现这个基础款的产品自己不支持换 IP 换机房。正在想实在不行就得还供应商的时候，突然搜到搬瓦工针对此情况专门提供了免费更换 IP 的功能，每十周换一次，还是挺爽的。&lt;/p&gt;

&lt;p&gt;这个功能就是当你确信你的机器被墙了，可以访问&lt;a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck"&gt;https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck&lt;/a&gt;，此时会提示检测 ip，&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Xnip2018-06-26_12-01-04.jpg" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;然后点击 Test Main IP，如果检测到被封禁，就会出现 next 按钮，自然点击 next 按钮更换 IP 就好啦。&lt;/p&gt;

&lt;p&gt;最后别忘记去域名管理把你服务器的域名 A 记录换掉哦！要不然域名还是无法访问的！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</guid></item><item><title>一个USB-C的时代</title><link>http://blog.shrp.me//An-Era-of-USB-Type-C.html</link><pubdate>2018-06-15</pubdate><content:encoded>&lt;p&gt;最近为了配合在家用电脑的显示器需求，买了一台联想的ThinkVision显示器——&lt;a href="https://item.jd.com/4702716.html"&gt;联想（ThinkVision）T27h 27英寸窄边框 &lt;/a&gt;，用了几天，颇有些感想。&lt;/p&gt;

&lt;p&gt;首先，这货有一个坏点。显然联想在显示器的品控并不太好，而且国家的政策里坏点是允许的，而且越大的屏幕坏点允许就越多。当然我可以按照京东7天无条件去退换，可是这款显示器推出快一年了，按照系统显示，它的库存不多了，按照二手东的情况，可能剩下的多少有点问题。这款是我唯一能够找到价格比较低，带有USB-Hub功能的USB-C可充电可旋转显示器了（其实还有一款三星的，但是为了老回，必须不买三星的）。还好的是一个坏点并不是太大的问题，如果你观察你自己的显示器，其实上边落满了灰尘，一个坏点的影响就像是一粒灰尘，并不太影响。事实上，当你打开游戏，打开电影的时候，这个坏点根本就看不到。所以这次为二手东接了盘，感觉也还可以接受。&lt;/p&gt;

&lt;p&gt;虽然显示器有个坏点，但是功能上来说，它真的非常适合我的情况。我目前手里有三套设备，一个台式机，一个新版MacBook Pro，一台GPD pocket。台式机是没有USB-Type C的接口的，视频走HDMI接口；但是苹果本和pocket都是支持Type C接口的。我的电脑桌桌面空间很紧凑，键鼠当然只能有一套，如何用这一套键鼠控制三台电脑，关键只能是怎么利用显示器的USB-Hub功能了。&lt;/p&gt;

&lt;p&gt;然而显示器的USB-Hub是Type-C接口是host，四个普通USB接口去接键鼠。这个原理就像是那些Type-C的转接器一样，只不过转接器的视频输出直接接入显示器的视频输入了而已。那么Pocket和苹果本天然就应该支持边充电边视频输出，并且接到显示器的键鼠也可以用。结果我试了一下，不论是用苹果还是绿联买的一根充电线，还是显示器自带的Type-C线，都只能让苹果本使用，Pocket只能充电，不能显示视频，也无法实现USB-Hub。不过我插上了一款&lt;a href="https://item.jd.com/10391831021.html"&gt;绿联的0.5米长的线&lt;/a&gt;时，奇迹发生了，Pocket也能边充电边显示视频，还能使用接入的键鼠了。Perfect！&lt;/p&gt;

&lt;p&gt;不过还有一个麻烦，就是台式机怎么接入呢？台式机没有Type-C接口，没法直接使用。最简单的方法是电脑用一根Type-C的数据线（一头是Type-A的公头，另一头是Type-C的公头）我之前设想的是买一款Type-C的延长线（一公头一母头）接到显示器，一根USB Type-A公头转USB Type-C公头的普通数据线来连接。当用台式机的时候，就是&lt;code&gt;台式机--A转C数据线--延长线--显示器&lt;/code&gt;；当用苹果本的时候，就是&lt;code&gt;苹果本--C双公头的数据线--延长线--显示器&lt;/code&gt;。结果这个方案失败了：延长线是有逻辑的，公头是host，母头是client。但是在我的设计里，延长线的母头被用来连接host电脑了，公头插到显示器上，跟设计的方向是反的，现在只能充电显示，USB-HUB功能不能用，三个设备都不能。不过我又心生一计，电脑上用一个USB Type-A公头转USB-Type-C母头的转换器，再连到显示器，是不是就可以把显示器当成是USB-Hub了呢？这个情况下的连接是&lt;code&gt;电脑--公A转母C--C双公头的数据线--显示器&lt;/code&gt;，跟苹果本切换的时候只要把“双公头的数据线”连到公A转母C就可以了啊。这个方案理论上可行，赶紧去京东下单买转接头了，大概明天才能验证。&lt;/p&gt;

&lt;p&gt;不过不管验证情况怎么说，Type-C开始在电脑和手机上引领的接口风暴，怕是会越来越激烈了。对于用户来说，一个统一的接口价值相当的重要。恐怕只有等无线连接到来的时候，Type-C才会被淘汰了吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//An-Era-of-USB-Type-C.html</guid></item><item><title>联通IPTV诺基亚贝尔机顶盒怎么安装第三方应用</title><link>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</link><pubdate>2018-04-06</pubdate><content:encoded>&lt;p&gt;由于旧的IPTV盒子坏了，今天抽空去联通换了个IPTV，是上海诺基亚贝尔的S-010W-AV2B机器。拿回来以后IPTV功能都正常，但是一个安卓机顶盒不装点其他应用，那多浪费啊。没想到U盘插上去，傻眼了：apk都不显示，这可咋安装啊？&lt;/p&gt;

&lt;p&gt;一般来说这个方法应该有很多种，比如同一网络下用悟空遥控去推送，比如用USB线连到电脑上安装，比如连上键盘，按快捷键打开网页下载apk。可是一一试过以后发现都不能用，adb没有开，快捷键也被关闭了。&lt;/p&gt;

&lt;p&gt;正手足无措的时候，发现系统点击官方的应用商城居然会下载一个apk安装。嗯？如果我劫持url，下载一个贝当市场，问题不就迎刃而解了吗？&lt;/p&gt;

&lt;p&gt;具体步骤如下：
1、找了个电脑，设置网络共享。我家的IPTV方案是机顶盒通过光猫的wifi上网的，那么我的网络共享就是电脑连光猫的wifi，把网络共享给自己的网线，通过网线连接到IPTV机顶盒。&lt;/p&gt;

&lt;p&gt;2、装上wireshark抓包&lt;/p&gt;

&lt;p&gt;3、在机顶盒点击联通自己的应用商城，成功在wireshark里抓到了http请求地址：http://210.13.0.175:7084/launcher/data/1522120317/CUTV_DSMClient_V4.5.apk&lt;/p&gt;

&lt;p&gt;4、在自己电脑上架设一个网站（要监听所有的设备哦），在相应的地址，相同的文件名放一个贝当应用商店的apk。但是ip地址怎么办？别担心，我在电脑上添加了一个虚拟网卡，地址设置为静态的210.13.0.175，这样请求上来的时候自动就被路由到自己的这个网卡上了。如果你的自建站点按照我的提示监听了电脑所有的网卡，那么这个时候通过你电脑访问的下载请求都会被指向自己的假冒apk了。&lt;/p&gt;

&lt;p&gt;5、把机顶盒的商店卸载掉，再点击安装，很快进度条就走完了，只不过99%的时候提示验证错误，大概是安装后有个验证流程，还需要劫持后修改下，不过不要紧，就算不修改，apk已经安装好了。&lt;/p&gt;

&lt;p&gt;6、最后记得把自己的电脑的网络共享关掉，机顶盒连到正常的网络下下载你想要的apk吧。需要看IPTV的时候，把机顶盒连到光猫的IPTV的wifi下，就可以正常看IPTV了；需要看网络电视的时候，就连到普通wifi下看第三方apk的视频啦。&lt;/p&gt;

&lt;p&gt;最后强调一下，每个人的机顶盒访问的地址不一定一样，因此你一定要自己抓个包，才可能有效。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</guid></item><item><title>HG220GS-U改桥接模式</title><link>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</link><pubdate>2018-04-05</pubdate><content:encoded>&lt;p&gt;前两天联通宽带续费升级，原来的百兆猫要换成千兆猫，新猫型号是HG220GS-U.我自己有需要把光猫后的路由器映射到公网去,因此一般都会做dmz或者端口映射.联通原来的猫就有bug,dmz设置不生效,必须要挨个做端口映射;这个新猫更过分,dmz和端口映射均不生效.还好在网上搜到老周的一篇教程&lt;a href="http://guanggai.org/thread-459-1-1.html"&gt;烽火HG220G-U E00L2.03M2000光猫改桥接教程&lt;/a&gt;,解决了问题.&lt;/p&gt;

&lt;p&gt;原文里也有点小问题,telnet节点不必打开,后续操作也用不上telnet,而且telnet一旦打开,从外网也可以telnet到的,用户名admin,密码admin,只怕没几分钟就已经被攻陷了.其他操作均与原文相同.&lt;/p&gt;

&lt;p&gt;为了防止原链接失效,简单讲过程记在下边:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;登录光猫管理页面&lt;a href="http://192.168.1.1/"&gt;http://192.168.1.1/&lt;/a&gt;,默认用户名user,密码在光猫背后.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录后访问&lt;a href="http://192.168.1.1/backupsettings.conf"&gt;http://192.168.1.1/backupsettings.conf&lt;/a&gt;,将现有的配置文件保存并且备份,不管什么时候都能轻易恢复原有配置了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用notepad++或者sublime编辑一个配置文件的副本,先找到&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括IPTV的那个配置,北京联通通常出现在&amp;lt;WANConnectionDevice instance="4"&amp;gt;下,可以看到该配置的X_BROADCOM_COM_IfName的属性是epon0.4.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再找到上网的配置,也就是&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括INTERNET的那个配置,通常是&amp;lt;WANConnectionDevice instance="2"&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除该配置节点内的删除&amp;lt;IdleDisconnectTime&amp;gt;120&amp;lt;/IdleDisconnectTime&amp;gt;一整行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改该配置节点内的ConnectionType属性,从IP_Routed改为PPPoE_Bridged.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的名字从2_INTERNET_R_VID_3961改成2_INTERNET_B_VID_3961(也就是R改成了B),这个改动不知道是否必须&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的X_BROADCOM_COM_IfName属性从ppp0.2改成epon0.2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在该配置节点X_BROADCOM_COM_IfName后新增节点&amp;lt;X_CU_IPMode&amp;gt;3&amp;lt;/X_CU_IPMode&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href="http://192.168.1.1/updatesettings.html"&gt;http://192.168.1.1/updatesettings.html&lt;/a&gt;,选择上传配置,然后路由会自动重启,重启后就是桥接模式了,需要光猫后边的路由器或者电脑自己拨号才能上网了.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS:旧版的HG220GS是可以通过网址&lt;a href="http://192.168.1.1/logoffaccount.html"&gt;http://192.168.1.1/logoffaccount.html&lt;/a&gt;打开隐藏账户的,然后就可以通过&lt;a href="http://192.168.1.1/cu.html"&gt;http://192.168.1.1/cu.html&lt;/a&gt;登录管理员账户,用户名CUAdmin,密码123qweasdzxc.但是我的这个网页是不能访问的.隐藏账户登录后可以关闭端口扫描的防御来打开DMZ和端口映射功能.&lt;/p&gt;

&lt;p&gt;但是又有人说这种情况可以通过&lt;a href="http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1"&gt;http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1&lt;/a&gt;访问来开启隐藏账户,这个我就没有尝试了,大家可以自行尝试.&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</guid></item><item><title>程序员工作用什么操作系统？</title><link>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</link><pubdate>2018-03-10</pubdate><content:encoded>&lt;h1 id=""&gt;程序员工作用什么操作系统？&lt;/h1&gt;

&lt;p&gt;　　今天偶然看到之前关注的 vpsee 网站一篇09年的文章(&lt;a href="https://www.vpsee.com/2009/06/why-programmers-love-mac/"&gt;为什么国外程序员爱用 Mac？ | vpsee.com&lt;/a&gt;)在讨论为什么程序员喜欢用 Mac，文章后洋洋洒洒数百个评论或激昂，或讽刺，或诅咒，或炫耀，好不热闹。恰好最近一个.Net 开发同事想用 Mac 开发 Java 程序，一个 Java 开发 同事想把自己的 Mac 换成 Windows，真是有意思。于是我也按耐不住，想要说点什么。&lt;/p&gt;

&lt;p&gt;　　开始前我想先声明一下，如果说有人说这个话题没有偏颇，我真不太相信。每个人连颜色都有自己的偏好，操作系统这么复杂而又常用的东西如果没有喜好那也太大条了。我当然也不例外。就目前而言，我作为一个开发，是用 Mac 多一些，也喜欢用 Mac；但是我并不觉得每个程序员都用，或者每个程序员都喜欢用 Mac 是正常的，正相反，我觉得最多只有一半喜欢或者应该用 Mac来从事开发工作。&lt;/p&gt;

&lt;p&gt;　　先说 Windwos。Windows 借中国早先盗版的问题最先在群众中普及，我也不例外，从98年家里的第一台电脑开始就在用 Windows。这个系统我们用得多了，也就耳熟能详怎么去把玩到极致：从 DOS 时代在启动文件里调整虚拟内存，到9x 的简繁转换，再到 NT 内核系统的服务优化，再到 Windows10 的免费升级。应用怎么查杀，注册表的大体结构，游戏使用的 direct 技术和安装方法，不论是写代码，玩游戏，还是看电影听音乐，基本是无所不能。更不要说.NET 程序员了，目前来说只在 Windows 工作。甚至包括怎么分区，多久备份一次，怎么快速备份恢复，一个老 Windows 程序员估计都有自己的方案，以免在升级失败，电脑蓝屏时还不用耽误太久工作。尽管这些技能都跟程序开发没有直接关系，却能帮助我们尽快解决手头的问题，把精力集中在开发上。然而并不是程序员都是.NET 程序员，Windows 也不是100%契合所有开发人员的需求，有些问题会一而再再而三的坑害开发，比如说中文版 Windows 默认的字符编码是 GB2312，而大多数部署到 Linux 的软件都得处理 UTF-8。那么开发在部署的时候经常要注意自己的代码里处理字符集转换，一些文字要提前处理成 UTF-8。而且即便是在 Windows 保存为 UTF-8文件，还会面临另一个问题：BOM 头。在 Windows 上 BOM 一般不会惹什么麻烦，但是当部署到 Linux 服务器的时候，结果就不好说了；ImportNews 网站的 RSS 甚至就带有 BOM 头，而带有 BOM 头的 RSS 是不符合 XML 规范的。一个 Java 专业社区的组件都有这样的 bug，还能指望 Windwos 开发对于 Linux 开发有多友好呢？再比如说 Windows 的目录是分磁盘的，C:\，D:\等等，而且目录的分割用\而不是/。这对一些预计部署在 Linux 的服务的开发带来了负面的影响。再有就是孱弱的命令行环境了，自带的命令稀缺，Linux 的工具链工具几乎不支持，这对于工作面对 Linux 服务器的程序员来说都不是什么好事情。&lt;/p&gt;

&lt;p&gt;　　再说 Linux。我刚开始用 Linux 还是高三的时候，是很经典的小红帽 Red Hat，好像一共6张 CD 光盘。当时就是尝个鲜，装好了以后主要在窗口界面里乱用。后来工作后才真正开始学习怎么去用 Linux，看《鸟哥的 Linux 私房菜》，把服务部署到 Linux 服务器上，但是当时开发还是 Windows。在进行了1年的 跨平台开发后，被字符集坑惨的我开始用最流行的 Ubuntu 来开发程序，当时使用的是 Ubuntu10 LTS。 Ubuntu确实简单易上手，互联网上也充斥着大量使用 Ubuntu 的经验，基本上遇到什么问题都能用搜索引擎得到质量比较高的回答。Linux 跟生产的环境是相当契合的，不太容易出现环境部署的问题。但是 Ubuntu 最大的问题就是官方仓库东西还是不够，必须添加私有源；可是私有源到了后期却或多或少带有的陈旧核心组件，都可能存在不同乃至冲突。有时候甚至为了看 flash，装个 vpn 而安装的某个源带入的依赖跟系统最新的根本不搭，导致后续的更新都不能应用了。解决问题一定是有方法的，但是却需要开发者投入不少的精力去跟踪操作系统里发生了什么冲突，怎么去解决。此后我还用过 cent OS，Mint，Arch，然而大同小异，总是因为系统里安装的什么东西不兼容，从而系统没法完整升级。这种情况一开始可能只是几个包，但是后来不满足依赖的升级越来越多，而且有时候为了某个特定的需要，比如 docker，还不得不升级。这些冲突解决起来痛苦而且耗费时间，因此Linux最适合还是放在服务器里，不出事情几年都想不起升个级的。&lt;/p&gt;

&lt;p&gt;　　至于 Mac 么，真的是我用过最省心的操作系统了。插上移动硬盘就自动备份，不管是换电脑，还是出问题重装系统，都可以在一个小时左右恢复搞定，而且恢复以后打开浏览器，上次没关闭的窗口还热乎着呢。目录符合 unix 风格，程序跑起来没什么毛病。工具链也有，很多脚本都是可以直接用的。用 Mac 开发，既可以不断享受升级，又不会太折腾，可以把精力集中在代码本身。不过 Mac 也不是完全没有问题。就我自己遇到的就有这么几种情况：每次升级都有可能一些安全性的提升导致某些软件用不了；1024以下的端口默认不可以被用户程序占用；命令其实是 BSD 版本的，参数跟 Linux 上的并不一致；默认文件系统不是大小写敏感的，甚至很多软件都不支持在大小写敏感的分区上使用（没想到吧）；并不太可能做到完全不用鼠标，不过用鼠标的次数还是可以比较少的。&lt;/p&gt;

&lt;p&gt;　　在我看来，其实并没有一个最合适的电脑。如果想省心省力，能够集中精力去开发的，也就是 Mac 了，这也是大多数中年程序员的首选，每天除了工作还要肩负养家糊口的重担，没有太多时间去折腾设备，用一款 Mac 可以帮助他们做到这点。如果是刚刚开始工作的程序员，有大把时间去折腾，那选择一款 Linux 长时间使用就比较合适，能够更熟悉自己软件部署的环境，写出的代码就更容易减少出 bug 的可能，如果剩下的软件也能维护好升级和依赖的关系，配置的足够好，免鼠标什么的没问题，开发效率也可以得到提升。至于剩下的程序员，或者要开发 Windows 程序，或者 Windows 非常熟悉，或者对系统差异足够熟悉的，用 Windows 开发并不会给他们带来不便。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</guid></item><item><title>一个不严谨的 String Intern 测试</title><link>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</link><pubdate>2018-01-15</pubdate><content:encoded>&lt;p&gt;　　今天在 Reeder 上看到一个关于 String Intern 的&lt;a href="http://www.importnew.com/27694.html"&gt;文章&lt;/a&gt;，自己测试了一下，发现有些地方并不严谨。&lt;/p&gt;

&lt;p&gt;　　原文用了一段如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public static void main(String[] args) {
    String s = new String("1");
    s.intern();
    String s2 = "1";
    System.out.println(s == s2);
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    System.out.println(s3 == s4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目的很明确，希望通过==判断 intern 能否为下一次赋值从 intern 的池里提供。然而这段代码做了一个假设：在 main 函数之前，没有任何字符串被 intern。&lt;/p&gt;

&lt;p&gt;　　然而我在Java8以上测试，却发现了有意思的情况。考虑以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;    public static void main(String[] args) {
        String s =  String.valueOf(1) + String.valueOf(1);
        s.intern();
        String s2 = "11";
        System.out.println(s == s2);

        String s3 = String.valueOf(1) + String.valueOf(2);
        s3.intern();
        String s4 = "12";
        System.out.println(s3 == s4);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　按照原文作者的假设，结果应该都是 true 才对，第一次 intern 的时候该对象保存进入常量，第二次赋值的时候取出，因此==的两个结果是 true。&lt;/p&gt;

&lt;p&gt;　　但是在我的机器和其他同事的机器上却发现有人是 false，true，有人是 false，false，有人是 true，true。也就是说，JVM 根据某些信息提前进行了 intern，这种 intern 操作来自哪里，我暂时还不知道，有知道的同学可以帮忙在回复里解释一下。&lt;/p&gt;

&lt;p&gt;　　BTW，调用 intern 却不是用其返回值作为对象，那么这次使用的对象不一定是在 Intern 里存储的那个对象，使用==的结果并不是确定的。这种类似 C 的未定义行为，不能作为 Java 特性的说明，也不能在生产代码里使用，原文的原理是正确的，但是代码却没有说服力了。这从另一个角度提醒我们写代码还是要大胆假设，小心求证。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</guid></item><item><title>简单的Http客户端——OKHttp</title><link>http://blog.shrp.me//simple-http-client-okhttp.html</link><pubdate>2017-12-21</pubdate><content:encoded>&lt;p&gt;&lt;a href="https://github.com/square/okhttp"&gt;OKHttp&lt;/a&gt;支持以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;http/2支持，同一个host可以共享一个端口&lt;/li&gt;
&lt;li&gt;如果http/2不支持，则使用连接池降低请求延迟&lt;/li&gt;
&lt;li&gt;透明gzip请求的返回&lt;/li&gt;
&lt;li&gt;可以针对重复的网络请求进行缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下文将分几个方向介绍OKHttp：&lt;/p&gt;

&lt;p&gt;1.引用&lt;/p&gt;

&lt;p&gt;当前最新版本是3.9.1，使用maven仓库引入即可，maven配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gradle 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;compile 'com.squareup.okhttp3:okhttp:3.9.1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.先引入一个函数来表示具体的请求，后边的执行大多会使用这个函数来发起具体的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private static Response executeRequest(final OkHttpClient okHttpClient, final Request build) {
        try {
            final Response response = okHttpClient.newCall(build).execute();
            if (response.isSuccessful()) {
                System.out.println(response.code() + " : " + response.body().string().length());
            } else {
                System.out.println(response.code());
            }
            return response;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.基本的get请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple get: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.基本的post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MediaType parse = MediaType.parse("application/json");
        final RequestBody requestBody = RequestBody.create(parse, "{}");
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(requestBody)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple post: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.multipart post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MultipartBody form = new MultipartBody.Builder().addFormDataPart(
                "test", "test"
        ).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(form)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("multipart post: ");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.带有缓存功能的get&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_NETWORK)
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("cached get: ");
        final Response response = executeRequest(okHttpClient, build);
        assert response.networkResponse() != null;
        final Request request2 = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_CACHE)
                .addHeader("client-version", "3.9.1")
                .build();
        final Response response2 = executeRequest(okHttpClient, request2);
        assert response2.cacheResponse() != null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.异步请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("async get: ");
        okHttpClient.newCall(build).enqueue(new Callback() {
            @Override
            public void onFailure(final Call call, final IOException e) {
                System.out.println(call.request().url() + " is failed. " + e.getMessage());
            }

            @Override
            public void onResponse(final Call call, final Response response) throws IOException {
                if (response.isSuccessful()) {
                    System.out.println(response.code() + " : " + response.body().string().length());
                } else {
                    System.out.println(response.code());
                }
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.带有拦截器的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt; final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache)
                .addInterceptor(chain -&amp;gt; {
//                    System.out.println("intercept 1.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 1 return.");
                    return proceed;
                })
                .addInterceptor(chain -&amp;gt; {
                    System.out.println("intercept 2.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 2 return.");
                    return proceed;
                })
                .addNetworkInterceptor(chain -&amp;gt; {
                    System.out.println("network intercept.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("network intercept return.");
                    return proceed;
                })
                .build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("intercept get: ");
        executeRequest(okHttpClient, build);
        System.out.print("intercept get from cache: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.还可以添加认证器，在异步调用后使用cancel取消等功能。&lt;/p&gt;

&lt;p&gt;okhttp的api更易用，据说性能也不错。以后有机会可以进行性能的比较。本文代码可以在&lt;a href="https://github.com/stirp/MyTests"&gt;https://github.com/stirp/MyTests&lt;/a&gt;找到。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//simple-http-client-okhttp.html</guid></item><item><title>在Mac OS X管理多个Java环境</title><link>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</link><pubdate>2017-12-18</pubdate><content:encoded>&lt;p&gt;　　Java刚出了Java9，Java10也在日程上了。然而Java的相关环境实在是太多，对于某些增强型的组件，是依赖某个特定版本的Java进行工作的，当手头的项目多，不得不对不同版本的Java进行开发的时候，就必须来回不停切换版本，实在是不方便。其实不同版本的Java目录是不同的，完全可以同时存在。通过本文介绍的工具Jenv就可以管理本机的多个Java环境，并且通过简单的配置就可以让指定项目使用特定的Java版本，无需再进行反复切换了。这个工具本身还是开源的，地址就在&lt;a href="https://github.com/gcuisinier/jenv"&gt;https://github.com/gcuisinier/jenv&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　先要强调，Jenv是个脚本软件，作用环境限于shell环境内，如果是使用IDE比如eclipse，Intellij，那它体现不出它自己的价值，毕竟IDE一般都具有管理JDK的功能。安装Jenv的方式很简单，直接clone到~/.jenv中，然后把bin目录添加到系统路径中，重启shell就好啦。&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; git clone https://github.com/gcuisinier/jenv.git ~/.jenv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; vim ~/.local/share/omf/init.fish&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; cp fish/jenv.fish ~/.config/fish/functions/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　在文件中添加&lt;code&gt;set PATH $HOME/.jenv/bin $PATH&lt;/code&gt;。这是fish shell的安装方式，其他方式可以参考官方文档。&lt;/p&gt;

&lt;p&gt;　　装好以后通过&lt;code&gt;jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home&lt;/code&gt;可以将安装在该目录下的Java添加到jenv中。目前的jenv在fish上有点问题，jenv默认有两个文件夹不存在，因此需要先执行&lt;code&gt;mkdir ~/.jenv/versions&lt;/code&gt; 和 &lt;code&gt;mkdir ~/.jenv/plugins&lt;/code&gt;先建立目录才能执行jenv add和jenv enable-plugins.&lt;/p&gt;

&lt;p&gt;　　Jenv有两个环境，global和local，分别对应全局jdk和文件夹内的jdk版本指定。对于我来说，一般全局使用最新的Java版本，在不能使用最新Java的文件夹内执行&lt;code&gt;jenv local 1.8.0&lt;/code&gt;来指定比如1.8.0版本。如果使用了maven，gradle等编译管理软件，需要用&lt;code&gt;jev enabel-plugin maven&lt;/code&gt;来重定向mvn命令，以便maven也使用指定的Java版本。其他工具，比如gradle，原理是类似的。&lt;/p&gt;

&lt;p&gt;　　有了这个工具，从此再也不怕多种版本的Java开发啦！&lt;/p&gt;

&lt;p&gt;Update 12.19:&lt;/p&gt;

&lt;p&gt;　　对于fish来说，启动的时候需要执行jenv rehash，来确保java由jenv管理。最简单的方法在~/.config/fish/conf.d/omf.fish里增加&lt;code&gt;jenv rehash&lt;/code&gt;即可。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</guid></item><item><title>碰巧发现一个水友电脑中了病毒</title><link>http://blog.shrp.me//find-a-cyber-friend-get-his-computer-infected-by-computer-virus.html</link><pubdate>2017-09-20</pubdate><content:encoded>&lt;p&gt;　　今天恰好看到有人在玩星际菠菜，我想起早以前在YY玩菠菜的经历，心理痒痒，也想试试手气，于是也打开网站上去找找菠菜的入口在哪里。&lt;/p&gt;

&lt;p&gt;　　没成想打开唯一的live.htm，却没发现菠菜的入口。难道入口屏蔽了？于是F12看看吧，不看不要紧，一看吓一跳，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Jietu20170920-145708.png" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;　　虽然咱不太懂vbscript，但是这段代码大致意思还是看得懂的：先找到一个路径，尝试写入一些二进制数据，然后调用运行这个文件，文件名是svchost.exe。这个名字不就是Windows系统最常用的系统进程嘛！这段代码看起来就是个病毒啊！&lt;/p&gt;

&lt;p&gt;　　然后用二进制编辑软件把这段二进制保存起来，提交&lt;a href="https://www.virustotal.com/zh-cn/file/fd6c69c345f1e32924f0a5bb7393e191b393a78d58e2c6413b03ced7482f2320/analysis/"&gt;在线工具&lt;/a&gt;，提示极大可能是病毒,创建病毒文件于C:\Program Files\Microsoft\DesktopLayer.exe。赶紧跟对方反应了这个问题，最终确认他电脑中了DesktopLayer病毒，所有机器都感染了，可能还有水友也因为观看直播中病毒。后续处理就简单了，网上有专杀工具，搜索下载就好了，据说专杀效果还是挺不错的。&lt;/p&gt;

&lt;p&gt;　　病毒实在是很难防范，搞得我都想装个iOS虚拟机上网了……哈哈，当然是玩笑了。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//find-a-cyber-friend-get-his-computer-infected-by-computer-virus.html</guid></item><item><title>面对勒索病毒的数据备份方案</title><link>http://blog.shrp.me//importance-of-backup.html</link><pubdate>2017-05-15</pubdate><content:encoded>&lt;p&gt;估计大家这几天都被勒索病毒刷了屏，我也来凑凑热闹，简单说下我的方案——备份。&lt;/p&gt;

&lt;p&gt;看到这里读者大概会觉得我大概是石乐志，备份有什么难的，普天下的人都会备份，还要你出来讲啊。但是如果你深入思考一下勒索病毒的特点，你会发现传统的备份方案在勒索病毒进一步发展后很有可能无效。&lt;/p&gt;

&lt;p&gt;首先，备份一般按时效分，有实时备份和定时备份。如果是实时备份，那么备份写入的地方一定是当前系统有写入权限的地方，你的备份也可以被病毒加密。如果说是类似Ghost的备份方案，病毒完全可以做到对一部分内容进行加密，比如开头512字节，中间512字节和结尾512字节。这样做可以兼顾加密速度和破坏效果，实时备份此时就是引狼入室，不仅最新备份无法使用，连旧的都有可能一起感染。如果是定时备份，也可以通过病毒延迟发作，在潜伏期内进入设备——这跟现在的病毒发作方式其实有点关系，因为现在加密过程是需要时间的，在此期间接入保存设备也会导致备份被破坏。&lt;/p&gt;

&lt;p&gt;其次，对于我来说，我有大量的视频资源需要备份，2T的备份就需要一块2T的硬盘，这样的消耗其实相当大。所以使用移动硬盘备份这样的方案，对我来说成本就相当的高，而可靠性却很一般。&lt;/p&gt;

&lt;p&gt;最后，我认为对于有潜伏期的勒索病毒而言，一个能通过私有协议持续写入备份，又能够提供历史版本的备份设备是最合适的。私有协议使得备份只能通过特定应用备份，历史版本又能在最新几个备份是已感染的情况下，找到一个干净的备份来还原，降低损失。&lt;/p&gt;

&lt;p&gt;最终我买了NAS来做这个备份。我买的这个NAS是包含了备份软件的，备份会通过其他协议上传到服务器，并不是通过网络共享来写入的。如果使用网络共享，就有可能破坏已经进入共享的文件。而且它能够提供32个版本的文件历史，因此如果某天我本地被感染并且把加密后的文件上传，我也还是可以恢复出未感染的文件。&lt;/p&gt;

&lt;p&gt;这样即便是有带有潜伏期的勒索者病毒，也无法破坏我已经备份的内容了。只是有一个缺点，硬盘还是得买够，NAS、本地都要有一份。要不然万一NAS被攻击了丢数据，可就追悔莫及啦。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//importance-of-backup.html</guid></item></channel>
</rss>