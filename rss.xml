<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>一个不严谨的 String Intern 测试</title><link>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</link><pubdate>2018-01-15</pubdate><content:encoded>&lt;p&gt;　　今天在 Reeder 上看到一个关于 String Intern 的&lt;a href="http://www.importnew.com/27694.html"&gt;文章&lt;/a&gt;，自己测试了一下，发现有些地方并不严谨。&lt;/p&gt;

&lt;p&gt;　　原文用了一段如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public static void main(String[] args) {
    String s = new String("1");
    s.intern();
    String s2 = "1";
    System.out.println(s == s2);
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    System.out.println(s3 == s4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目的很明确，希望通过==判断 intern 能否为下一次赋值从 intern 的池里提供。然而这段代码做了一个假设：在 main 函数之前，没有任何字符串被 intern。&lt;/p&gt;

&lt;p&gt;　　然而我在Java8以上测试，却发现了有意思的情况。考虑以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;    public static void main(String[] args) {
        String s =  String.valueOf(1) + String.valueOf(1);
        s.intern();
        String s2 = "11";
        System.out.println(s == s2);

        String s3 = String.valueOf(1) + String.valueOf(2);
        s3.intern();
        String s4 = "12";
        System.out.println(s3 == s4);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　按照原文作者的假设，结果应该都是 true 才对，第一次 intern 的时候该对象保存进入常量，第二次赋值的时候取出，因此==的两个结果是 true。&lt;/p&gt;

&lt;p&gt;　　但是在我的机器和其他同事的机器上却发现有人是 false，true，有人是 false，false，有人是 true，true。也就是说，JVM 根据某些信息提前进行了 intern，这种 intern 操作来自哪里，我暂时还不知道，有知道的同学可以帮忙在回复里解释一下。&lt;/p&gt;

&lt;p&gt;　　BTW，调用 intern 却不是用其返回值作为对象，那么这次使用的对象不一定是在 Intern 里存储的那个对象，使用==的结果并不是确定的。这种类似 C 的未定义行为，不能作为 Java 特性的说明，也不能在生产代码里使用，原文的原理是正确的，但是代码却没有说服力了。这从另一个角度提醒我们写代码还是要大胆假设，小心求证。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</guid></item><item><title>简单的Http客户端——OKHttp</title><link>http://blog.shrp.me//simple-http-client-okhttp.html</link><pubdate>2017-12-21</pubdate><content:encoded>&lt;p&gt;&lt;a href="https://github.com/square/okhttp"&gt;OKHttp&lt;/a&gt;支持以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;http/2支持，同一个host可以共享一个端口&lt;/li&gt;
&lt;li&gt;如果http/2不支持，则使用连接池降低请求延迟&lt;/li&gt;
&lt;li&gt;透明gzip请求的返回&lt;/li&gt;
&lt;li&gt;可以针对重复的网络请求进行缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下文将分几个方向介绍OKHttp：&lt;/p&gt;

&lt;p&gt;1.引用&lt;/p&gt;

&lt;p&gt;当前最新版本是3.9.1，使用maven仓库引入即可，maven配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gradle 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;compile 'com.squareup.okhttp3:okhttp:3.9.1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.先引入一个函数来表示具体的请求，后边的执行大多会使用这个函数来发起具体的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private static Response executeRequest(final OkHttpClient okHttpClient, final Request build) {
        try {
            final Response response = okHttpClient.newCall(build).execute();
            if (response.isSuccessful()) {
                System.out.println(response.code() + " : " + response.body().string().length());
            } else {
                System.out.println(response.code());
            }
            return response;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.基本的get请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple get: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.基本的post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MediaType parse = MediaType.parse("application/json");
        final RequestBody requestBody = RequestBody.create(parse, "{}");
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(requestBody)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple post: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.multipart post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MultipartBody form = new MultipartBody.Builder().addFormDataPart(
                "test", "test"
        ).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(form)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("multipart post: ");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.带有缓存功能的get&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_NETWORK)
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("cached get: ");
        final Response response = executeRequest(okHttpClient, build);
        assert response.networkResponse() != null;
        final Request request2 = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_CACHE)
                .addHeader("client-version", "3.9.1")
                .build();
        final Response response2 = executeRequest(okHttpClient, request2);
        assert response2.cacheResponse() != null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.异步请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("async get: ");
        okHttpClient.newCall(build).enqueue(new Callback() {
            @Override
            public void onFailure(final Call call, final IOException e) {
                System.out.println(call.request().url() + " is failed. " + e.getMessage());
            }

            @Override
            public void onResponse(final Call call, final Response response) throws IOException {
                if (response.isSuccessful()) {
                    System.out.println(response.code() + " : " + response.body().string().length());
                } else {
                    System.out.println(response.code());
                }
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.带有拦截器的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt; final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache)
                .addInterceptor(chain -&amp;gt; {
//                    System.out.println("intercept 1.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 1 return.");
                    return proceed;
                })
                .addInterceptor(chain -&amp;gt; {
                    System.out.println("intercept 2.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 2 return.");
                    return proceed;
                })
                .addNetworkInterceptor(chain -&amp;gt; {
                    System.out.println("network intercept.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("network intercept return.");
                    return proceed;
                })
                .build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("intercept get: ");
        executeRequest(okHttpClient, build);
        System.out.print("intercept get from cache: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.还可以添加认证器，在异步调用后使用cancel取消等功能。&lt;/p&gt;

&lt;p&gt;okhttp的api更易用，据说性能也不错。以后有机会可以进行性能的比较。本文代码可以在&lt;a href="https://github.com/stirp/MyTests"&gt;https://github.com/stirp/MyTests&lt;/a&gt;找到。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//simple-http-client-okhttp.html</guid></item><item><title>在Mac OS X管理多个Java环境</title><link>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</link><pubdate>2017-12-18</pubdate><content:encoded>&lt;p&gt;　　Java刚出了Java9，Java10也在日程上了。然而Java的相关环境实在是太多，对于某些增强型的组件，是依赖某个特定版本的Java进行工作的，当手头的项目多，不得不对不同版本的Java进行开发的时候，就必须来回不停切换版本，实在是不方便。其实不同版本的Java目录是不同的，完全可以同时存在。通过本文介绍的工具Jenv就可以管理本机的多个Java环境，并且通过简单的配置就可以让指定项目使用特定的Java版本，无需再进行反复切换了。这个工具本身还是开源的，地址就在&lt;a href="https://github.com/gcuisinier/jenv"&gt;https://github.com/gcuisinier/jenv&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　先要强调，Jenv是个脚本软件，作用环境限于shell环境内，如果是使用IDE比如eclipse，Intellij，那它体现不出它自己的价值，毕竟IDE一般都具有管理JDK的功能。安装Jenv的方式很简单，直接clone到~/.jenv中，然后把bin目录添加到系统路径中，重启shell就好啦。&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; git clone https://github.com/gcuisinier/jenv.git ~/.jenv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; vim ~/.local/share/omf/init.fish&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; cp fish/jenv.fish ~/.config/fish/functions/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　在文件中添加&lt;code&gt;set PATH $HOME/.jenv/bin $PATH&lt;/code&gt;。这是fish shell的安装方式，其他方式可以参考官方文档。&lt;/p&gt;

&lt;p&gt;　　装好以后通过&lt;code&gt;jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home&lt;/code&gt;可以将安装在该目录下的Java添加到jenv中。目前的jenv在fish上有点问题，jenv默认有两个文件夹不存在，因此需要先执行&lt;code&gt;mkdir ~/.jenv/versions&lt;/code&gt; 和 &lt;code&gt;mkdir ~/.jenv/plugins&lt;/code&gt;先建立目录才能执行jenv add和jenv enable-plugins.&lt;/p&gt;

&lt;p&gt;　　Jenv有两个环境，global和local，分别对应全局jdk和文件夹内的jdk版本指定。对于我来说，一般全局使用最新的Java版本，在不能使用最新Java的文件夹内执行&lt;code&gt;jenv local 1.8.0&lt;/code&gt;来指定比如1.8.0版本。如果使用了maven，gradle等编译管理软件，需要用&lt;code&gt;jev enabel-plugin maven&lt;/code&gt;来重定向mvn命令，以便maven也使用指定的Java版本。其他工具，比如gradle，原理是类似的。&lt;/p&gt;

&lt;p&gt;　　有了这个工具，从此再也不怕多种版本的Java开发啦！&lt;/p&gt;

&lt;p&gt;Update 12.19:&lt;/p&gt;

&lt;p&gt;　　对于fish来说，启动的时候需要执行jenv rehash，来确保java由jenv管理。最简单的方法在~/.config/fish/conf.d/omf.fish里增加&lt;code&gt;jenv rehash&lt;/code&gt;即可。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</guid></item><item><title>碰巧发现一个水友电脑中了病毒</title><link>http://blog.shrp.me//find-a-cyber-friend-get-his-computer-infected-by-computer-virus.html</link><pubdate>2017-09-20</pubdate><content:encoded>&lt;p&gt;　　今天恰好看到有人在玩星际菠菜，我想起早以前在YY玩菠菜的经历，心理痒痒，也想试试手气，于是也打开网站上去找找菠菜的入口在哪里。&lt;/p&gt;

&lt;p&gt;　　没成想打开唯一的live.htm，却没发现菠菜的入口。难道入口屏蔽了？于是F12看看吧，不看不要紧，一看吓一跳，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Jietu20170920-145708.png" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;　　虽然咱不太懂vbscript，但是这段代码大致意思还是看得懂的：先找到一个路径，尝试写入一些二进制数据，然后调用运行这个文件，文件名是svchost.exe。这个名字不就是Windows系统最常用的系统进程嘛！这段代码看起来就是个病毒啊！&lt;/p&gt;

&lt;p&gt;　　然后用二进制编辑软件把这段二进制保存起来，提交&lt;a href="https://www.virustotal.com/zh-cn/file/fd6c69c345f1e32924f0a5bb7393e191b393a78d58e2c6413b03ced7482f2320/analysis/"&gt;在线工具&lt;/a&gt;，提示极大可能是病毒,创建病毒文件于C:\Program Files\Microsoft\DesktopLayer.exe。赶紧跟对方反应了这个问题，最终确认他电脑中了DesktopLayer病毒，所有机器都感染了，可能还有水友也因为观看直播中病毒。后续处理就简单了，网上有专杀工具，搜索下载就好了，据说专杀效果还是挺不错的。&lt;/p&gt;

&lt;p&gt;　　病毒实在是很难防范，搞得我都想装个iOS虚拟机上网了……哈哈，当然是玩笑了。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//find-a-cyber-friend-get-his-computer-infected-by-computer-virus.html</guid></item><item><title>面对勒索病毒的数据备份方案</title><link>http://blog.shrp.me//importance-of-backup.html</link><pubdate>2017-05-15</pubdate><content:encoded>&lt;p&gt;估计大家这几天都被勒索病毒刷了屏，我也来凑凑热闹，简单说下我的方案——备份。&lt;/p&gt;

&lt;p&gt;看到这里读者大概会觉得我大概是石乐志，备份有什么难的，普天下的人都会备份，还要你出来讲啊。但是如果你深入思考一下勒索病毒的特点，你会发现传统的备份方案在勒索病毒进一步发展后很有可能无效。&lt;/p&gt;

&lt;p&gt;首先，备份一般按时效分，有实时备份和定时备份。如果是实时备份，那么备份写入的地方一定是当前系统有写入权限的地方，你的备份也可以被病毒加密。如果说是类似Ghost的备份方案，病毒完全可以做到对一部分内容进行加密，比如开头512字节，中间512字节和结尾512字节。这样做可以兼顾加密速度和破坏效果，实时备份此时就是引狼入室，不仅最新备份无法使用，连旧的都有可能一起感染。如果是定时备份，也可以通过病毒延迟发作，在潜伏期内进入设备——这跟现在的病毒发作方式其实有点关系，因为现在加密过程是需要时间的，在此期间接入保存设备也会导致备份被破坏。&lt;/p&gt;

&lt;p&gt;其次，对于我来说，我有大量的视频资源需要备份，2T的备份就需要一块2T的硬盘，这样的消耗其实相当大。所以使用移动硬盘备份这样的方案，对我来说成本就相当的高，而可靠性却很一般。&lt;/p&gt;

&lt;p&gt;最后，我认为对于有潜伏期的勒索病毒而言，一个能通过私有协议持续写入备份，又能够提供历史版本的备份设备是最合适的。私有协议使得备份只能通过特定应用备份，历史版本又能在最新几个备份是已感染的情况下，找到一个干净的备份来还原，降低损失。&lt;/p&gt;

&lt;p&gt;最终我买了NAS来做这个备份。我买的这个NAS是包含了备份软件的，备份会通过其他协议上传到服务器，并不是通过网络共享来写入的。如果使用网络共享，就有可能破坏已经进入共享的文件。而且它能够提供32个版本的文件历史，因此如果某天我本地被感染并且把加密后的文件上传，我也还是可以恢复出未感染的文件。&lt;/p&gt;

&lt;p&gt;这样即便是有带有潜伏期的勒索者病毒，也无法破坏我已经备份的内容了。只是有一个缺点，硬盘还是得买够，NAS、本地都要有一份。要不然万一NAS被攻击了丢数据，可就追悔莫及啦。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//importance-of-backup.html</guid></item><item><title>EF BF BD 引发的血案</title><link>http://blog.shrp.me//EF-BF-BD-Caused-Bug.html</link><pubdate>2017-05-13</pubdate><content:encoded>&lt;p&gt;　　最近在公司遇到一件奇怪的事情，我司私有协议的业务服务器总是收到奇怪的请求，导致收到的包解包失败。&lt;/p&gt;

&lt;p&gt;　　这个私有协议原理是先收到一个消息头，再收到一个长度，根据长度得到后边数据的长度，最后再把数据解析为相应的 Bytes 或者字符串，完成解包。&lt;/p&gt;

&lt;p&gt;　　然而实际却总是收到跟声明情况不符合的数据，特点就是消息头声明了后边数据是一个字符串性质的内容，字节长度是x，但是实际发出的数据字节长度是超过x的，因此发现这个包在理应结束后还是没有遇到结束符号，解包出了问题，这条流已无法继续使用了，只能断开连接。&lt;/p&gt;

&lt;p&gt;　　可是业务的流量来自于一个私有协议的请求分发服务，相当于网络入口，这个服务的编码程序也是久经使用的，经过内网发向业务服务器，是不会无故发出向下图这样不正确的包啊。（图中 ca 表示一个 String 类型的消息，9c 是长度。但是经过 9c 也解析不到任何有意义的数据）&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Jietu20170513-232035.png" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;　　不过仔细观察图上的流，我发现字节流里有不寻常的出现了很多 EF BF BD 。这几个字节为什么会突然多这么多？一个字符串出现很多同样的字符是很可疑的。上网搜索，发现这个是 UTF-8 的无效字符，Java 在构造 String 的时候如果遇到了非法的 UTF-8 字符，就会使用 EF BF BD 替换。于是查看请求路由的源码，发现它是在应用层上解开了私有协议，对于收到用户发来的消息头，长度和内容，如果消息是 String 内容，就会使用 UTF-8 把消息内容构造成 String，转发的时候则使用了构造后 String 的 getBytes 写入到流内，而此时的长度跟之前写入的长度根本对不上。所以实际上消息分发服务就已经出了问题，只是这在 String 的构造器上并不抛出异常，因此消息分发服务对此一无所知。&lt;/p&gt;

&lt;p&gt;　　其实知道问题怎么发生的是最难的，解决问题反而是简单的。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//EF-BF-BD-Caused-Bug.html</guid></item><item><title>在Mac终端格式化Json并自动复制到粘贴板</title><link>http://blog.shrp.me//format-and-copy-json-on-mac.html</link><pubdate>2017-04-01</pubdate><content:encoded>&lt;p&gt;　　现在的Restful接口非常多，我们开发会经常遇到调试json的地方。但是json一般都是compact过的，肉眼很难观察，但是打开页面、工具去解析又很麻烦。有什么好办法呢？这个在Mac上有个非常轻松的解决办法，那就是使用命令行工具&lt;a href="https://stedolan.github.io/jq/"&gt;jq&lt;/a&gt;。    &lt;/p&gt;

&lt;p&gt;　　首先需要安装工具jq，Mac可以直接使用brew安装。&lt;/p&gt;

&lt;p&gt;　　然后在你的终端里使用命令&lt;code&gt;pbpaste | jq "." | pbcopy; pbpaste | jq; echo -e "\033[0;32mjson copied to clipboard!"&lt;/code&gt;就可以一行命令把粘贴板里的json文本格式化，并重新复制到粘贴板。&lt;/p&gt;

&lt;p&gt;　　当然这么做非常繁琐，所以你需要把它alias为bash命令。对于fish，我单独制作了一个function，你可以将我的脚本放到function目录内使用，地址&lt;a href="https://raw.githubusercontent.com/stirp/oh-my-fish/master/functions/jsonfmt.fish"&gt;https://raw.githubusercontent.com/stirp/oh-my-fish/master/functions/jsonfmt.fish&lt;/a&gt;。最终效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/WX20170401-183739.png" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;本文参考知乎文章&lt;a href="https://zhuanlan.zhihu.com/p/26134439"&gt;【Mac小技巧】一键format json&lt;/a&gt;&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//format-and-copy-json-on-mac.html</guid></item><item><title>Intellij 和 docker for Mac的兼容方案</title><link>http://blog.shrp.me//compatible-workaroud-about-Intellij-and-Dorkcer-for-Mac.html</link><pubdate>2017-02-22</pubdate><content:encoded>&lt;p&gt;　　今天在配置Intellij使用Docker for mac的时候发现需要使用api-url，但是Docker for mac并没有api-url。经过搜索发现&lt;a href="http://www.cnblogs.com/micrari/p/6169936.html"&gt;这里(http://www.cnblogs.com/micrari/p/6169936.html)&lt;/a&gt;有解决方案，简单来讲是使用socat将unix的socket文件转发到本地的tcp端口。鉴于互联网链接可能失效，附文如后：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;笔者在自己的Mac上安装的是Docker for Mac，而不是Docker Toolbox。&lt;/p&gt;
  
  &lt;p&gt;这两者最主要的区别在于Docker for Mac用HyperKit作为虚拟化解决方案而不是VirtualBox,相比Docker Toolbox，Docker for Mac更加native些。
  Docker for Mac 通过&lt;code&gt;/var/tmp/docker.sock&lt;/code&gt;暴露API。&lt;/p&gt;
  
  &lt;p&gt;JetBrains系IDE有一款叫&lt;a href="https://youtrack.jetbrains.com/issue/IDEA-153973#comment=27-1484220"&gt;Docker Integration&lt;/a&gt;的插件。&lt;/p&gt;
  
  &lt;p&gt;当笔者尝试配置此插件时，发现它对Docker for Mac用户不是太友好。而在笔者的另一台安装Docker Toolbox的Mac上却是相当容易的。&lt;/p&gt;
  
  &lt;p&gt;&lt;img src="http://images2015.cnblogs.com/blog/584724/201612/584724-20161213143354058-100182548.png"&gt;&lt;/p&gt;
  
  &lt;p&gt;当打开配置页，默认的显示结果如图所示，API URL为https://192.168.99.100:2376。然而这并不起作用，没办法和Docker建立连接。&lt;/p&gt;
  
  &lt;p&gt;当我尝试在API URL中随便填入&lt;code&gt;unix:///var/run/docker.sock&lt;/code&gt;，IDE提示如下。
  &lt;img src="http://images2015.cnblogs.com/blog/584724/201612/584724-20161213144232917-1999769934.png"&gt;
  点开More info，会进到这个&lt;a href="https://youtrack.jetbrains.com/issue/IDEA-153973#comment=27-1484220"&gt;issue&lt;/a&gt;
  &lt;img src="http://images2015.cnblogs.com/blog/584724/201612/584724-20161213143354058-100182548.png"&gt;
  发现Docker Integration与Docker for Mac的兼容性问题有一个workaround&lt;/p&gt;
  
  &lt;p&gt;在命令行输入&lt;/p&gt;
  
  &lt;p&gt;&lt;code&gt;brew install socat&lt;/code&gt;&lt;/p&gt;
  
  &lt;p&gt;安装socat&lt;/p&gt;
  
  &lt;p&gt;再输入命令&lt;/p&gt;
  
  &lt;p&gt;&lt;code&gt;socat -d -d TCP-L:8099,fork UNIX:/var/run/docker.sock&lt;/code&gt;&lt;/p&gt;
  
  &lt;p&gt;再在IntelliJ中配置API URL为&lt;code&gt;tcp://localhost:8099&lt;/code&gt;
  可以看到最终成功连接到docker，如下图所示。
  &lt;img src="http://images2015.cnblogs.com/blog/584724/201612/584724-20161213150704479-236755813.png"&gt;
  &lt;img src="http://images2015.cnblogs.com/blog/584724/201612/584724-20161213150447120-1352983762.png"&gt;
  笔者阅读了相关ISSUE，事实上，这个问题并没有真正的解决，只是目前有这么个workaround。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded><guid>http://blog.shrp.me//compatible-workaroud-about-Intellij-and-Dorkcer-for-Mac.html</guid></item><item><title>在CentOS7安装PPTP client和Gnome的PPTP界面</title><link>http://blog.shrp.me//Install-pptp-and-gnome-pptp-client-on-centos7.html</link><pubdate>2017-02-06</pubdate><content:encoded>&lt;p&gt;不知道为什么，CentOS7默认的yum源里没有PPTP的GNOME客户端，设置很不方便。&lt;/p&gt;

&lt;p&gt;那么简单的方式就是直接安装其他源的rpm,比如&lt;a href="http://li.nux.ro/download/nux/dextop/el7/x86_64/"&gt;http://li.nux.ro/download/nux/dextop/el7/x86_64/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;也可以直接运行命令搞定：&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;sudo yum install http&lt;span class="token punctuation"&gt;:&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;li&lt;span class="token punctuation"&gt;.&lt;/span&gt;nux&lt;span class="token punctuation"&gt;.&lt;/span&gt;ro&lt;span class="token operator"&gt;/&lt;/span&gt;download&lt;span class="token operator"&gt;/&lt;/span&gt;nux&lt;span class="token operator"&gt;/&lt;/span&gt;dextop&lt;span class="token operator"&gt;/&lt;/span&gt;el7&lt;span class="token operator"&gt;/&lt;/span&gt;x86_64&lt;span class="token operator"&gt;/&lt;/span&gt;NetworkManager&lt;span class="token operator"&gt;-&lt;/span&gt;pptp&lt;span class="token number"&gt;-0.9&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token number"&gt;8.2&lt;/span&gt;&lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;4&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;el7&lt;span class="token punctuation"&gt;.&lt;/span&gt;nux&lt;span class="token punctuation"&gt;.&lt;/span&gt;x86_64&lt;span class="token punctuation"&gt;.&lt;/span&gt;rpm
sudo yum install http&lt;span class="token punctuation"&gt;:&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;li&lt;span class="token punctuation"&gt;.&lt;/span&gt;nux&lt;span class="token punctuation"&gt;.&lt;/span&gt;ro&lt;span class="token operator"&gt;/&lt;/span&gt;download&lt;span class="token operator"&gt;/&lt;/span&gt;nux&lt;span class="token operator"&gt;/&lt;/span&gt;dextop&lt;span class="token operator"&gt;/&lt;/span&gt;el7&lt;span class="token operator"&gt;/&lt;/span&gt;x86_64&lt;span class="token operator"&gt;/&lt;/span&gt;NetworkManager&lt;span class="token operator"&gt;-&lt;/span&gt;pptp&lt;span class="token operator"&gt;-&lt;/span&gt;gnome&lt;span class="token number"&gt;-0.9&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token number"&gt;8.2&lt;/span&gt;&lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;4&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;el7&lt;span class="token punctuation"&gt;.&lt;/span&gt;nux&lt;span class="token punctuation"&gt;.&lt;/span&gt;x86_64&lt;span class="token punctuation"&gt;.&lt;/span&gt;rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后在系统的网络设置中就能够添加自己的配置啦！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Install-pptp-and-gnome-pptp-client-on-centos7.html</guid></item><item><title>OpenWRT安装OpenVPN</title><link>http://blog.shrp.me//Install-OpenVPN-on-OpenWRT.html</link><pubdate>2017-01-30</pubdate><content:encoded>&lt;p&gt;　　苹果升级iOS10和Mac OS X Sierra有一段时间了，我的iPhone一不小心就中招升级了，导致我在外边玩游戏速度特别差，也不能拨号回家。&lt;/p&gt;

&lt;p&gt;　　之前尝试着装个L2tp服务器，发现问题多多，始终不能成功；正好这次放假看到了知乎这个&lt;a href="https://www.zhihu.com/question/21751217/answer/32851461"&gt;答案&lt;/a&gt;，所以就尝试着按照这个方式装一个OpenVPN服务器。&lt;/p&gt;

&lt;p&gt;　　1、安装相应的软件：&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;opkg update
opkg install openvpn&lt;span class="token operator"&gt;-&lt;/span&gt;polarssl
opkg install openvpn&lt;span class="token operator"&gt;-&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　原文说的KEY_CN就是被注解掉的，所以不用执行相应的sed。&lt;/p&gt;

&lt;p&gt;　　2、修改/etc/easy-rsa/vars，把原文所说的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KEY_SIZE=2048
export KEY_COUNTRY=CN
export KEY_PROVINCE=Canton
export KEY_CITY=city_name
export KEY_ORG=org_name
export KEY_EMAIL=email_address
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都修改一下，然后执行&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;source &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;vars
clean&lt;span class="token operator"&gt;-&lt;/span&gt;all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来做好生成证书的准备。&lt;/p&gt;

&lt;p&gt;　　3、执行命令生成证书&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;pkitool –initca
pkitool &lt;span class="token operator"&gt;--&lt;/span&gt;server 服务端名称
pkitool 客户端名称&lt;span class="token number"&gt;0&lt;/span&gt;
pkitool 客户端名称&lt;span class="token number"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上有一个客户端就需要生成一套客户端的证书，当然，你也可以按照我的一会列出的参数，一套证书多个客户端使用。&lt;/p&gt;

&lt;p&gt;　　4、执行&lt;code&gt;build-dh&lt;/code&gt;来生成Diffie Hellman参数&lt;/p&gt;

&lt;p&gt;　　5、生成ta.key&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;openvpn &lt;span class="token operator"&gt;--&lt;/span&gt;genkey &lt;span class="token operator"&gt;--&lt;/span&gt;secret &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;keys&lt;span class="token operator"&gt;/&lt;/span&gt;ta&lt;span class="token punctuation"&gt;.&lt;/span&gt;key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　6、编辑/etc/config/network，修改lan下的option ifname ，增加tun0&lt;/p&gt;

&lt;p&gt;　　7、修改/etc/config/openvpn&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;config openvpn my&lt;span class="token operator"&gt;-&lt;/span&gt;server
    option enabled &lt;span class="token number"&gt;1&lt;/span&gt;
    option local &lt;span class="token number"&gt;0.0&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token number"&gt;0.0&lt;/span&gt;
    option port &lt;span class="token number"&gt;1194&lt;/span&gt;
    option proto tcp
    option dev tun
    option ca &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;keys&lt;span class="token operator"&gt;/&lt;/span&gt;ca&lt;span class="token punctuation"&gt;.&lt;/span&gt;crt
    option cert &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;keys&lt;span class="token operator"&gt;/&lt;/span&gt;my&lt;span class="token operator"&gt;-&lt;/span&gt;server&lt;span class="token punctuation"&gt;.&lt;/span&gt;crt
    option key &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;keys&lt;span class="token operator"&gt;/&lt;/span&gt;my&lt;span class="token operator"&gt;-&lt;/span&gt;server&lt;span class="token punctuation"&gt;.&lt;/span&gt;key
    option dh &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;easy&lt;span class="token operator"&gt;-&lt;/span&gt;rsa&lt;span class="token operator"&gt;/&lt;/span&gt;keys&lt;span class="token operator"&gt;/&lt;/span&gt;dh2048&lt;span class="token punctuation"&gt;.&lt;/span&gt;pem
    option server &lt;span class="token string"&gt;"172.8.0.0 255.255.255.0"&lt;/span&gt;
    list push &lt;span class="token string"&gt;"redirect-gateway def1"&lt;/span&gt;
    list push &lt;span class="token string"&gt;"dhcp-option DNS 172.8.0.1"&lt;/span&gt;
    list push &lt;span class="token string"&gt;"dhcp-option WINS 172.8.0.1"&lt;/span&gt;
    option client_to_client &lt;span class="token number"&gt;1&lt;/span&gt;
    option duplicate_cn &lt;span class="token number"&gt;1&lt;/span&gt; &lt;span class="token comment" spellcheck="true"&gt;#允许一个证书多个客户端使用
&lt;/span&gt;    option keepalive &lt;span class="token string"&gt;"10 120"&lt;/span&gt;
    option tls_auth &lt;span class="token string"&gt;"/etc/easy-rsa/keys/ta.key 0"&lt;/span&gt;
    option tls_server &lt;span class="token number"&gt;1&lt;/span&gt;
    option comp_lzo yes
    option max_clients &lt;span class="token number"&gt;100&lt;/span&gt;
    option persist_key &lt;span class="token number"&gt;1&lt;/span&gt;
    option persist_tun &lt;span class="token number"&gt;1&lt;/span&gt;
    option status &lt;span class="token operator"&gt;/&lt;/span&gt;tmp&lt;span class="token operator"&gt;/&lt;/span&gt;openvpn&lt;span class="token operator"&gt;-&lt;/span&gt;status&lt;span class="token punctuation"&gt;.&lt;/span&gt;log
    option log         &lt;span class="token operator"&gt;/&lt;/span&gt;tmp&lt;span class="token operator"&gt;/&lt;/span&gt;openvpn&lt;span class="token punctuation"&gt;.&lt;/span&gt;log
    option verb &lt;span class="token number"&gt;3&lt;/span&gt;
    option mute &lt;span class="token number"&gt;20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　8、添加路由做测试 &lt;code&gt;iptables -t nat -A POSTROUTING -s 172.8.0.0/24 -j MASQUERADE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　9、添加路由，保证以后重启能正常使用&lt;code&gt;iptables -A FORWARD -s 172.8.0.0/24 -j ACCEPT&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　10、编辑&lt;code&gt;/etc/config/firewall&lt;/code&gt;，在wan开放1194端口&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;config rule
option enabled &lt;span class="token string"&gt;'1'&lt;/span&gt;
option target &lt;span class="token string"&gt;'ACCEPT'&lt;/span&gt;
option src &lt;span class="token string"&gt;'wan'&lt;/span&gt;
option name &lt;span class="token string"&gt;'Allow-WAN-OpenVPN-Input'&lt;/span&gt;
option family &lt;span class="token string"&gt;'ipv4'&lt;/span&gt;
option proto &lt;span class="token string"&gt;'tcp'&lt;/span&gt;
option dest_port &lt;span class="token string"&gt;'1194'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　11、重启服务生效 &lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;init&lt;span class="token punctuation"&gt;.&lt;/span&gt;d&lt;span class="token operator"&gt;/&lt;/span&gt;openvpn enable
reboot（or &lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;init&lt;span class="token punctuation"&gt;.&lt;/span&gt;d&lt;span class="token operator"&gt;/&lt;/span&gt;network restart&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;init&lt;span class="token punctuation"&gt;.&lt;/span&gt;d&lt;span class="token operator"&gt;/&lt;/span&gt;firewall restart&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;etc&lt;span class="token operator"&gt;/&lt;/span&gt;init&lt;span class="token punctuation"&gt;.&lt;/span&gt;d&lt;span class="token operator"&gt;/&lt;/span&gt;openvpn start&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端只要把相应的ca.crt,ta.key,客户端.crt，客户端.key下载下来，编辑文本文件vpn.ovpn，内容如下：&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;client
proto tcp
remote 服务器ip &lt;span class="token number"&gt;1194&lt;/span&gt;
dev tun
comp&lt;span class="token operator"&gt;-&lt;/span&gt;lzo
nobind
ca ca&lt;span class="token punctuation"&gt;.&lt;/span&gt;crt
cert 客户端&lt;span class="token punctuation"&gt;.&lt;/span&gt;crt
key 客户端&lt;span class="token punctuation"&gt;.&lt;/span&gt;key
tls&lt;span class="token operator"&gt;-&lt;/span&gt;auth ta&lt;span class="token punctuation"&gt;.&lt;/span&gt;key &lt;span class="token number"&gt;1&lt;/span&gt;
route&lt;span class="token operator"&gt;-&lt;/span&gt;delay &lt;span class="token number"&gt;2&lt;/span&gt;
route&lt;span class="token operator"&gt;-&lt;/span&gt;method exe
verb &lt;span class="token number"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要拨号后使用代理，只需要添加如下参数：&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;dhcp&lt;span class="token operator"&gt;-&lt;/span&gt;option PROXY_HTTP 代理ip 代理端口
dhcp&lt;span class="token operator"&gt;-&lt;/span&gt;option PROXY_HTTPS 代理ip 代理端口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用自动代理，添加如下参数：&lt;/p&gt;

&lt;pre class=" language-bash"&gt;&lt;code class=" language-bash"&gt;dhcp&lt;span class="token operator"&gt;-&lt;/span&gt;option PROXY_AUTO_CONFIG_URL http&lt;span class="token punctuation"&gt;:&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;&lt;span class="token operator"&gt;/&lt;/span&gt;example&lt;span class="token punctuation"&gt;.&lt;/span&gt;tld&lt;span class="token operator"&gt;/&lt;/span&gt;proxy&lt;span class="token punctuation"&gt;.&lt;/span&gt;pac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过上述几个参数并非所有openVPN客户端支持。&lt;/p&gt;

&lt;p&gt;update-2017-11-12:&lt;/p&gt;

&lt;p&gt;经过升级到openwrt 15.05.1后，发现openvpn-polarssl出现了segment fault，在路由器上没法调试，改用openvpn-openssl后，发现没有问题，配置等无需修改，完全兼容。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Install-OpenVPN-on-OpenWRT.html</guid></item></channel>
</rss>