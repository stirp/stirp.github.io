<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
~~~~{Java}
package com.woqu.crm.server;

import java.io.UnsupportedEncodingException;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by shangrenpeng on 16/2/18.
 */
public class PHPUrlDecoder {
    public static byte[] decode(String s, String enc)
            throws UnsupportedEncodingException {

        int numChars = s.length();
        List<Byte> sb = new LinkedList<>();
        int i = 0;

        if (enc.length() == 0) {
            throw new UnsupportedEncodingException ("URLDecoder: empty string enc parameter");
        }

        char c;
        byte[] bytes = null;
        while (i < numChars) {
            c = s.charAt(i);
            switch (c) {
                case '+':
                    addBytes(sb,String.valueOf(' ').getBytes("UTF-8"));
                    i++;
                    break;
                case '%':
                /*
                 * Starting with this instance of %, process all
                 * consecutive substrings of the form %xy. Each
                 * substring %xy will yield a byte. Convert all
                 * consecutive  bytes obtained this way to whatever
                 * character(s) they represent in the provided
                 * encoding.
                 */

                    try {
                        if (!canParse(s ,i)){
                            addBytes(sb,String.valueOf(c).getBytes("UTF-8"));
                            i++;
                            break;
                        }

                        // (numChars-i)/3 is an upper bound for the number
                        // of remaining bytes
                        if (bytes == null)
                            bytes = new byte[(numChars-i)/3];
                        int pos = 0;

                        while ( ((i+2) < numChars) &&
                                (c=='%')) {

                            int v = Integer.parseInt(s.substring(i+1,i+3),16);
//                            if (v < 0){
//                                throw new IllegalArgumentException("URLDecoder: Illegal hex characters in escape (%) pattern - negative value");
//                            }

                            bytes[pos++] = (byte) v;
                            i+= 3;
                            if (i < numChars)
                                c = s.charAt(i);
                        }
                        addBytes(sb, bytes,pos);
                    } catch (NumberFormatException e) {
                        throw new IllegalArgumentException(
                                "URLDecoder: Illegal hex characters in escape (%) pattern - "
                                        + e.getMessage());
                    }
                    break;
                default:
                    addBytes(sb,String.valueOf(c).getBytes("UTF-8"));
                    i++;
                    break;
            }
        }

        final Byte[] ret = sb.toArray(new Byte[sb.size()]);

        return toPrimitive(ret);
    }

    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

    public static byte[] toPrimitive(Byte[] array) {
        if(array == null) {
            return null;
        } else if(array.length == 0) {
            return EMPTY_BYTE_ARRAY;
        } else {
            byte[] result = new byte[array.length];

            for(int i = 0; i < array.length; ++i) {
                result[i] = array[i].byteValue();
            }

            return result;
        }
    }

    private static void addBytes(final List<Byte> sb, final byte[] bytes,int pos) {
        for (int j = 0; j < pos; j++){
            sb.add(bytes[j]);
        }
    }

    private static void addBytes(final List<Byte> sb, final byte[] bytes) {
        for (int j = 0; j < bytes.length; j++){
            sb.add(bytes[j]);
        }
    }

    private static boolean canParse(final String s, final int i) {
        try {
            int v = Integer.parseInt(s.substring(i+1,i+3),16);
            return true;
        } catch (Exception e){
            return false;
        }
    }
}

~~~~
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>~~~~{Java}
package com.woqu.crm.server;</p>

<p>import java.io.UnsupportedEncodingException;
import java.util.LinkedList;
import java.util.List;</p>

<p>/**
 * Created by shangrenpeng on 16/2/18.
 */
public class PHPUrlDecoder {
    public static byte[] decode(String s, String enc)
            throws UnsupportedEncodingException {</p>

<pre><code>    int numChars = s.length();
    List&lt;Byte&gt; sb = new LinkedList&lt;&gt;();
    int i = 0;

    if (enc.length() == 0) {
        throw new UnsupportedEncodingException ("URLDecoder: empty string enc parameter");
    }

    char c;
    byte[] bytes = null;
    while (i &lt; numChars) {
        c = s.charAt(i);
        switch (c) {
            case '+':
                addBytes(sb,String.valueOf(' ').getBytes("UTF-8"));
                i++;
                break;
            case '%':
            /*
             * Starting with this instance of %, process all
             * consecutive substrings of the form %xy. Each
             * substring %xy will yield a byte. Convert all
             * consecutive  bytes obtained this way to whatever
             * character(s) they represent in the provided
             * encoding.
             */

                try {
                    if (!canParse(s ,i)){
                        addBytes(sb,String.valueOf(c).getBytes("UTF-8"));
                        i++;
                        break;
                    }

                    // (numChars-i)/3 is an upper bound for the number
                    // of remaining bytes
                    if (bytes == null)
                        bytes = new byte[(numChars-i)/3];
                    int pos = 0;

                    while ( ((i+2) &lt; numChars) &amp;&amp;
                            (c=='%')) {

                        int v = Integer.parseInt(s.substring(i+1,i+3),16);
</code></pre>

<p>//                            if (v &lt; 0){
//                                throw new IllegalArgumentException("URLDecoder: Illegal hex characters in escape (%) pattern - negative value");
//                            }</p>

<pre><code>                        bytes[pos++] = (byte) v;
                        i+= 3;
                        if (i &lt; numChars)
                            c = s.charAt(i);
                    }
                    addBytes(sb, bytes,pos);
                } catch (NumberFormatException e) {
                    throw new IllegalArgumentException(
                            "URLDecoder: Illegal hex characters in escape (%) pattern - "
                                    + e.getMessage());
                }
                break;
            default:
                addBytes(sb,String.valueOf(c).getBytes("UTF-8"));
                i++;
                break;
        }
    }

    final Byte[] ret = sb.toArray(new Byte[sb.size()]);

    return toPrimitive(ret);
}

public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

public static byte[] toPrimitive(Byte[] array) {
    if(array == null) {
        return null;
    } else if(array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    } else {
        byte[] result = new byte[array.length];

        for(int i = 0; i &lt; array.length; ++i) {
            result[i] = array[i].byteValue();
        }

        return result;
    }
}

private static void addBytes(final List&lt;Byte&gt; sb, final byte[] bytes,int pos) {
    for (int j = 0; j &lt; pos; j++){
        sb.add(bytes[j]);
    }
}

private static void addBytes(final List&lt;Byte&gt; sb, final byte[] bytes) {
    for (int j = 0; j &lt; bytes.length; j++){
        sb.add(bytes[j]);
    }
}

private static boolean canParse(final String s, final int i) {
    try {
        int v = Integer.parseInt(s.substring(i+1,i+3),16);
        return true;
    } catch (Exception e){
        return false;
    }
}
</code></pre>

<p>}</p>

<p>~~~~</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>Â© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "temp.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
