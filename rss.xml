<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>2018-08-19</title><link>http://blog.shrp.me//2018-08-19.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;这是我第一次编写每周分享。这个点子是受到阮一峰阮老师的每周分享启发，考虑到自己每周看了很多消息和工具，正好也能借助这个机会总结留下有价值的资讯。只要能帮助读者了解最新的研发消息，或者某天能用来总结查看，都算是没有白写每周分享。正常情况下我会在周五晚上发出这个系列的文章。（第一期就不正常……）&lt;/p&gt;

&lt;p&gt;我的每周分享会包括以下几点内容：本周内学会的一些Java最新的研发知识；发现的新工具；研发人员可能会关注的新闻。其中研发新闻是随缘项目，一方面我也不太关注没有生产力的新闻，一方面也没有太大的留存价值，只有特别关注到的新闻才会分享给大家。Warning：由于我的消息来源也包括阮老师，所以肯定有些内容是来自阮老师的网站，而且如果内容不带有阮老师的观点的话，来源会写真正的消息来源，而不是阮老师的网站；这主要是考虑读者不用多次跳转找出处，而非对阮老师的劳动不尊重，相信阮老师也会见谅的。&lt;/p&gt;

&lt;p&gt;下边是8月19日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/07/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ByteBuffer/"&gt;JDK源码阅读-ByteBuffer&lt;/a&gt;
&amp;nbsp;&amp;nbsp;木衫大神对 ByteBuffer 的理解。讲真的，当你开始从 Java 业务深入到底层技术的时候，Java 的 IO 系统始终会是需要关注和优化的一个点。这篇文章就是理解 ByteBuffer 设计的绝佳讲解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://blog.shrp.me/personal-understanding-of-async-and-blocking.html"&gt;JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解&lt;/a&gt; 由于之前跟同事对一段代码是否同步，是否阻塞的看法不一致，所以想深入了解一下同步异步，阻塞非阻塞究竟是什么。个人才疏学浅，也希望有大牛帮忙指正。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.cnblogs.com/lovesqcc/p/9271781.html"&gt;CR常见代码问题 - 琴水玉 - 博客园&lt;/a&gt; 很多人应该都对 CodeReview 不陌生，这是个非常好的提高能力的机会，也是代码拿出来让大家一起改进的好机会。但是有时候一次 CodeReview 包含的事情太多，没有重点，效果也不会太好。这篇文章就对 CodeReview 应该做什么进行了详细的说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/go-gitea/gitea/"&gt;gitea&lt;/a&gt; 有些人就是想自己搭建 git 服务器，但是又不想用 gitlab 这样重量级的产品。Gitea 就是这样一款产品，它的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。项目采用 Go 作为后端语言，只要生成一个可执行程序即可。并且它还支持跨平台，支持 Linux、 macOS 和 Windows 以及各种架构，除了x86、amd64，还包括 ARM 和 PowerPC 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/"&gt;PowerShell Core&lt;/a&gt; PowerShell 对于 Windows 用户应该并不陌生，但是这款 Core ，知道的可能就少了，更何况它是开源并且跨平台的。它是微软开源的一个跨平台 (Windows, Linux 和 OS X) 自动化和配置工具（框架），可以和已有的工具友好集成，特别优化用于处理结构化数据 (如 JSON, CSV, XML 等), REST APIs 以及对象模型。它包含一个命令行 Shell、一个关联的脚本语言以及一个用于处理 cmdlets 的框架。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29239.html"&gt;JVM 的 ASM 工具&lt;/a&gt; 在OpenJDK里有一个AsmTools项目，用来生成正确的或者不正确的java .class文件，主要用来测试和验证。可能对于普通开发人员来说这个工具没什么用，不过对于 JVM 语言开发来说可能很有价值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/kkk001/hp-reflect"&gt;kvn-wang/hp-reflect&lt;/a&gt;  hp-reflect 是一个高性能的反射工具。它使用字节码技术动态生成 access class。通过不同的 access class，可以高效的获取字段的值，或者调用方法，或者生成实例。 在基础框架中非常实用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lym51/AutoLink"&gt;苦叶子/AutoLink&lt;/a&gt; AutoLink是一个开源Web IDE自动化测试集成解决方案,可以帮助你轻易的构建 Web 自动化测试脚本、HTTP 接口自动化测试脚本以及移动自动化测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.jumpserver.org/"&gt;Jumpserver - 开源堡垒机 - 官网&lt;/a&gt;完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/snail007/goproxy"&gt;GitHub - snail007/goproxy&lt;/a&gt; goProxy是golang实现的高性能http,https,websocket,tcp,防污染DNS,socks5代理服务器,支持内网穿透,链式代理,通讯加密,智能HTTP,SOCKS5代理,域名黑白名单,跨平台,KCP协议支持,集成外部API。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;推荐一下我这周从阮老师那里看到的文章，&lt;a href="http://www.ruanyifeng.com/blog/2018/08/api-below.html"&gt;API 之下&lt;/a&gt;。乍看之下似乎是讲软件的，但是其实是猜测未来 AI 普及后财富分配的一个可能的后果，非常有见解。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-19.html</guid></item><item><title>JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解</title><link>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;最近在工作中跟同事讨论起了一个调用是否算是非阻塞、异步时，居然发现我们对同一段代码的定性是不一样的，于是就想写一篇文章把这个问题琢磨琢磨。由于这里涉及很多专有名词的含义，因此就先从字典开始研究。&lt;/p&gt;

&lt;h2 id=""&gt;名词字典&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;同步阻塞 IO——内核态阻塞 IO。这种 IO 模型的工作方式是这样的：用户空间的进程发起一个系统调用，这导致了用户空间的这个进程被阻塞，无法执行任何进程上的其它代码，直到系统调用返回。&lt;/li&gt;
&lt;li&gt;同步非阻塞 IO——内核态非阻塞 IO。这种 IO 的工作方式是这样的：用户空间的进程发起一个系统调用，进程并不会被阻塞，而是回到用户空间继续执行，但是会时不时通过系统调用回到内核检查之前的调用是否结束。如果没有结束，则返回用户空间继续执行，并且很快再次通过系统调用去检查结果，直到结果被返回。&lt;/li&gt;
&lt;li&gt;异步 IO——用户态 IO。这种 IO 的工作方式是这样的：用户空间的进程发起系统调用，进程不阻塞立刻回到用户空间继续执行，也不需要回到内核检查结果，而是内核在结果准备好后复制给用户进程，再通知进程数据已经准备好了。这样用户进程不需要到内核中进行 IO 操作，虽然真正的 IO 仍然是内核完成的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（如果对上述文字难以理解，可以参考&lt;a href="https://www.jianshu.com/p/486b0965c296"&gt;聊聊Linux 五种IO模型 - 简书&lt;/a&gt;这篇文章）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同步请求——调用方主动获取被调方的结果&lt;/li&gt;
&lt;li&gt;异步请求——调用方被动收到被调方的通知&lt;/li&gt;
&lt;li&gt;Java线程阻塞状态——blocked&lt;/li&gt;
&lt;li&gt;Java线程等待状态——waiting，timed waiting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Java 线程的状态，可以参考下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/n2U3N.png" alt="" title=""&gt;&lt;/p&gt;

&lt;h2 id=""&gt;我们到底在说的是哪个概念？&lt;/h2&gt;

&lt;p&gt;一般当我们在说同步异步，阻塞非阻塞的时候，我们说的到底是哪个概念呢？&lt;/p&gt;

&lt;p&gt;是系统内核 IO 类型吗？如果这样的话，根本是没有异步阻塞的说法的，因为 IO 只有异步模型，按照异步模型的行为，是不阻塞进程执行的。&lt;/p&gt;

&lt;p&gt;那么我们是在说字典里的4567这四条解释吗？看起来好像是的，当我们说同步请求的时候，确实是在等执行结束后才能得到结果，主动赋值给一个变量；异步请求的时候，通过 callback 或者 listener 调用回来修改数据 ；当我们说阻塞的时候，Java 线程的状态是……哎？Java 线程的状态可不是只有阻塞（blocked）一个这么简单，而是还有 Waiting、Timed Waiting 状态，表示线程没有继续执行，在等待条件成熟的手变成 Runable 或者 Blocked。难道这种情况算是非阻塞？&lt;/p&gt;

&lt;p&gt;原来，当我们说一个函数阻塞非阻塞的时候，并不是在按照上述的定义去解释的，而是按照线程执行的角度去解释的。也就是说，如果函数调用的时候线程在继续执行逻辑，就是非阻塞的；如果在等待调用结束不继续执行，就是阻塞的。也就是说，第六条和第七条都算是阻塞的。&lt;/p&gt;

&lt;h2 id=""&gt;为什么我们要按照这个定义去理解？&lt;/h2&gt;

&lt;p&gt;有人可能觉得不服气，怎么就不能按照执行过程中的 IO 类型来划分？
我是这么理解的：一个编程概念的提出，是有它的语境的。比如 IO 模型，很确定是发生在IO 时的事情，而我们讨论一个函数的同步异步，阻塞非阻塞，是为了研究这次函数调用对我的程序执行顺序的影响，而非其中的某次 IO，因为这次 IO 的类型不会影响我怎么写代码，这种类型差异在封装过程中就已经抹平了。在我看来，同步就是函数返回值，异步就是回调函数，阻塞就是不执行结束不继续执行后边的逻辑，非阻塞就是不等结果继续执行。这样的定义才能让使用函数的人不用看源码就能继续放心的开发下去。&lt;/p&gt;

&lt;h2 id=""&gt;可以举个例子吗？&lt;/h2&gt;

&lt;p&gt;嗯，光是在理论逻辑上去论证是很枯燥又难以理解的，不如我们看点例子吧。&lt;/p&gt;

&lt;p&gt;首先看一个最简单的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    public static Result test() throws ExecutionException, InterruptedException {
        final ExecutorService executorService = Executors.newFixedThreadPool(1);
        final Result result = new Result();
        final Future&amp;lt;String&amp;gt; submit = executorService.submit(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "test";
        });
        result.done = true;
        result.text = submit.get();
        executorService.shutdown();
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test函数是同步还是异步，阻塞还是非阻塞呢？有朋友看到这里有线程池，执行的结果是交由另一个线程来处理的，所以理所当然的认为是异步的；由于执行过程会被 &lt;code&gt;submit.get()&lt;/code&gt;所阻塞，所以是阻塞的。可是在我看来，这个函数你会起名为 asyncTest 吗？不会的。虽然&lt;code&gt;executorService.submit&lt;/code&gt;确实是异步执行，但是这个函数内还对 future 进行了 get 操作，使得整个函数结束后返回完整的应答，变成了同步的。因此这个函数可以说是同步阻塞的。&lt;/p&gt;

&lt;p&gt;再看一个的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    final static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static Result test(){
        final Result result = new Result();
        executorService.execute(() -&amp;gt;{
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result.done = true;
            result.text = "test";
        });
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println("doing sth in main");
        while (!test.done);
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个test 函数的声明看起来就是个普通函数，但是需要等 done 结束才能使用。这是同步的还是异步的呢？我认为这算是异步的，因为需要等待 done 被通知修改后才能完成整改逻辑。由于可以 doing sth in main，这个是异步非阻塞的。如果把 done 改成传入的一个回调函数，就更容易被确认为异步了；我认为这两个行为是没有差别的，因为远离都是提交出去的任务通过通知的方式给到了原有线程。&lt;/p&gt;

&lt;p&gt;啊，既然这么说来，如果想变成异步阻塞怎么办呢？就在 test 函数中阻塞一下，比如 join 提交的任务，这不就是传说中的异步阻塞了嘛。只是异步阻塞的编程大多数情况下没必要写，因为都已经阻塞了，异步跟同步对于原有线程的代码执行顺序都没有任何区别了，无非是主动发请求还是收通知。异步的写法比同步写法麻烦多了，也就不太需要异步阻塞了。我能想到一种异步阻塞的情况，就是提交的任务会周期性的执行，也就是不只一次通知原有线程，比如配置文件的 watch就是类似的情况，会写成&lt;code&gt;Config.watch(filename,listener)&lt;/code&gt;,在程序初始化的过程中，必须先执行 listener，得到配置文件内容才能继续初始化；初始化后，如果有人改了配置文件，listener 会被再一次触发，从而改变程序的行为。&lt;/p&gt;

&lt;p&gt;再来看一个例子，来自ConcurrentLinkedQueue：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public boolean offer(E e) {
        checkNotNull(e);
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

        for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
            Node&amp;lt;E&amp;gt; q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数在执行过程中的亮点在于 &lt;code&gt;p.casNext(null, newNode)&lt;/code&gt; 和 &lt;code&gt;casTail(t, newNode)&lt;/code&gt;，两个 CAS 操作不阻塞，又完成了并发条件下的 offer 函数，整个函数是同步的，又没有阻塞，因此是同步非阻塞。&lt;/p&gt;

&lt;h2 id=""&gt;总结&lt;/h2&gt;

&lt;p&gt;其实很多时候不同的看法是因为我们的定义不同。如果同步和异步是指通信方式，阻塞非阻塞是指线程执行与否，那么我们就可以顺利得到示例里的结论；如果指的是 Linux IO 模型，那么显然我示例都是与之无关的。&lt;/p&gt;

&lt;p&gt;但是不管怎样，只要你能够根据你使用的定义去理解程序的行为方式，并写出正确的调用代码，我想这才是最重要的。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</guid></item><item><title>搬瓦工免费换 ip</title><link>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</link><pubdate>2018-06-26</pubdate><content:encoded>&lt;p&gt;前两天我的搬瓦工突然被封禁了，一大票技术网站无法访问，实在不方便。登录搬瓦工想找地方换 IP，发现这个基础款的产品自己不支持换 IP 换机房。正在想实在不行就得还供应商的时候，突然搜到搬瓦工针对此情况专门提供了免费更换 IP 的功能，每十周换一次，还是挺爽的。&lt;/p&gt;

&lt;p&gt;这个功能就是当你确信你的机器被墙了，可以访问&lt;a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck"&gt;https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck&lt;/a&gt;，此时会提示检测 ip，&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Xnip2018-06-26_12-01-04.jpg" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;然后点击 Test Main IP，如果检测到被封禁，就会出现 next 按钮，自然点击 next 按钮更换 IP 就好啦。&lt;/p&gt;

&lt;p&gt;不过由于 IP 变化了，需要运行以下命令更新 iptables 记录：
&lt;code&gt;iptables -F; iptables -t nat -F; iptables-save &amp;gt; /etc/sysconfig/iptables&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后别忘记去域名管理把你服务器的域名 A 记录换掉哦！要不然域名还是无法访问的！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</guid></item><item><title>一个USB-C的时代</title><link>http://blog.shrp.me//An-Era-of-USB-Type-C.html</link><pubdate>2018-06-15</pubdate><content:encoded>&lt;p&gt;最近为了配合在家用电脑的显示器需求，买了一台联想的ThinkVision显示器——&lt;a href="https://item.jd.com/4702716.html"&gt;联想（ThinkVision）T27h 27英寸窄边框 &lt;/a&gt;，用了几天，颇有些感想。&lt;/p&gt;

&lt;p&gt;首先，这货有一个坏点。显然联想在显示器的品控并不太好，而且国家的政策里坏点是允许的，而且越大的屏幕坏点允许就越多。当然我可以按照京东7天无条件去退换，可是这款显示器推出快一年了，按照系统显示，它的库存不多了，按照二手东的情况，可能剩下的多少有点问题。这款是我唯一能够找到价格比较低，带有USB-Hub功能的USB-C可充电可旋转显示器了（其实还有一款三星的，但是为了老回，必须不买三星的）。还好的是一个坏点并不是太大的问题，如果你观察你自己的显示器，其实上边落满了灰尘，一个坏点的影响就像是一粒灰尘，并不太影响。事实上，当你打开游戏，打开电影的时候，这个坏点根本就看不到。所以这次为二手东接了盘，感觉也还可以接受。&lt;/p&gt;

&lt;p&gt;虽然显示器有个坏点，但是功能上来说，它真的非常适合我的情况。我目前手里有三套设备，一个台式机，一个新版MacBook Pro，一台GPD pocket。台式机是没有USB-Type C的接口的，视频走HDMI接口；但是苹果本和pocket都是支持Type C接口的。我的电脑桌桌面空间很紧凑，键鼠当然只能有一套，如何用这一套键鼠控制三台电脑，关键只能是怎么利用显示器的USB-Hub功能了。&lt;/p&gt;

&lt;p&gt;然而显示器的USB-Hub是Type-C接口是host，四个普通USB接口去接键鼠。这个原理就像是那些Type-C的转接器一样，只不过转接器的视频输出直接接入显示器的视频输入了而已。那么Pocket和苹果本天然就应该支持边充电边视频输出，并且接到显示器的键鼠也可以用。结果我试了一下，不论是用苹果还是绿联买的一根充电线，还是显示器自带的Type-C线，都只能让苹果本使用，Pocket只能充电，不能显示视频，也无法实现USB-Hub。不过我插上了一款&lt;a href="https://item.jd.com/10391831021.html"&gt;绿联的0.5米长的线&lt;/a&gt;时，奇迹发生了，Pocket也能边充电边显示视频，还能使用接入的键鼠了。Perfect！&lt;/p&gt;

&lt;p&gt;不过还有一个麻烦，就是台式机怎么接入呢？台式机没有Type-C接口，没法直接使用。最简单的方法是电脑用一根Type-C的数据线（一头是Type-A的公头，另一头是Type-C的公头）我之前设想的是买一款Type-C的延长线（一公头一母头）接到显示器，一根USB Type-A公头转USB Type-C公头的普通数据线来连接。当用台式机的时候，就是&lt;code&gt;台式机--A转C数据线--延长线--显示器&lt;/code&gt;；当用苹果本的时候，就是&lt;code&gt;苹果本--C双公头的数据线--延长线--显示器&lt;/code&gt;。结果这个方案失败了：延长线是有逻辑的，公头是host，母头是client。但是在我的设计里，延长线的母头被用来连接host电脑了，公头插到显示器上，跟设计的方向是反的，现在只能充电显示，USB-HUB功能不能用，三个设备都不能。不过我又心生一计，电脑上用一个USB Type-A公头转USB-Type-C母头的转换器，再连到显示器，是不是就可以把显示器当成是USB-Hub了呢？这个情况下的连接是&lt;code&gt;电脑--公A转母C--C双公头的数据线--显示器&lt;/code&gt;，跟苹果本切换的时候只要把“双公头的数据线”连到公A转母C就可以了啊。这个方案理论上可行，赶紧去京东下单买转接头了，大概明天才能验证。&lt;/p&gt;

&lt;p&gt;不过不管验证情况怎么说，Type-C开始在电脑和手机上引领的接口风暴，怕是会越来越激烈了。对于用户来说，一个统一的接口价值相当的重要。恐怕只有等无线连接到来的时候，Type-C才会被淘汰了吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//An-Era-of-USB-Type-C.html</guid></item><item><title>联通IPTV诺基亚贝尔机顶盒怎么安装第三方应用</title><link>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</link><pubdate>2018-04-06</pubdate><content:encoded>&lt;p&gt;由于旧的IPTV盒子坏了，今天抽空去联通换了个IPTV，是上海诺基亚贝尔的S-010W-AV2B机器。拿回来以后IPTV功能都正常，但是一个安卓机顶盒不装点其他应用，那多浪费啊。没想到U盘插上去，傻眼了：apk都不显示，这可咋安装啊？&lt;/p&gt;

&lt;p&gt;一般来说这个方法应该有很多种，比如同一网络下用悟空遥控去推送，比如用USB线连到电脑上安装，比如连上键盘，按快捷键打开网页下载apk。可是一一试过以后发现都不能用，adb没有开，快捷键也被关闭了。&lt;/p&gt;

&lt;p&gt;正手足无措的时候，发现系统点击官方的应用商城居然会下载一个apk安装。嗯？如果我劫持url，下载一个贝当市场，问题不就迎刃而解了吗？&lt;/p&gt;

&lt;p&gt;具体步骤如下：
1、找了个电脑，设置网络共享。我家的IPTV方案是机顶盒通过光猫的wifi上网的，那么我的网络共享就是电脑连光猫的wifi，把网络共享给自己的网线，通过网线连接到IPTV机顶盒。&lt;/p&gt;

&lt;p&gt;2、装上wireshark抓包&lt;/p&gt;

&lt;p&gt;3、在机顶盒点击联通自己的应用商城，成功在wireshark里抓到了http请求地址：http://210.13.0.175:7084/launcher/data/1522120317/CUTV_DSMClient_V4.5.apk&lt;/p&gt;

&lt;p&gt;4、在自己电脑上架设一个网站（要监听所有的设备哦），在相应的地址，相同的文件名放一个贝当应用商店的apk。但是ip地址怎么办？别担心，我在电脑上添加了一个虚拟网卡，地址设置为静态的210.13.0.175，这样请求上来的时候自动就被路由到自己的这个网卡上了。如果你的自建站点按照我的提示监听了电脑所有的网卡，那么这个时候通过你电脑访问的下载请求都会被指向自己的假冒apk了。&lt;/p&gt;

&lt;p&gt;5、把机顶盒的商店卸载掉，再点击安装，很快进度条就走完了，只不过99%的时候提示验证错误，大概是安装后有个验证流程，还需要劫持后修改下，不过不要紧，就算不修改，apk已经安装好了。&lt;/p&gt;

&lt;p&gt;6、最后记得把自己的电脑的网络共享关掉，机顶盒连到正常的网络下下载你想要的apk吧。需要看IPTV的时候，把机顶盒连到光猫的IPTV的wifi下，就可以正常看IPTV了；需要看网络电视的时候，就连到普通wifi下看第三方apk的视频啦。&lt;/p&gt;

&lt;p&gt;最后强调一下，每个人的机顶盒访问的地址不一定一样，因此你一定要自己抓个包，才可能有效。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</guid></item><item><title>HG220GS-U改桥接模式</title><link>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</link><pubdate>2018-04-05</pubdate><content:encoded>&lt;p&gt;前两天联通宽带续费升级，原来的百兆猫要换成千兆猫，新猫型号是HG220GS-U.我自己有需要把光猫后的路由器映射到公网去,因此一般都会做dmz或者端口映射.联通原来的猫就有bug,dmz设置不生效,必须要挨个做端口映射;这个新猫更过分,dmz和端口映射均不生效.还好在网上搜到老周的一篇教程&lt;a href="http://guanggai.org/thread-459-1-1.html"&gt;烽火HG220G-U E00L2.03M2000光猫改桥接教程&lt;/a&gt;,解决了问题.&lt;/p&gt;

&lt;p&gt;原文里也有点小问题,telnet节点不必打开,后续操作也用不上telnet,而且telnet一旦打开,从外网也可以telnet到的,用户名admin,密码admin,只怕没几分钟就已经被攻陷了.其他操作均与原文相同.&lt;/p&gt;

&lt;p&gt;为了防止原链接失效,简单讲过程记在下边:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;登录光猫管理页面&lt;a href="http://192.168.1.1/"&gt;http://192.168.1.1/&lt;/a&gt;,默认用户名user,密码在光猫背后.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录后访问&lt;a href="http://192.168.1.1/backupsettings.conf"&gt;http://192.168.1.1/backupsettings.conf&lt;/a&gt;,将现有的配置文件保存并且备份,不管什么时候都能轻易恢复原有配置了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用notepad++或者sublime编辑一个配置文件的副本,先找到&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括IPTV的那个配置,北京联通通常出现在&amp;lt;WANConnectionDevice instance="4"&amp;gt;下,可以看到该配置的X_BROADCOM_COM_IfName的属性是epon0.4.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再找到上网的配置,也就是&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括INTERNET的那个配置,通常是&amp;lt;WANConnectionDevice instance="2"&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除该配置节点内的删除&amp;lt;IdleDisconnectTime&amp;gt;120&amp;lt;/IdleDisconnectTime&amp;gt;一整行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改该配置节点内的ConnectionType属性,从IP_Routed改为PPPoE_Bridged.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的名字从2_INTERNET_R_VID_3961改成2_INTERNET_B_VID_3961(也就是R改成了B),这个改动不知道是否必须&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的X_BROADCOM_COM_IfName属性从ppp0.2改成epon0.2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在该配置节点X_BROADCOM_COM_IfName后新增节点&amp;lt;X_CU_IPMode&amp;gt;3&amp;lt;/X_CU_IPMode&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href="http://192.168.1.1/updatesettings.html"&gt;http://192.168.1.1/updatesettings.html&lt;/a&gt;,选择上传配置,然后路由会自动重启,重启后就是桥接模式了,需要光猫后边的路由器或者电脑自己拨号才能上网了.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS:旧版的HG220GS是可以通过网址&lt;a href="http://192.168.1.1/logoffaccount.html"&gt;http://192.168.1.1/logoffaccount.html&lt;/a&gt;打开隐藏账户的,然后就可以通过&lt;a href="http://192.168.1.1/cu.html"&gt;http://192.168.1.1/cu.html&lt;/a&gt;登录管理员账户,用户名CUAdmin,密码123qweasdzxc.但是我的这个网页是不能访问的.隐藏账户登录后可以关闭端口扫描的防御来打开DMZ和端口映射功能.&lt;/p&gt;

&lt;p&gt;但是又有人说这种情况可以通过&lt;a href="http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1"&gt;http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1&lt;/a&gt;访问来开启隐藏账户,这个我就没有尝试了,大家可以自行尝试.&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</guid></item><item><title>程序员工作用什么操作系统？</title><link>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</link><pubdate>2018-03-10</pubdate><content:encoded>&lt;h1 id=""&gt;程序员工作用什么操作系统？&lt;/h1&gt;

&lt;p&gt;　　今天偶然看到之前关注的 vpsee 网站一篇09年的文章(&lt;a href="https://www.vpsee.com/2009/06/why-programmers-love-mac/"&gt;为什么国外程序员爱用 Mac？ | vpsee.com&lt;/a&gt;)在讨论为什么程序员喜欢用 Mac，文章后洋洋洒洒数百个评论或激昂，或讽刺，或诅咒，或炫耀，好不热闹。恰好最近一个.Net 开发同事想用 Mac 开发 Java 程序，一个 Java 开发 同事想把自己的 Mac 换成 Windows，真是有意思。于是我也按耐不住，想要说点什么。&lt;/p&gt;

&lt;p&gt;　　开始前我想先声明一下，如果说有人说这个话题没有偏颇，我真不太相信。每个人连颜色都有自己的偏好，操作系统这么复杂而又常用的东西如果没有喜好那也太大条了。我当然也不例外。就目前而言，我作为一个开发，是用 Mac 多一些，也喜欢用 Mac；但是我并不觉得每个程序员都用，或者每个程序员都喜欢用 Mac 是正常的，正相反，我觉得最多只有一半喜欢或者应该用 Mac来从事开发工作。&lt;/p&gt;

&lt;p&gt;　　先说 Windwos。Windows 借中国早先盗版的问题最先在群众中普及，我也不例外，从98年家里的第一台电脑开始就在用 Windows。这个系统我们用得多了，也就耳熟能详怎么去把玩到极致：从 DOS 时代在启动文件里调整虚拟内存，到9x 的简繁转换，再到 NT 内核系统的服务优化，再到 Windows10 的免费升级。应用怎么查杀，注册表的大体结构，游戏使用的 direct 技术和安装方法，不论是写代码，玩游戏，还是看电影听音乐，基本是无所不能。更不要说.NET 程序员了，目前来说只在 Windows 工作。甚至包括怎么分区，多久备份一次，怎么快速备份恢复，一个老 Windows 程序员估计都有自己的方案，以免在升级失败，电脑蓝屏时还不用耽误太久工作。尽管这些技能都跟程序开发没有直接关系，却能帮助我们尽快解决手头的问题，把精力集中在开发上。然而并不是程序员都是.NET 程序员，Windows 也不是100%契合所有开发人员的需求，有些问题会一而再再而三的坑害开发，比如说中文版 Windows 默认的字符编码是 GB2312，而大多数部署到 Linux 的软件都得处理 UTF-8。那么开发在部署的时候经常要注意自己的代码里处理字符集转换，一些文字要提前处理成 UTF-8。而且即便是在 Windows 保存为 UTF-8文件，还会面临另一个问题：BOM 头。在 Windows 上 BOM 一般不会惹什么麻烦，但是当部署到 Linux 服务器的时候，结果就不好说了；ImportNews 网站的 RSS 甚至就带有 BOM 头，而带有 BOM 头的 RSS 是不符合 XML 规范的。一个 Java 专业社区的组件都有这样的 bug，还能指望 Windwos 开发对于 Linux 开发有多友好呢？再比如说 Windows 的目录是分磁盘的，C:\，D:\等等，而且目录的分割用\而不是/。这对一些预计部署在 Linux 的服务的开发带来了负面的影响。再有就是孱弱的命令行环境了，自带的命令稀缺，Linux 的工具链工具几乎不支持，这对于工作面对 Linux 服务器的程序员来说都不是什么好事情。&lt;/p&gt;

&lt;p&gt;　　再说 Linux。我刚开始用 Linux 还是高三的时候，是很经典的小红帽 Red Hat，好像一共6张 CD 光盘。当时就是尝个鲜，装好了以后主要在窗口界面里乱用。后来工作后才真正开始学习怎么去用 Linux，看《鸟哥的 Linux 私房菜》，把服务部署到 Linux 服务器上，但是当时开发还是 Windows。在进行了1年的 跨平台开发后，被字符集坑惨的我开始用最流行的 Ubuntu 来开发程序，当时使用的是 Ubuntu10 LTS。 Ubuntu确实简单易上手，互联网上也充斥着大量使用 Ubuntu 的经验，基本上遇到什么问题都能用搜索引擎得到质量比较高的回答。Linux 跟生产的环境是相当契合的，不太容易出现环境部署的问题。但是 Ubuntu 最大的问题就是官方仓库东西还是不够，必须添加私有源；可是私有源到了后期却或多或少带有的陈旧核心组件，都可能存在不同乃至冲突。有时候甚至为了看 flash，装个 vpn 而安装的某个源带入的依赖跟系统最新的根本不搭，导致后续的更新都不能应用了。解决问题一定是有方法的，但是却需要开发者投入不少的精力去跟踪操作系统里发生了什么冲突，怎么去解决。此后我还用过 cent OS，Mint，Arch，然而大同小异，总是因为系统里安装的什么东西不兼容，从而系统没法完整升级。这种情况一开始可能只是几个包，但是后来不满足依赖的升级越来越多，而且有时候为了某个特定的需要，比如 docker，还不得不升级。这些冲突解决起来痛苦而且耗费时间，因此Linux最适合还是放在服务器里，不出事情几年都想不起升个级的。&lt;/p&gt;

&lt;p&gt;　　至于 Mac 么，真的是我用过最省心的操作系统了。插上移动硬盘就自动备份，不管是换电脑，还是出问题重装系统，都可以在一个小时左右恢复搞定，而且恢复以后打开浏览器，上次没关闭的窗口还热乎着呢。目录符合 unix 风格，程序跑起来没什么毛病。工具链也有，很多脚本都是可以直接用的。用 Mac 开发，既可以不断享受升级，又不会太折腾，可以把精力集中在代码本身。不过 Mac 也不是完全没有问题。就我自己遇到的就有这么几种情况：每次升级都有可能一些安全性的提升导致某些软件用不了；1024以下的端口默认不可以被用户程序占用；命令其实是 BSD 版本的，参数跟 Linux 上的并不一致；默认文件系统不是大小写敏感的，甚至很多软件都不支持在大小写敏感的分区上使用（没想到吧）；并不太可能做到完全不用鼠标，不过用鼠标的次数还是可以比较少的。&lt;/p&gt;

&lt;p&gt;　　在我看来，其实并没有一个最合适的电脑。如果想省心省力，能够集中精力去开发的，也就是 Mac 了，这也是大多数中年程序员的首选，每天除了工作还要肩负养家糊口的重担，没有太多时间去折腾设备，用一款 Mac 可以帮助他们做到这点。如果是刚刚开始工作的程序员，有大把时间去折腾，那选择一款 Linux 长时间使用就比较合适，能够更熟悉自己软件部署的环境，写出的代码就更容易减少出 bug 的可能，如果剩下的软件也能维护好升级和依赖的关系，配置的足够好，免鼠标什么的没问题，开发效率也可以得到提升。至于剩下的程序员，或者要开发 Windows 程序，或者 Windows 非常熟悉，或者对系统差异足够熟悉的，用 Windows 开发并不会给他们带来不便。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</guid></item><item><title>一个不严谨的 String Intern 测试</title><link>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</link><pubdate>2018-01-15</pubdate><content:encoded>&lt;p&gt;　　今天在 Reeder 上看到一个关于 String Intern 的&lt;a href="http://www.importnew.com/27694.html"&gt;文章&lt;/a&gt;，自己测试了一下，发现有些地方并不严谨。&lt;/p&gt;

&lt;p&gt;　　原文用了一段如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public static void main(String[] args) {
    String s = new String("1");
    s.intern();
    String s2 = "1";
    System.out.println(s == s2);
    String s3 = new String("1") + new String("1");
    s3.intern();
    String s4 = "11";
    System.out.println(s3 == s4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目的很明确，希望通过==判断 intern 能否为下一次赋值从 intern 的池里提供。然而这段代码做了一个假设：在 main 函数之前，没有任何字符串被 intern。&lt;/p&gt;

&lt;p&gt;　　然而我在Java8以上测试，却发现了有意思的情况。考虑以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;    public static void main(String[] args) {
        String s =  String.valueOf(1) + String.valueOf(1);
        s.intern();
        String s2 = "11";
        System.out.println(s == s2);

        String s3 = String.valueOf(1) + String.valueOf(2);
        s3.intern();
        String s4 = "12";
        System.out.println(s3 == s4);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　按照原文作者的假设，结果应该都是 true 才对，第一次 intern 的时候该对象保存进入常量，第二次赋值的时候取出，因此==的两个结果是 true。&lt;/p&gt;

&lt;p&gt;　　但是在我的机器和其他同事的机器上却发现有人是 false，true，有人是 false，false，有人是 true，true。也就是说，JVM 根据某些信息提前进行了 intern，这种 intern 操作来自哪里，我暂时还不知道，有知道的同学可以帮忙在回复里解释一下。&lt;/p&gt;

&lt;p&gt;　　BTW，调用 intern 却不是用其返回值作为对象，那么这次使用的对象不一定是在 Intern 里存储的那个对象，使用==的结果并不是确定的。这种类似 C 的未定义行为，不能作为 Java 特性的说明，也不能在生产代码里使用，原文的原理是正确的，但是代码却没有说服力了。这从另一个角度提醒我们写代码还是要大胆假设，小心求证。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//a-None-Strict-String-Intern-Test.html</guid></item><item><title>简单的Http客户端——OKHttp</title><link>http://blog.shrp.me//simple-http-client-okhttp.html</link><pubdate>2017-12-21</pubdate><content:encoded>&lt;p&gt;&lt;a href="https://github.com/square/okhttp"&gt;OKHttp&lt;/a&gt;支持以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;http/2支持，同一个host可以共享一个端口&lt;/li&gt;
&lt;li&gt;如果http/2不支持，则使用连接池降低请求延迟&lt;/li&gt;
&lt;li&gt;透明gzip请求的返回&lt;/li&gt;
&lt;li&gt;可以针对重复的网络请求进行缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下文将分几个方向介绍OKHttp：&lt;/p&gt;

&lt;p&gt;1.引用&lt;/p&gt;

&lt;p&gt;当前最新版本是3.9.1，使用maven仓库引入即可，maven配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="xml"&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.9.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gradle 配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;compile 'com.squareup.okhttp3:okhttp:3.9.1'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.先引入一个函数来表示具体的请求，后边的执行大多会使用这个函数来发起具体的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;private static Response executeRequest(final OkHttpClient okHttpClient, final Request build) {
        try {
            final Response response = okHttpClient.newCall(build).execute();
            if (response.isSuccessful()) {
                System.out.println(response.code() + " : " + response.body().string().length());
            } else {
                System.out.println(response.code());
            }
            return response;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.基本的get请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple get: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.基本的post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MediaType parse = MediaType.parse("application/json");
        final RequestBody requestBody = RequestBody.create(parse, "{}");
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(requestBody)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("simple post: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.multipart post请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final MultipartBody form = new MultipartBody.Builder().addFormDataPart(
                "test", "test"
        ).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .post(form)
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("multipart post: ");
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.带有缓存功能的get&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache).build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_NETWORK)
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("cached get: ");
        final Response response = executeRequest(okHttpClient, build);
        assert response.networkResponse() != null;
        final Request request2 = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .cacheControl(CacheControl.FORCE_CACHE)
                .addHeader("client-version", "3.9.1")
                .build();
        final Response response2 = executeRequest(okHttpClient, request2);
        assert response2.cacheResponse() != null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.异步请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("async get: ");
        okHttpClient.newCall(build).enqueue(new Callback() {
            @Override
            public void onFailure(final Call call, final IOException e) {
                System.out.println(call.request().url() + " is failed. " + e.getMessage());
            }

            @Override
            public void onResponse(final Call call, final Response response) throws IOException {
                if (response.isSuccessful()) {
                    System.out.println(response.code() + " : " + response.body().string().length());
                } else {
                    System.out.println(response.code());
                }
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.带有拦截器的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt; final File cacheDir = Files.createTempDirectory("test").toFile();
        final Cache cache = new Cache(cacheDir, MAX_SIZE);
        final OkHttpClient okHttpClient = new OkHttpClient.Builder().cache(cache)
                .addInterceptor(chain -&amp;gt; {
//                    System.out.println("intercept 1.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 1 return.");
                    return proceed;
                })
                .addInterceptor(chain -&amp;gt; {
                    System.out.println("intercept 2.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("intercept 2 return.");
                    return proceed;
                })
                .addNetworkInterceptor(chain -&amp;gt; {
                    System.out.println("network intercept.");
                    final Response proceed = chain.proceed(chain.request());
                    System.out.println("network intercept return.");
                    return proceed;
                })
                .build();
        final Request build = new Request.Builder().url("http://blog.shrp.me")
                .header("PostId", "12345")
                .addHeader("client-version", "3.9.1")
                .build();
        System.out.print("intercept get: ");
        executeRequest(okHttpClient, build);
        System.out.print("intercept get from cache: ");
        executeRequest(okHttpClient, build);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.还可以添加认证器，在异步调用后使用cancel取消等功能。&lt;/p&gt;

&lt;p&gt;okhttp的api更易用，据说性能也不错。以后有机会可以进行性能的比较。本文代码可以在&lt;a href="https://github.com/stirp/MyTests"&gt;https://github.com/stirp/MyTests&lt;/a&gt;找到。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//simple-http-client-okhttp.html</guid></item><item><title>在Mac OS X管理多个Java环境</title><link>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</link><pubdate>2017-12-18</pubdate><content:encoded>&lt;p&gt;　　Java刚出了Java9，Java10也在日程上了。然而Java的相关环境实在是太多，对于某些增强型的组件，是依赖某个特定版本的Java进行工作的，当手头的项目多，不得不对不同版本的Java进行开发的时候，就必须来回不停切换版本，实在是不方便。其实不同版本的Java目录是不同的，完全可以同时存在。通过本文介绍的工具Jenv就可以管理本机的多个Java环境，并且通过简单的配置就可以让指定项目使用特定的Java版本，无需再进行反复切换了。这个工具本身还是开源的，地址就在&lt;a href="https://github.com/gcuisinier/jenv"&gt;https://github.com/gcuisinier/jenv&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　先要强调，Jenv是个脚本软件，作用环境限于shell环境内，如果是使用IDE比如eclipse，Intellij，那它体现不出它自己的价值，毕竟IDE一般都具有管理JDK的功能。安装Jenv的方式很简单，直接clone到~/.jenv中，然后把bin目录添加到系统路径中，重启shell就好啦。&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; git clone https://github.com/gcuisinier/jenv.git ~/.jenv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; vim ~/.local/share/omf/init.fish&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;code&gt;&amp;gt; cp fish/jenv.fish ~/.config/fish/functions/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　在文件中添加&lt;code&gt;set PATH $HOME/.jenv/bin $PATH&lt;/code&gt;。这是fish shell的安装方式，其他方式可以参考官方文档。&lt;/p&gt;

&lt;p&gt;　　装好以后通过&lt;code&gt;jenv add /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home&lt;/code&gt;可以将安装在该目录下的Java添加到jenv中。目前的jenv在fish上有点问题，jenv默认有两个文件夹不存在，因此需要先执行&lt;code&gt;mkdir ~/.jenv/versions&lt;/code&gt; 和 &lt;code&gt;mkdir ~/.jenv/plugins&lt;/code&gt;先建立目录才能执行jenv add和jenv enable-plugins.&lt;/p&gt;

&lt;p&gt;　　Jenv有两个环境，global和local，分别对应全局jdk和文件夹内的jdk版本指定。对于我来说，一般全局使用最新的Java版本，在不能使用最新Java的文件夹内执行&lt;code&gt;jenv local 1.8.0&lt;/code&gt;来指定比如1.8.0版本。如果使用了maven，gradle等编译管理软件，需要用&lt;code&gt;jev enabel-plugin maven&lt;/code&gt;来重定向mvn命令，以便maven也使用指定的Java版本。其他工具，比如gradle，原理是类似的。&lt;/p&gt;

&lt;p&gt;　　有了这个工具，从此再也不怕多种版本的Java开发啦！&lt;/p&gt;

&lt;p&gt;Update 12.19:&lt;/p&gt;

&lt;p&gt;　　对于fish来说，启动的时候需要执行jenv rehash，来确保java由jenv管理。最简单的方法在~/.config/fish/conf.d/omf.fish里增加&lt;code&gt;jenv rehash&lt;/code&gt;即可。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Manage-Multi-Java-version-on-Mac-OS-X.html</guid></item></channel>
</rss>