<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>2018-09-09</title><link>http://blog.shrp.me//2018-09-09.html</link><pubdate>2018-09-10</pubdate><content:encoded>&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.infoq.com/cn/articles/how-to-write-a-good-software-design-document"&gt;如何才能写出好的软件设计文档？&lt;/a&gt; 做了这么多年的 Java 开发，除了在恶补测试，我想最需要恶补的其实是设计。我们虽然没有设计也做了这么多年的系统，但是没有先行设计，总是缺乏对系统方向的把握。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html"&gt;哈希碰撞与生日攻击 - 阮一峰的网络日志&lt;/a&gt; 虽然不是 Java 语言，但是这个问题存在于任何语言的哈希算法之中，值得一看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://liuzhengyang.github.io/2017/07/27/jitwatch/"&gt;使用JITWatch查看JVM的JIT编译代码 | 刘正阳&lt;/a&gt; 有时候我们对程序 JIT 优化后的情况不太了解，这个工具&lt;a href="https://github.com/AdoptOpenJDK/jitwatch"&gt;GitHub - AdoptOpenJDK/jitwatch: Log analyser / visualiser for Java HotSpot JIT compiler. Inspect inlining decisions, hot methods, bytecode, and assembly. View results in the JavaFX user interface.&lt;/a&gt;正合适。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.momothink.com/wonderpen/"&gt;WonderPen | 妙笔 - momothink&lt;/a&gt;妙笔，一个新的文档编辑工具，支持多级目录，存储自动增加版本可以支持回退，可以增加笔记备份，有导出功能，作者的用户画像是勤于写作的作家，实际上需要整理笔记的程序员也很适合。缺点是还不支持 sequence 或者 graph 语法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://commons.apache.org/proper/commons-weaver/download_weaver.cgi"&gt;Commons Weaver – Download Apache Commons Weaver&lt;/a&gt; 通过在类中生成（"weaving"）字节码，提供一种简单的方法来增强已编译的 Java 类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/snail007/shadowtunnel"&gt;GitHub - snail007/shadowtunnel: secure tunnel which help you protecting your tcp traffic between your machine and your service on remote.&lt;/a&gt; goproxy 作者的又一力作，为已有代理增加一个加密的链路。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/redisson/redisson"&gt;GitHub - redisson/redisson: Redisson - distributed Java objects and services (Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, Map Reduce, Publish / Subscribe, Bloom filter, Spring Cache, Executor service, Tomcat Session Manager, Scheduler service, JCache API) on top of Redis server. State of the Art Redis client&lt;/a&gt; Redisson是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。【Redis官方推荐】Redisson在基于NIO的Netty框架上，充分的利用了Redis键值数据库提供的一系列优势，在Java实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/rwv/chinese-dos-games"&gt;GitHub - rwv/chinese-dos-games: 🎮 Chinese DOS games in browser.&lt;/a&gt; 游戏大概有版权问题，但是技术是之前就很火的 WebAssembly 技术。不过这个目前最大的问题是存储没法保留，关闭浏览器存档就丢了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.wturrell.co.uk/phpstorm-ideavim-not-working/"&gt;PhpStorm troubleshooting – ideaVim stops working – William Turrell&lt;/a&gt; 这个也是我最近遇到的一个情况，idea 使用的 vim 插件突然就不工作了，编辑器回到了原始的状态，但是看插件是安装的，没有任何问题。原来是插件有个工作开关，默认开关还有快捷键，而且这个快捷键跟 Mac 的粘贴非常接近，囧。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.oschina.net/news/99768/tracking-users-across-the-web-via-tls-session-resumption"&gt;研究发现：不靠 cookie，网站也能通过 TLS 协议追踪你 - 开源中国&lt;/a&gt; 这个新闻有点恐怖，居然可以不用 cookie 而是通过 TLS 协议进行客户端的识别——这个功能对正常的业务来说没什么帮助，客户说关闭浏览器就关闭了；但是对于广告功能来说，完全可以用来短期跟踪客户，甚至对于手机的浏览器来说，完全可以替代 cookie 的作用了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-09.html</guid></item><item><title>2018-09-01</title><link>http://blog.shrp.me//2018-09-01.html</link><pubdate>2018-09-01</pubdate><content:encoded>&lt;p&gt;下边是9月01日的每周分享：&lt;/p&gt;

&lt;h2 id="java"&gt;Java新姿势：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="http://imushan.com/2018/08/29/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-DirectByteBuffer/"&gt;JDK源码阅读-DirectByteBuffer | 木杉的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;木杉大神的又一力作，让我们继续学习 JVM 里的内容。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://my.oschina.net/zijingshanke/blog/1930333"&gt;Uber 开源分布式追踪工具：JVM Profiler - RiboseYim‘s OpenSource Blog - 开源中国&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Uber 的这次开源非常受欢迎，这篇文章就是关于这款 Profiler 的详细介绍。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.importnew.com/29591.html"&gt;一次Java内存泄漏调试的有趣经历 - ImportNew&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然是个老外，但是讲述的问题是个好问题——长时间 fullGC 导致的超时问题。虽然技术问题本身不复杂，但是解决起来并没有想象中那么容易。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://blog.codingnow.com/2018/08/lockstep.html"&gt;lockstep 网络游戏同步方案&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;云风大神的详细讲解对于我们这样行业外的人来说真是一篇上等的入门力作。在此之前我只能猜测即时游戏的互联方案，其实这个方案在其他需要协作的场景都可以使用。对于非游戏程序员力荐。&lt;/p&gt;

&lt;h2 id=""&gt;新奇工具：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://gitee.com/ld/J2Cache"&gt;红薯/J2Cache: Java 两级缓存框架，可以让应用支持两级缓存框架 ehcache(Caffeine) + redis 。避免完全使用独立缓存系统所带来的网络IO开销问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;J2Cache 是 OSChina 目前正在使用的两级缓存框架。第一级缓存使用 Ehcache，第二级缓存使用 Redis 。由于大量的缓存读取会导致 L2 的网络成为整个系统的瓶颈，因此 L1 的目标是降低对 L2 的读取次数。该缓存框架主要用于集群环境中。单机也可使用，用于避免应用重启导致的 Ehcache 缓存数据丢失。与其说是个 cache，不如说是个 cache 桥梁，用于解决多级缓存的过期和更新不错。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/uber-common/jvm-profiler"&gt;GitHub - uber-common/jvm-profiler: JVM Profiler Sending Metrics to Kafka, Console Output or Custom Reporter&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Uber 开源的 Profiler，上文有介绍，可以参考下。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.oschina.net/p/smart-doc"&gt;smart-doc首页、文档和下载 - Java Restful API 文档生成工具 - 开源中国社区&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;号称免注入文档生成工具，目标还是比较长远的。既然不涉及生产，用于自动维护文档是不错的，已经在跟同事准备使用起来了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://jobob.gitee.io/mp3doc/"&gt;MyBatis-Plus&lt;/a&gt; &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个工具大概不是特别新奇了，我看已经有很多人在关注它的 github 源码了&lt;a href="https://github.com/baomidou/mybatis-plus"&gt;GitHub - baomidou/mybatis-plus: An enhanced toolkit of Mybatis to simplify development&lt;/a&gt;其使用会比直接使用 mybatis 简单很多，但是对于复杂业务来说还是需要写代码的。原理比较简单，本身性能无需担心。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://gitee.com/lsongiu/redis-shared-lock"&gt;qidianliusong/redis-shared-lock: 基于redis的分布式共享锁，使用注解的方式对方法加锁&lt;/a&gt; 一个基于 redis 的分布式共享锁，代码有点意思。由于开发历史不太久，最好不要直接用于生产。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=""&gt;新闻资讯：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.oschina.net/news/99299/windows95-open-source-project"&gt;经典不灭，开源项目带你在各平台上重温 Windows 95 - 开源中国&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大概很多人都没有用过 Windows95，有人用 Electron 制作了这款 Win95的虚拟机的前端界面，目测虚拟机是 bochs 下载地址：&lt;a href="https://github.com/felixrieseberg/windows95/releases"&gt;Releases · felixrieseberg/windows95 · GitHub&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://mp.weixin.qq.com/s/NamsJHwEOdF3GgGE5sM4gg"&gt;几个大型网站的Feeds(Timeline)设计简单对比&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很抱歉，这个是我最近比较关注的话题，看起来也不是最新的文章了，但是多关注一下其他社区的设计对于我们自己的社区就会多一些思考。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//2018-09-01.html</guid></item><item><title>2018-08-24</title><link>http://blog.shrp.me//2018-08-24.html</link><pubdate>2018-08-24</pubdate><content:encoded>&lt;p&gt;下边是8月24日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://hengyunabc.github.io/jvm-heap-dump-find-fd/"&gt;从JVM heap dump里查找没有关闭文件的引用&lt;/a&gt; 如果程序发布后长期持有一个本应该关闭的文件引用，一定是发生了引用的泄露，这种事情一般查起来是很费劲的，还得在代码里跟踪引用的传递。文章里的方法也可以用来找任意你怀疑泄露的资源，不过需要学会 OQL。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://blog.csdn.net/u013096088/article/details/81161084"&gt;Java与单例模式 - CSDN博客&lt;/a&gt; 单例模式大家都见得多了，什么美国的枚举单利，在代码里谈笑风生。不过为什么不能改进原有代码，使得反序列化不会破坏单例呢？本文通过阅读Java源码，给出了一个可行的方案：readresolve。不过面对一些速度著称的json库时，不见得可以像Java库函数那么标准，枚举依然是最安全的选择。&lt;/p&gt;&lt;/li&gt;

3. 
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://redkale.org/"&gt;redkale&lt;/a&gt;     Redkale(中文名: 红菜苔，湖北特产蔬菜)是基于Java 8全新的微服务开源框架， 包含HTTP、WebSocket、TCP/UDP、数据序列化、数据缓存、依赖注入等功能。 本框架致力于简化集中式和微服务架构的开发，在增强开发敏捷性的同时保持高性能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://oblac.github.io/jodd/"&gt;Jodd&lt;/a&gt; Jodd是个轻量的Java组件包，有基础工具，有mvc，有依赖注入，有web扩展。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lifei6671/mindoc"&gt;MinDoc&lt;/a&gt; Golang实现的基于beego框架的接口在线文档管理系统。一个好用的wiki系统真的是太重要了，不仅仅对于那些不差钱的大企业来说。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://lujun9972.github.io/blog/2018/08/18/%E8%AF%AF%E5%88%A0%E9%99%A4dev%E4%B8%8B%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E/"&gt;误删除dev下的文件怎么办&lt;/a&gt; 如果不小心删除了/dev/下的文件，也就意味着你电脑上的一些组件无法使用了。本文介绍了你如何可以恢复它们。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-24.html</guid></item><item><title>2018-08-19</title><link>http://blog.shrp.me//2018-08-19.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;这是我第一次编写每周分享。这个点子是受到阮一峰阮老师的每周分享启发，考虑到自己每周看了很多消息和工具，正好也能借助这个机会总结留下有价值的资讯。只要能帮助读者了解最新的研发消息，或者某天能用来总结查看，都算是没有白写每周分享。正常情况下我会在周五晚上发出这个系列的文章。（第一期就不正常……）&lt;/p&gt;

&lt;p&gt;我的每周分享会包括以下几点内容：本周内学会的一些Java最新的研发知识；发现的新工具；研发人员可能会关注的新闻。其中研发新闻是随缘项目，一方面我也不太关注没有生产力的新闻，一方面也没有太大的留存价值，只有特别关注到的新闻才会分享给大家。Warning：由于我的消息来源也包括阮老师，所以肯定有些内容是来自阮老师的网站，而且如果内容不带有阮老师的观点的话，来源会写真正的消息来源，而不是阮老师的网站；这主要是考虑读者不用多次跳转找出处，而非对阮老师的劳动不尊重，相信阮老师也会见谅的。&lt;/p&gt;

&lt;p&gt;下边是8月19日的每周分享：&lt;/p&gt;

&lt;p&gt;Java新姿势：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://imushan.com/2018/08/07/java/language/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ByteBuffer/"&gt;JDK源码阅读-ByteBuffer&lt;/a&gt;
&amp;nbsp;&amp;nbsp;木衫大神对 ByteBuffer 的理解。讲真的，当你开始从 Java 业务深入到底层技术的时候，Java 的 IO 系统始终会是需要关注和优化的一个点。这篇文章就是理解 ByteBuffer 设计的绝佳讲解。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://blog.shrp.me/personal-understanding-of-async-and-blocking.html"&gt;JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解&lt;/a&gt; 由于之前跟同事对一段代码是否同步，是否阻塞的看法不一致，所以想深入了解一下同步异步，阻塞非阻塞究竟是什么。个人才疏学浅，也希望有大牛帮忙指正。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://www.cnblogs.com/lovesqcc/p/9271781.html"&gt;CR常见代码问题 - 琴水玉 - 博客园&lt;/a&gt; 很多人应该都对 CodeReview 不陌生，这是个非常好的提高能力的机会，也是代码拿出来让大家一起改进的好机会。但是有时候一次 CodeReview 包含的事情太多，没有重点，效果也不会太好。这篇文章就对 CodeReview 应该做什么进行了详细的说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新奇工具：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/go-gitea/gitea/"&gt;gitea&lt;/a&gt; 有些人就是想自己搭建 git 服务器，但是又不想用 gitlab 这样重量级的产品。Gitea 就是这样一款产品，它的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。项目采用 Go 作为后端语言，只要生成一个可执行程序即可。并且它还支持跨平台，支持 Linux、 macOS 和 Windows 以及各种架构，除了x86、amd64，还包括 ARM 和 PowerPC 。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/PowerShell/PowerShell/"&gt;PowerShell Core&lt;/a&gt; PowerShell 对于 Windows 用户应该并不陌生，但是这款 Core ，知道的可能就少了，更何况它是开源并且跨平台的。它是微软开源的一个跨平台 (Windows, Linux 和 OS X) 自动化和配置工具（框架），可以和已有的工具友好集成，特别优化用于处理结构化数据 (如 JSON, CSV, XML 等), REST APIs 以及对象模型。它包含一个命令行 Shell、一个关联的脚本语言以及一个用于处理 cmdlets 的框架。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.importnew.com/29239.html"&gt;JVM 的 ASM 工具&lt;/a&gt; 在OpenJDK里有一个AsmTools项目，用来生成正确的或者不正确的java .class文件，主要用来测试和验证。可能对于普通开发人员来说这个工具没什么用，不过对于 JVM 语言开发来说可能很有价值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/kkk001/hp-reflect"&gt;kvn-wang/hp-reflect&lt;/a&gt;  hp-reflect 是一个高性能的反射工具。它使用字节码技术动态生成 access class。通过不同的 access class，可以高效的获取字段的值，或者调用方法，或者生成实例。 在基础框架中非常实用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://gitee.com/lym51/AutoLink"&gt;苦叶子/AutoLink&lt;/a&gt; AutoLink是一个开源Web IDE自动化测试集成解决方案,可以帮助你轻易的构建 Web 自动化测试脚本、HTTP 接口自动化测试脚本以及移动自动化测试脚本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="http://www.jumpserver.org/"&gt;Jumpserver - 开源堡垒机 - 官网&lt;/a&gt;完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 的专业运维审计系统。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/snail007/goproxy"&gt;GitHub - snail007/goproxy&lt;/a&gt; goProxy是golang实现的高性能http,https,websocket,tcp,防污染DNS,socks5代理服务器,支持内网穿透,链式代理,通讯加密,智能HTTP,SOCKS5代理,域名黑白名单,跨平台,KCP协议支持,集成外部API。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新闻资讯：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;推荐一下我这周从阮老师那里看到的文章，&lt;a href="http://www.ruanyifeng.com/blog/2018/08/api-below.html"&gt;API 之下&lt;/a&gt;。乍看之下似乎是讲软件的，但是其实是猜测未来 AI 普及后财富分配的一个可能的后果，非常有见解。&lt;/li&gt;
&lt;/ol&gt;</content:encoded><guid>http://blog.shrp.me//2018-08-19.html</guid></item><item><title>JAVA线程和 IO 的同步异步，阻塞非阻塞的个人理解</title><link>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</link><pubdate>2018-08-19</pubdate><content:encoded>&lt;p&gt;最近在工作中跟同事讨论起了一个调用是否算是非阻塞、异步时，居然发现我们对同一段代码的定性是不一样的，于是就想写一篇文章把这个问题琢磨琢磨。由于这里涉及很多专有名词的含义，因此就先从字典开始研究。&lt;/p&gt;

&lt;h2 id=""&gt;名词字典&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;同步阻塞 IO——内核态阻塞 IO。这种 IO 模型的工作方式是这样的：用户空间的进程发起一个系统调用，这导致了用户空间的这个进程被阻塞，无法执行任何进程上的其它代码，直到系统调用返回。&lt;/li&gt;
&lt;li&gt;同步非阻塞 IO——内核态非阻塞 IO。这种 IO 的工作方式是这样的：用户空间的进程发起一个系统调用，进程并不会被阻塞，而是回到用户空间继续执行，但是会时不时通过系统调用回到内核检查之前的调用是否结束。如果没有结束，则返回用户空间继续执行，并且很快再次通过系统调用去检查结果，直到结果被返回。&lt;/li&gt;
&lt;li&gt;异步 IO——用户态 IO。这种 IO 的工作方式是这样的：用户空间的进程发起系统调用，进程不阻塞立刻回到用户空间继续执行，也不需要回到内核检查结果，而是内核在结果准备好后复制给用户进程，再通知进程数据已经准备好了。这样用户进程不需要到内核中进行 IO 操作，虽然真正的 IO 仍然是内核完成的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（如果对上述文字难以理解，可以参考&lt;a href="https://www.jianshu.com/p/486b0965c296"&gt;聊聊Linux 五种IO模型 - 简书&lt;/a&gt;这篇文章）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同步请求——调用方主动获取被调方的结果&lt;/li&gt;
&lt;li&gt;异步请求——调用方被动收到被调方的通知&lt;/li&gt;
&lt;li&gt;Java线程阻塞状态——blocked&lt;/li&gt;
&lt;li&gt;Java线程等待状态——waiting，timed waiting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于 Java 线程的状态，可以参考下图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/n2U3N.png" alt="" title=""&gt;&lt;/p&gt;

&lt;h2 id=""&gt;我们到底在说的是哪个概念？&lt;/h2&gt;

&lt;p&gt;一般当我们在说同步异步，阻塞非阻塞的时候，我们说的到底是哪个概念呢？&lt;/p&gt;

&lt;p&gt;是系统内核 IO 类型吗？如果这样的话，根本是没有异步阻塞的说法的，因为 IO 只有异步模型，按照异步模型的行为，是不阻塞进程执行的。&lt;/p&gt;

&lt;p&gt;那么我们是在说字典里的4567这四条解释吗？看起来好像是的，当我们说同步请求的时候，确实是在等执行结束后才能得到结果，主动赋值给一个变量；异步请求的时候，通过 callback 或者 listener 调用回来修改数据 ；当我们说阻塞的时候，Java 线程的状态是……哎？Java 线程的状态可不是只有阻塞（blocked）一个这么简单，而是还有 Waiting、Timed Waiting 状态，表示线程没有继续执行，在等待条件成熟的手变成 Runable 或者 Blocked。难道这种情况算是非阻塞？&lt;/p&gt;

&lt;p&gt;原来，当我们说一个函数阻塞非阻塞的时候，并不是在按照上述的定义去解释的，而是按照线程执行的角度去解释的。也就是说，如果函数调用的时候线程在继续执行逻辑，就是非阻塞的；如果在等待调用结束不继续执行，就是阻塞的。也就是说，第六条和第七条都算是阻塞的。&lt;/p&gt;

&lt;h2 id=""&gt;为什么我们要按照这个定义去理解？&lt;/h2&gt;

&lt;p&gt;有人可能觉得不服气，怎么就不能按照执行过程中的 IO 类型来划分？
我是这么理解的：一个编程概念的提出，是有它的语境的。比如 IO 模型，很确定是发生在IO 时的事情，而我们讨论一个函数的同步异步，阻塞非阻塞，是为了研究这次函数调用对我的程序执行顺序的影响，而非其中的某次 IO，因为这次 IO 的类型不会影响我怎么写代码，这种类型差异在封装过程中就已经抹平了。在我看来，同步就是函数返回值，异步就是回调函数，阻塞就是不执行结束不继续执行后边的逻辑，非阻塞就是不等结果继续执行。这样的定义才能让使用函数的人不用看源码就能继续放心的开发下去。&lt;/p&gt;

&lt;h2 id=""&gt;可以举个例子吗？&lt;/h2&gt;

&lt;p&gt;嗯，光是在理论逻辑上去论证是很枯燥又难以理解的，不如我们看点例子吧。&lt;/p&gt;

&lt;p&gt;首先看一个最简单的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    public static Result test() throws ExecutionException, InterruptedException {
        final ExecutorService executorService = Executors.newFixedThreadPool(1);
        final Result result = new Result();
        final Future&amp;lt;String&amp;gt; submit = executorService.submit(() -&amp;gt; {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "test";
        });
        result.done = true;
        result.text = submit.get();
        executorService.shutdown();
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test函数是同步还是异步，阻塞还是非阻塞呢？有朋友看到这里有线程池，执行的结果是交由另一个线程来处理的，所以理所当然的认为是异步的；由于执行过程会被 &lt;code&gt;submit.get()&lt;/code&gt;所阻塞，所以是阻塞的。可是在我看来，这个函数你会起名为 asyncTest 吗？不会的。虽然&lt;code&gt;executorService.submit&lt;/code&gt;确实是异步执行，但是这个函数内还对 future 进行了 get 操作，使得整个函数结束后返回完整的应答，变成了同步的。因此这个函数可以说是同步阻塞的。&lt;/p&gt;

&lt;p&gt;再看一个的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;import java.util.concurrent.*;

public class Test {
    public static class Result{
        volatile boolean done = false;
        volatile String text;
    }
    final static ExecutorService executorService = Executors.newFixedThreadPool(1);
    public static Result test(){
        final Result result = new Result();
        executorService.execute(() -&amp;gt;{
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result.done = true;
            result.text = "test";
        });
        return result;
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        final Result test = test();
        System.out.println("doing sth in main");
        while (!test.done);
        System.out.println(test.text);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个test 函数的声明看起来就是个普通函数，但是需要等 done 结束才能使用。这是同步的还是异步的呢？我认为这算是异步的，因为需要等待 done 被通知修改后才能完成整改逻辑。由于可以 doing sth in main，这个是异步非阻塞的。如果把 done 改成传入的一个回调函数，就更容易被确认为异步了；我认为这两个行为是没有差别的，因为远离都是提交出去的任务通过通知的方式给到了原有线程。&lt;/p&gt;

&lt;p&gt;啊，既然这么说来，如果想变成异步阻塞怎么办呢？就在 test 函数中阻塞一下，比如 join 提交的任务，这不就是传说中的异步阻塞了嘛。只是异步阻塞的编程大多数情况下没必要写，因为都已经阻塞了，异步跟同步对于原有线程的代码执行顺序都没有任何区别了，无非是主动发请求还是收通知。异步的写法比同步写法麻烦多了，也就不太需要异步阻塞了。我能想到一种异步阻塞的情况，就是提交的任务会周期性的执行，也就是不只一次通知原有线程，比如配置文件的 watch就是类似的情况，会写成&lt;code&gt;Config.watch(filename,listener)&lt;/code&gt;,在程序初始化的过程中，必须先执行 listener，得到配置文件内容才能继续初始化；初始化后，如果有人改了配置文件，listener 会被再一次触发，从而改变程序的行为。&lt;/p&gt;

&lt;p&gt;再来看一个例子，来自ConcurrentLinkedQueue：&lt;/p&gt;

&lt;pre&gt;&lt;code class="java"&gt;public boolean offer(E e) {
        checkNotNull(e);
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

        for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
            Node&amp;lt;E&amp;gt; q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数在执行过程中的亮点在于 &lt;code&gt;p.casNext(null, newNode)&lt;/code&gt; 和 &lt;code&gt;casTail(t, newNode)&lt;/code&gt;，两个 CAS 操作不阻塞，又完成了并发条件下的 offer 函数，整个函数是同步的，又没有阻塞，因此是同步非阻塞。&lt;/p&gt;

&lt;h2 id=""&gt;总结&lt;/h2&gt;

&lt;p&gt;其实很多时候不同的看法是因为我们的定义不同。如果同步和异步是指通信方式，阻塞非阻塞是指线程执行与否，那么我们就可以顺利得到示例里的结论；如果指的是 Linux IO 模型，那么显然我示例都是与之无关的。&lt;/p&gt;

&lt;p&gt;但是不管怎样，只要你能够根据你使用的定义去理解程序的行为方式，并写出正确的调用代码，我想这才是最重要的。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//personal-understanding-of-async-and-blocking.html</guid></item><item><title>搬瓦工免费换 ip</title><link>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</link><pubdate>2018-06-26</pubdate><content:encoded>&lt;p&gt;前两天我的搬瓦工突然被封禁了，一大票技术网站无法访问，实在不方便。登录搬瓦工想找地方换 IP，发现这个基础款的产品自己不支持换 IP 换机房。正在想实在不行就得还供应商的时候，突然搜到搬瓦工针对此情况专门提供了免费更换 IP 的功能，每十周换一次，还是挺爽的。&lt;/p&gt;

&lt;p&gt;这个功能就是当你确信你的机器被墙了，可以访问&lt;a href="https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck"&gt;https://kiwivm.64clouds.com/main-exec.php?mode=blacklistcheck&lt;/a&gt;，此时会提示检测 ip，&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/Xnip2018-06-26_12-01-04.jpg" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;然后点击 Test Main IP，如果检测到被封禁，就会出现 next 按钮，自然点击 next 按钮更换 IP 就好啦。&lt;/p&gt;

&lt;p&gt;不过由于 IP 变化了，需要运行以下命令更新 iptables 记录：
&lt;code&gt;iptables -F; iptables -t nat -F; iptables-save &amp;gt; /etc/sysconfig/iptables&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后别忘记去域名管理把你服务器的域名 A 记录换掉哦！要不然域名还是无法访问的！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//change-ip-freely-on-bandwagon.html</guid></item><item><title>一个USB-C的时代</title><link>http://blog.shrp.me//An-Era-of-USB-Type-C.html</link><pubdate>2018-06-15</pubdate><content:encoded>&lt;p&gt;最近为了配合在家用电脑的显示器需求，买了一台联想的ThinkVision显示器——&lt;a href="https://item.jd.com/4702716.html"&gt;联想（ThinkVision）T27h 27英寸窄边框 &lt;/a&gt;，用了几天，颇有些感想。&lt;/p&gt;

&lt;p&gt;首先，这货有一个坏点。显然联想在显示器的品控并不太好，而且国家的政策里坏点是允许的，而且越大的屏幕坏点允许就越多。当然我可以按照京东7天无条件去退换，可是这款显示器推出快一年了，按照系统显示，它的库存不多了，按照二手东的情况，可能剩下的多少有点问题。这款是我唯一能够找到价格比较低，带有USB-Hub功能的USB-C可充电可旋转显示器了（其实还有一款三星的，但是为了老回，必须不买三星的）。还好的是一个坏点并不是太大的问题，如果你观察你自己的显示器，其实上边落满了灰尘，一个坏点的影响就像是一粒灰尘，并不太影响。事实上，当你打开游戏，打开电影的时候，这个坏点根本就看不到。所以这次为二手东接了盘，感觉也还可以接受。&lt;/p&gt;

&lt;p&gt;虽然显示器有个坏点，但是功能上来说，它真的非常适合我的情况。我目前手里有三套设备，一个台式机，一个新版MacBook Pro，一台GPD pocket。台式机是没有USB-Type C的接口的，视频走HDMI接口；但是苹果本和pocket都是支持Type C接口的。我的电脑桌桌面空间很紧凑，键鼠当然只能有一套，如何用这一套键鼠控制三台电脑，关键只能是怎么利用显示器的USB-Hub功能了。&lt;/p&gt;

&lt;p&gt;然而显示器的USB-Hub是Type-C接口是host，四个普通USB接口去接键鼠。这个原理就像是那些Type-C的转接器一样，只不过转接器的视频输出直接接入显示器的视频输入了而已。那么Pocket和苹果本天然就应该支持边充电边视频输出，并且接到显示器的键鼠也可以用。结果我试了一下，不论是用苹果还是绿联买的一根充电线，还是显示器自带的Type-C线，都只能让苹果本使用，Pocket只能充电，不能显示视频，也无法实现USB-Hub。不过我插上了一款&lt;a href="https://item.jd.com/10391831021.html"&gt;绿联的0.5米长的线&lt;/a&gt;时，奇迹发生了，Pocket也能边充电边显示视频，还能使用接入的键鼠了。Perfect！&lt;/p&gt;

&lt;p&gt;不过还有一个麻烦，就是台式机怎么接入呢？台式机没有Type-C接口，没法直接使用。最简单的方法是电脑用一根Type-C的数据线（一头是Type-A的公头，另一头是Type-C的公头）我之前设想的是买一款Type-C的延长线（一公头一母头）接到显示器，一根USB Type-A公头转USB Type-C公头的普通数据线来连接。当用台式机的时候，就是&lt;code&gt;台式机--A转C数据线--延长线--显示器&lt;/code&gt;；当用苹果本的时候，就是&lt;code&gt;苹果本--C双公头的数据线--延长线--显示器&lt;/code&gt;。结果这个方案失败了：延长线是有逻辑的，公头是host，母头是client。但是在我的设计里，延长线的母头被用来连接host电脑了，公头插到显示器上，跟设计的方向是反的，现在只能充电显示，USB-HUB功能不能用，三个设备都不能。不过我又心生一计，电脑上用一个USB Type-A公头转USB-Type-C母头的转换器，再连到显示器，是不是就可以把显示器当成是USB-Hub了呢？这个情况下的连接是&lt;code&gt;电脑--公A转母C--C双公头的数据线--显示器&lt;/code&gt;，跟苹果本切换的时候只要把“双公头的数据线”连到公A转母C就可以了啊。这个方案理论上可行，赶紧去京东下单买转接头了，大概明天才能验证。&lt;/p&gt;

&lt;p&gt;不过不管验证情况怎么说，Type-C开始在电脑和手机上引领的接口风暴，怕是会越来越激烈了。对于用户来说，一个统一的接口价值相当的重要。恐怕只有等无线连接到来的时候，Type-C才会被淘汰了吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//An-Era-of-USB-Type-C.html</guid></item><item><title>联通IPTV诺基亚贝尔机顶盒怎么安装第三方应用</title><link>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</link><pubdate>2018-04-06</pubdate><content:encoded>&lt;p&gt;由于旧的IPTV盒子坏了，今天抽空去联通换了个IPTV，是上海诺基亚贝尔的S-010W-AV2B机器。拿回来以后IPTV功能都正常，但是一个安卓机顶盒不装点其他应用，那多浪费啊。没想到U盘插上去，傻眼了：apk都不显示，这可咋安装啊？&lt;/p&gt;

&lt;p&gt;一般来说这个方法应该有很多种，比如同一网络下用悟空遥控去推送，比如用USB线连到电脑上安装，比如连上键盘，按快捷键打开网页下载apk。可是一一试过以后发现都不能用，adb没有开，快捷键也被关闭了。&lt;/p&gt;

&lt;p&gt;正手足无措的时候，发现系统点击官方的应用商城居然会下载一个apk安装。嗯？如果我劫持url，下载一个贝当市场，问题不就迎刃而解了吗？&lt;/p&gt;

&lt;p&gt;具体步骤如下：
1、找了个电脑，设置网络共享。我家的IPTV方案是机顶盒通过光猫的wifi上网的，那么我的网络共享就是电脑连光猫的wifi，把网络共享给自己的网线，通过网线连接到IPTV机顶盒。&lt;/p&gt;

&lt;p&gt;2、装上wireshark抓包&lt;/p&gt;

&lt;p&gt;3、在机顶盒点击联通自己的应用商城，成功在wireshark里抓到了http请求地址：http://210.13.0.175:7084/launcher/data/1522120317/CUTV_DSMClient_V4.5.apk&lt;/p&gt;

&lt;p&gt;4、在自己电脑上架设一个网站（要监听所有的设备哦），在相应的地址，相同的文件名放一个贝当应用商店的apk。但是ip地址怎么办？别担心，我在电脑上添加了一个虚拟网卡，地址设置为静态的210.13.0.175，这样请求上来的时候自动就被路由到自己的这个网卡上了。如果你的自建站点按照我的提示监听了电脑所有的网卡，那么这个时候通过你电脑访问的下载请求都会被指向自己的假冒apk了。&lt;/p&gt;

&lt;p&gt;5、把机顶盒的商店卸载掉，再点击安装，很快进度条就走完了，只不过99%的时候提示验证错误，大概是安装后有个验证流程，还需要劫持后修改下，不过不要紧，就算不修改，apk已经安装好了。&lt;/p&gt;

&lt;p&gt;6、最后记得把自己的电脑的网络共享关掉，机顶盒连到正常的网络下下载你想要的apk吧。需要看IPTV的时候，把机顶盒连到光猫的IPTV的wifi下，就可以正常看IPTV了；需要看网络电视的时候，就连到普通wifi下看第三方apk的视频啦。&lt;/p&gt;

&lt;p&gt;最后强调一下，每个人的机顶盒访问的地址不一定一样，因此你一定要自己抓个包，才可能有效。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//How-to-install-APK-in-Unicom-IPTV.html</guid></item><item><title>HG220GS-U改桥接模式</title><link>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</link><pubdate>2018-04-05</pubdate><content:encoded>&lt;p&gt;前两天联通宽带续费升级，原来的百兆猫要换成千兆猫，新猫型号是HG220GS-U.我自己有需要把光猫后的路由器映射到公网去,因此一般都会做dmz或者端口映射.联通原来的猫就有bug,dmz设置不生效,必须要挨个做端口映射;这个新猫更过分,dmz和端口映射均不生效.还好在网上搜到老周的一篇教程&lt;a href="http://guanggai.org/thread-459-1-1.html"&gt;烽火HG220G-U E00L2.03M2000光猫改桥接教程&lt;/a&gt;,解决了问题.&lt;/p&gt;

&lt;p&gt;原文里也有点小问题,telnet节点不必打开,后续操作也用不上telnet,而且telnet一旦打开,从外网也可以telnet到的,用户名admin,密码admin,只怕没几分钟就已经被攻陷了.其他操作均与原文相同.&lt;/p&gt;

&lt;p&gt;为了防止原链接失效,简单讲过程记在下边:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;登录光猫管理页面&lt;a href="http://192.168.1.1/"&gt;http://192.168.1.1/&lt;/a&gt;,默认用户名user,密码在光猫背后.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;登录后访问&lt;a href="http://192.168.1.1/backupsettings.conf"&gt;http://192.168.1.1/backupsettings.conf&lt;/a&gt;,将现有的配置文件保存并且备份,不管什么时候都能轻易恢复原有配置了&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用notepad++或者sublime编辑一个配置文件的副本,先找到&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括IPTV的那个配置,北京联通通常出现在&amp;lt;WANConnectionDevice instance="4"&amp;gt;下,可以看到该配置的X_BROADCOM_COM_IfName的属性是epon0.4.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;再找到上网的配置,也就是&amp;lt;Name&amp;gt;&amp;lt;/Name&amp;gt;之间包括INTERNET的那个配置,通常是&amp;lt;WANConnectionDevice instance="2"&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除该配置节点内的删除&amp;lt;IdleDisconnectTime&amp;gt;120&amp;lt;/IdleDisconnectTime&amp;gt;一整行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改该配置节点内的ConnectionType属性,从IP_Routed改为PPPoE_Bridged.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的名字从2_INTERNET_R_VID_3961改成2_INTERNET_B_VID_3961(也就是R改成了B),这个改动不知道是否必须&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该配置节点的X_BROADCOM_COM_IfName属性从ppp0.2改成epon0.2&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在该配置节点X_BROADCOM_COM_IfName后新增节点&amp;lt;X_CU_IPMode&amp;gt;3&amp;lt;/X_CU_IPMode&amp;gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href="http://192.168.1.1/updatesettings.html"&gt;http://192.168.1.1/updatesettings.html&lt;/a&gt;,选择上传配置,然后路由会自动重启,重启后就是桥接模式了,需要光猫后边的路由器或者电脑自己拨号才能上网了.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PS:旧版的HG220GS是可以通过网址&lt;a href="http://192.168.1.1/logoffaccount.html"&gt;http://192.168.1.1/logoffaccount.html&lt;/a&gt;打开隐藏账户的,然后就可以通过&lt;a href="http://192.168.1.1/cu.html"&gt;http://192.168.1.1/cu.html&lt;/a&gt;登录管理员账户,用户名CUAdmin,密码123qweasdzxc.但是我的这个网页是不能访问的.隐藏账户登录后可以关闭端口扫描的防御来打开DMZ和端口映射功能.&lt;/p&gt;

&lt;p&gt;但是又有人说这种情况可以通过&lt;a href="http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1"&gt;http://192.168.1.1/logoffaccount.cmd?enableFactoryAccount=1&lt;/a&gt;访问来开启隐藏账户,这个我就没有尝试了,大家可以自行尝试.&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//HG220GS-U-Change-To-Bridge.html</guid></item><item><title>程序员工作用什么操作系统？</title><link>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</link><pubdate>2018-03-10</pubdate><content:encoded>&lt;h1 id=""&gt;程序员工作用什么操作系统？&lt;/h1&gt;

&lt;p&gt;　　今天偶然看到之前关注的 vpsee 网站一篇09年的文章(&lt;a href="https://www.vpsee.com/2009/06/why-programmers-love-mac/"&gt;为什么国外程序员爱用 Mac？ | vpsee.com&lt;/a&gt;)在讨论为什么程序员喜欢用 Mac，文章后洋洋洒洒数百个评论或激昂，或讽刺，或诅咒，或炫耀，好不热闹。恰好最近一个.Net 开发同事想用 Mac 开发 Java 程序，一个 Java 开发 同事想把自己的 Mac 换成 Windows，真是有意思。于是我也按耐不住，想要说点什么。&lt;/p&gt;

&lt;p&gt;　　开始前我想先声明一下，如果说有人说这个话题没有偏颇，我真不太相信。每个人连颜色都有自己的偏好，操作系统这么复杂而又常用的东西如果没有喜好那也太大条了。我当然也不例外。就目前而言，我作为一个开发，是用 Mac 多一些，也喜欢用 Mac；但是我并不觉得每个程序员都用，或者每个程序员都喜欢用 Mac 是正常的，正相反，我觉得最多只有一半喜欢或者应该用 Mac来从事开发工作。&lt;/p&gt;

&lt;p&gt;　　先说 Windwos。Windows 借中国早先盗版的问题最先在群众中普及，我也不例外，从98年家里的第一台电脑开始就在用 Windows。这个系统我们用得多了，也就耳熟能详怎么去把玩到极致：从 DOS 时代在启动文件里调整虚拟内存，到9x 的简繁转换，再到 NT 内核系统的服务优化，再到 Windows10 的免费升级。应用怎么查杀，注册表的大体结构，游戏使用的 direct 技术和安装方法，不论是写代码，玩游戏，还是看电影听音乐，基本是无所不能。更不要说.NET 程序员了，目前来说只在 Windows 工作。甚至包括怎么分区，多久备份一次，怎么快速备份恢复，一个老 Windows 程序员估计都有自己的方案，以免在升级失败，电脑蓝屏时还不用耽误太久工作。尽管这些技能都跟程序开发没有直接关系，却能帮助我们尽快解决手头的问题，把精力集中在开发上。然而并不是程序员都是.NET 程序员，Windows 也不是100%契合所有开发人员的需求，有些问题会一而再再而三的坑害开发，比如说中文版 Windows 默认的字符编码是 GB2312，而大多数部署到 Linux 的软件都得处理 UTF-8。那么开发在部署的时候经常要注意自己的代码里处理字符集转换，一些文字要提前处理成 UTF-8。而且即便是在 Windows 保存为 UTF-8文件，还会面临另一个问题：BOM 头。在 Windows 上 BOM 一般不会惹什么麻烦，但是当部署到 Linux 服务器的时候，结果就不好说了；ImportNews 网站的 RSS 甚至就带有 BOM 头，而带有 BOM 头的 RSS 是不符合 XML 规范的。一个 Java 专业社区的组件都有这样的 bug，还能指望 Windwos 开发对于 Linux 开发有多友好呢？再比如说 Windows 的目录是分磁盘的，C:\，D:\等等，而且目录的分割用\而不是/。这对一些预计部署在 Linux 的服务的开发带来了负面的影响。再有就是孱弱的命令行环境了，自带的命令稀缺，Linux 的工具链工具几乎不支持，这对于工作面对 Linux 服务器的程序员来说都不是什么好事情。&lt;/p&gt;

&lt;p&gt;　　再说 Linux。我刚开始用 Linux 还是高三的时候，是很经典的小红帽 Red Hat，好像一共6张 CD 光盘。当时就是尝个鲜，装好了以后主要在窗口界面里乱用。后来工作后才真正开始学习怎么去用 Linux，看《鸟哥的 Linux 私房菜》，把服务部署到 Linux 服务器上，但是当时开发还是 Windows。在进行了1年的 跨平台开发后，被字符集坑惨的我开始用最流行的 Ubuntu 来开发程序，当时使用的是 Ubuntu10 LTS。 Ubuntu确实简单易上手，互联网上也充斥着大量使用 Ubuntu 的经验，基本上遇到什么问题都能用搜索引擎得到质量比较高的回答。Linux 跟生产的环境是相当契合的，不太容易出现环境部署的问题。但是 Ubuntu 最大的问题就是官方仓库东西还是不够，必须添加私有源；可是私有源到了后期却或多或少带有的陈旧核心组件，都可能存在不同乃至冲突。有时候甚至为了看 flash，装个 vpn 而安装的某个源带入的依赖跟系统最新的根本不搭，导致后续的更新都不能应用了。解决问题一定是有方法的，但是却需要开发者投入不少的精力去跟踪操作系统里发生了什么冲突，怎么去解决。此后我还用过 cent OS，Mint，Arch，然而大同小异，总是因为系统里安装的什么东西不兼容，从而系统没法完整升级。这种情况一开始可能只是几个包，但是后来不满足依赖的升级越来越多，而且有时候为了某个特定的需要，比如 docker，还不得不升级。这些冲突解决起来痛苦而且耗费时间，因此Linux最适合还是放在服务器里，不出事情几年都想不起升个级的。&lt;/p&gt;

&lt;p&gt;　　至于 Mac 么，真的是我用过最省心的操作系统了。插上移动硬盘就自动备份，不管是换电脑，还是出问题重装系统，都可以在一个小时左右恢复搞定，而且恢复以后打开浏览器，上次没关闭的窗口还热乎着呢。目录符合 unix 风格，程序跑起来没什么毛病。工具链也有，很多脚本都是可以直接用的。用 Mac 开发，既可以不断享受升级，又不会太折腾，可以把精力集中在代码本身。不过 Mac 也不是完全没有问题。就我自己遇到的就有这么几种情况：每次升级都有可能一些安全性的提升导致某些软件用不了；1024以下的端口默认不可以被用户程序占用；命令其实是 BSD 版本的，参数跟 Linux 上的并不一致；默认文件系统不是大小写敏感的，甚至很多软件都不支持在大小写敏感的分区上使用（没想到吧）；并不太可能做到完全不用鼠标，不过用鼠标的次数还是可以比较少的。&lt;/p&gt;

&lt;p&gt;　　在我看来，其实并没有一个最合适的电脑。如果想省心省力，能够集中精力去开发的，也就是 Mac 了，这也是大多数中年程序员的首选，每天除了工作还要肩负养家糊口的重担，没有太多时间去折腾设备，用一款 Mac 可以帮助他们做到这点。如果是刚刚开始工作的程序员，有大把时间去折腾，那选择一款 Linux 长时间使用就比较合适，能够更熟悉自己软件部署的环境，写出的代码就更容易减少出 bug 的可能，如果剩下的软件也能维护好升级和依赖的关系，配置的足够好，免鼠标什么的没问题，开发效率也可以得到提升。至于剩下的程序员，或者要开发 Windows 程序，或者 Windows 非常熟悉，或者对系统差异足够熟悉的，用 Windows 开发并不会给他们带来不便。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Which-OS-Do-Programers-Prefer-At-Work.html</guid></item></channel>
</rss>