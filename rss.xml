<?xml version="1.0" encoding="utf-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
    <channel>
        <title>尚弟的小笔记</title>
        <atom:link href="http://blog.shrp.me//rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://blog.shrp.me/</link>
        <dc:language>zh-cn</dc:language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
    <item><title>好久不更新了，得肺结核了</title><link>http://blog.shrp.me//Too-Long-No-Update-Since-Got-Tuberculosis.html</link><pubdate>2012-03-13</pubdate><content:encoded>&lt;p&gt;　　很久没更新了，最近得了肺结核，一阵检查之类的，现在确诊了，只好从公司出来，好好治病。&lt;/p&gt;

&lt;p&gt;　　正好好好写论文吧，也算是一个休整时期吧。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Too-Long-No-Update-Since-Got-Tuberculosis.html</guid></item><item><title>temp</title><link>http://blog.shrp.me//temp.html</link><pubdate>2016-02-19</pubdate><content:encoded>&lt;pre class=" language-java"&gt;&lt;code class=" language-java"&gt;
&lt;span class="token keyword"&gt;package&lt;/span&gt; com&lt;span class="token punctuation"&gt;.&lt;/span&gt;woqu&lt;span class="token punctuation"&gt;.&lt;/span&gt;crm&lt;span class="token punctuation"&gt;.&lt;/span&gt;server&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;io&lt;span class="token punctuation"&gt;.&lt;/span&gt;UnsupportedEncodingException&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;util&lt;span class="token punctuation"&gt;.&lt;/span&gt;LinkedList&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;import&lt;/span&gt; java&lt;span class="token punctuation"&gt;.&lt;/span&gt;util&lt;span class="token punctuation"&gt;.&lt;/span&gt;List&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token comment" spellcheck="true"&gt;/**
 * Created by shangrenpeng on 16/2/18.
 */&lt;/span&gt;
&lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;class&lt;/span&gt; &lt;span class="token class-name"&gt;PHPUrlDecoder&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token function"&gt;decode&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;String s&lt;span class="token punctuation"&gt;,&lt;/span&gt; String enc&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;throws&lt;/span&gt; UnsupportedEncodingException &lt;span class="token punctuation"&gt;{&lt;/span&gt;

        &lt;span class="token keyword"&gt;int&lt;/span&gt; numChars &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;length&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;LinkedList&lt;/span&gt;&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;&amp;gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;enc&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;length&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;throw&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;UnsupportedEncodingException&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token string"&gt;"URLDecoder: empty string enc parameter"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

        &lt;span class="token keyword"&gt;char&lt;/span&gt; c&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes &lt;span class="token operator"&gt;=&lt;/span&gt; null&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            c &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;charAt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token keyword"&gt;switch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                &lt;span class="token keyword"&gt;case&lt;/span&gt; &lt;span class="token string"&gt;'+'&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                    &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;' '&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                &lt;span class="token keyword"&gt;case&lt;/span&gt; &lt;span class="token string"&gt;'%'&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                &lt;span class="token comment" spellcheck="true"&gt;/*
                 * Starting with this instance of %, process all
                 * consecutive substrings of the form %xy. Each
                 * substring %xy will yield a byte. Convert all
                 * consecutive  bytes obtained this way to whatever
                 * character(s) they represent in the provided
                 * encoding.
                 */&lt;/span&gt;

                    &lt;span class="token keyword"&gt;try&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;!&lt;/span&gt;&lt;span class="token function"&gt;canParse&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s &lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
                            &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

                       &lt;span class="token comment" spellcheck="true"&gt; // (numChars-i)/3 is an upper bound for the number
&lt;/span&gt;                       &lt;span class="token comment" spellcheck="true"&gt; // of remaining bytes
&lt;/span&gt;                        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;bytes &lt;span class="token operator"&gt;==&lt;/span&gt; null&lt;span class="token punctuation"&gt;)&lt;/span&gt;
                            bytes &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;numChars&lt;span class="token operator"&gt;-&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;/3&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token keyword"&gt;int&lt;/span&gt; pos &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

                        &lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;i&lt;span class="token number"&gt;+2&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                                &lt;span class="token punctuation"&gt;(&lt;/span&gt;c&lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token string"&gt;'%'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;

                            &lt;span class="token keyword"&gt;int&lt;/span&gt; v &lt;span class="token operator"&gt;=&lt;/span&gt; Integer&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;parseInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;substring&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token number"&gt;+1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token number"&gt;+3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;,16&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;
//                            if (v &amp;lt; 0){
&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;//                                throw new IllegalArgumentException("URLDecoder: Illegal hex characters in escape (%) pattern - negative value");
&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;//                            }
&lt;/span&gt;
                            bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;pos&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; v&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            i&lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 3&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                            &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; numChars&lt;span class="token punctuation"&gt;)&lt;/span&gt;
                                c &lt;span class="token operator"&gt;=&lt;/span&gt; s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;charAt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
                        &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;,&lt;/span&gt;pos&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;catch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token class-name"&gt;NumberFormatException&lt;/span&gt; e&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                        &lt;span class="token keyword"&gt;throw&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;IllegalArgumentException&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;
                                &lt;span class="token string"&gt;"URLDecoder: Illegal hex characters in escape (%) pattern - "&lt;/span&gt;
                                        &lt;span class="token operator"&gt;+&lt;/span&gt; e&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getMessage&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                &lt;span class="token keyword"&gt;default&lt;/span&gt;&lt;span class="token operator"&gt;:&lt;/span&gt;
                    &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;sb&lt;span class="token punctuation"&gt;,&lt;/span&gt;String&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;valueOf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;c&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"UTF-8"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    i&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
                    &lt;span class="token keyword"&gt;break&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token punctuation"&gt;}&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;

        &lt;span class="token keyword"&gt;final&lt;/span&gt; Byte&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; ret &lt;span class="token operator"&gt;=&lt;/span&gt; sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;toArray&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;Byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;size&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

        &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token function"&gt;toPrimitive&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;ret&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; EMPTY_BYTE_ARRAY &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token number"&gt;[0&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

    &lt;span class="token keyword"&gt;public&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token function"&gt;toPrimitive&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;Byte&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; array&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;array &lt;span class="token operator"&gt;==&lt;/span&gt; null&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; null&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length &lt;span class="token operator"&gt;==&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; EMPTY_BYTE_ARRAY&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; result &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token keyword"&gt;new&lt;/span&gt; &lt;span class="token class-name"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

            &lt;span class="token keyword"&gt;for&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; array&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token operator"&gt;++&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
                result&lt;span class="token punctuation"&gt;[&lt;/span&gt;i&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; array&lt;span class="token punctuation"&gt;[&lt;/span&gt;i&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;byteValue&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token punctuation"&gt;}&lt;/span&gt;

            &lt;span class="token keyword"&gt;return&lt;/span&gt; result&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; pos&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; j &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; pos&lt;span class="token punctuation"&gt;;&lt;/span&gt; j&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;add&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;j&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;addBytes&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; List&lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt;Byte&amp;gt; sb&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;byte&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt;&lt;span class="token number"&gt; 0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt; j &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; bytes&lt;span class="token punctuation"&gt;.&lt;/span&gt;length&lt;span class="token punctuation"&gt;;&lt;/span&gt; j&lt;span class="token operator"&gt;++&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            sb&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;add&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;bytes&lt;span class="token punctuation"&gt;[&lt;/span&gt;j&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;

    &lt;span class="token keyword"&gt;private&lt;/span&gt; &lt;span class="token keyword"&gt;static&lt;/span&gt; &lt;span class="token keyword"&gt;boolean&lt;/span&gt; &lt;span class="token function"&gt;canParse&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;final&lt;/span&gt; String s&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;final&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
        &lt;span class="token keyword"&gt;try&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;int&lt;/span&gt; v &lt;span class="token operator"&gt;=&lt;/span&gt; Integer&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;parseInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;substring&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;i&lt;span class="token number"&gt;+1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token number"&gt;+3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token number"&gt;,16&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token boolean"&gt;true&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt; &lt;span class="token keyword"&gt;catch&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token class-name"&gt;Exception&lt;/span&gt; e&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token boolean"&gt;false&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;</content:encoded><guid>http://blog.shrp.me//temp.html</guid></item><item><title>无语了……本博客与淘宝商城没有任何联系！！！</title><link>http://blog.shrp.me//This-Blog-Has-Nothing-With-Tmall.html</link><pubdate>2012-01-12</pubdate><content:encoded>&lt;p&gt;　　我已经无语了……淘宝商城在毫无征兆的情况下改用了天猫作为名称，让我一下子不知所措。&lt;/p&gt;

&lt;p&gt;　　我的网站采用天猫是从我大二，也就是2007年底08年初的时候做的第一版就开始了。当时用的是&lt;a href="http://lynx.xinwen365.com"&gt;http://lynx.xinwen365.com&lt;/a&gt;吧，时间太过久远，记不清楚了。是采用iframe分栏的布局，记事本写的代码。后来该空间关闭，我换用花生壳的服务，在本机提供服务，地址&lt;a href="http://nada.eicp.net"&gt;http://nada.eicp.net&lt;/a&gt;。在这个URL上我做过两次升级，分别为第二版（2010年，纯手工静态，3个子站）和第三版（2011年2月纯php）。&lt;/p&gt;

&lt;p&gt;　　现在已经第四版了，采用了php+js+文件管理。在互联网上的只是我的网站的子集，仅包括博客部分，所以后缀了一个Small；在我的本地还提供了SVN、资料分享、媒体分享（主要是我的设备比较多，没有媒体分享就需要把同一个电影来回拷贝，太麻烦）。&lt;/p&gt;

&lt;p&gt;　　经过这么久的时间，我的网站一直采用这个名字，可见我的博客跟淘宝商城毫无关系。不要误会了哟~&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//This-Blog-Has-Nothing-With-Tmall.html</guid></item><item><title>打算在我的eeepc小笔电上边装个puppy</title><link>http://blog.shrp.me//Install-Puppy-Linux-in-My-EEEPC.html</link><pubdate>2011-12-28</pubdate><content:encoded>&lt;p&gt;　　原来我的小笔电EEEPC安装过两个Puppy版本，一个是曾经比较流行的小芭比Linux&lt;a href="http://www.minilinux.net/software/%E5%B0%8F%E8%8A%AD%E6%AF%94"&gt;链接1&lt;/a&gt;，貌似目前已经停止了；另一个是官方原版的lupu-520版本，目前已经是528版本了吧&lt;a href="http://bkhome.org/blog/?viewDetailed=02418"&gt;链接2&lt;/a&gt;。当时试了几种中文输入法，都不成功，改用了搜狗网页版，凑合用着。不过多试几次就没兴趣了。&lt;/p&gt;

&lt;p&gt;　　再后来我的小笔电把win7换回xp的时候把c盘用ghost还原了，puppy自然也就不在了。今天打算再安装回去，正好单位的事情也办的差不多了，随手安装吧，嘿嘿，等这回安装好了再发文总结。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//Install-Puppy-Linux-in-My-EEEPC.html</guid></item><item><title>二分查找法查找中点的方法（C语言）</title><link>http://blog.shrp.me//A-Method-To-Find-Midlle-in-Binary-Search-in-C.html</link><pubdate>2011-12-07</pubdate><content:encoded>&lt;p&gt;　　今天跟同事说起二分查找法中常见的一个问题，就是计算中点时会溢出的问题。&lt;/p&gt;

&lt;p&gt;　　常见的方法（a+b）/2就是铁定会溢出的方法。如果a和b很大，之和超出了它们定义的范围，那么运算结果可能会是负数，这绝对不是我们想要的。&lt;/p&gt;

&lt;p&gt;　　之后同事说他看到一个算法是(a+b)&amp;gt;1。其实这个问题只能说缓解了溢出的问题，实际问题还是存在的。为啥？比如int，当发生上溢的时候，溢出的进位其实进入了符号位；而右移的时候把符号位移到了第一位，此时计算结果是正确的；但是如果是无符号整型，溢出的时候已经丢弃了进位，右移后结果要少差一半。&lt;/p&gt;

&lt;p&gt;　　所以最好还是用a+（b-a）/2这样。除二或者右移一位都是可以的。当然，前提是因为我们知道a和b作为数组下标，都是正数，因此b-a不会下溢。如果你的数组奇怪到居然用负数左下标，呃，好吧，a和b做右移或除2处理再相加吧。不过记得要判断两个都是奇数的情况哦！&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//A-Method-To-Find-Midlle-in-Binary-Search-in-C.html</guid></item><item><title>关于函数指针的一点小研究</title><link>http://blog.shrp.me//something-about-pointer-point-to-method.html</link><pubdate>2011-10-07</pubdate><content:encoded>&lt;p&gt;　　C语言里有个特殊的指针，称为函数指针。这个东西比较可爱的一点是它本身是指向某函数的，可以用它来调用函数。&lt;/p&gt;

&lt;p&gt;　　但是语言上有个说法，是一切未初始化的变量是bug的来源。那么函数指针初始化为什么好呢？&lt;/p&gt;

&lt;p&gt;　　最最直接的想法是NULL。NULL当然没错了，但是它还不够智能，运行的时候闷头来个段错误，让人丈二和尚摸不着头脑，究竟是哪个指针跑飞了呢？&lt;/p&gt;

&lt;p&gt;　　于是我简单的研究了一下。&lt;/p&gt;

&lt;p&gt;　　首先定义了一个函数test：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;test&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"test!\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数很简单，就是在屏幕输出一行文字。&lt;/p&gt;

&lt;p&gt;如果直接定义它的函数指针，那就是&lt;code&gt;void (*point)() = test;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可是咱们说的是把它当做任意函数指针的地址。于是试了一下：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;LynxArrayListInit&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;LynxArrayList &lt;span class="token operator"&gt;*&lt;/span&gt;myArrayList&lt;span class="token punctuation"&gt;,&lt;/span&gt;
                            &lt;span class="token keyword"&gt;long&lt;/span&gt; increaseStep
                           &lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; test&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行，OK！没有问题。&lt;/p&gt;

&lt;p&gt;　　这样可以通过把函数指针初始化为报错的函数，可以调用exit终止掉非法调用，可以记录日志，可以做任何你想要做的事情，甚至忽略错误，让程序飞一会；或者添加第一个参数，记录下其余参数的数量，还可以把所有的参数都记录下来，以供改进。&lt;/p&gt;

&lt;p&gt;　　不过……最好还是通过它重新初始化的好。为啥呢？因为test函数不消耗参数，栈内多了两个参数啊，这些参数都消耗不掉了。总之这对于程序的运行百害无一利，更何况程序指针已经飞了，继续跑基本也不正确了。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//something-about-pointer-point-to-method.html</guid></item><item><title>code::blocks在windows平台如何加载动态链接库dll</title><link>http://blog.shrp.me//codeblocks-dynamically-load-dll-in-windows.html</link><pubdate>2011-09-18</pubdate><content:encoded>&lt;p&gt;　　今天写一个数据结构，突然想到这种东西必然会经常复用，完全可以写个库来供以后调用。然后就研究了下code::blocks下怎么来写库，又怎么去调用。&lt;/p&gt;

&lt;p&gt;　　首先是静态库。这个最为简单，只要选择static library项目新建。写好的库ctrl+F9，就能生成一个.a文件。要调用的时候只要在所需的项目中添加一个链接库，链接到这个.a文件即可。然后在项目中添加相应的.h文件，就像是使用正常的函数一样了。&lt;/p&gt;

&lt;p&gt;　　其次是动态库。动态库略为复杂，不过也不难。首先写库的时候新建的时候选择dynamic link library，写好以后ctrl+f9会生成三个文件（10.05版本如此，好像之前的版本并非如此，还需更改编译选项，在项目属性的构建目标中选中选中红色选项框内的内容&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/1.JPG" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;）。生成的除了dll外，还有一个.a和一个.def文件。.def是给其它语言导入使用的，.a是一个导出库，类似于一个空壳实现。这时在新的项目中只要添加相应的头文件，并且在链接的时候链接到.a文件就行。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/2.JPG" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;　　当然，运行程序的时候，.dll应该在.exe的执行目录中。不要问执行目录和存放目录有什么区别……这个请参照win快捷方式的start in（或者称为启动位置？手头没有中文系统）属性。&lt;/p&gt;

&lt;p&gt;　　不过如果不是cb生成的dll呢？我们只有.dll文件和.h文件，那也没有关系。直接把.dll文件替换上述.a文件，cb会根据dll当做.h的实现的。&lt;/p&gt;

&lt;p&gt;　　如果更进一步，没有.h，只知道几个重要的函数怎么办？那也没关系，用windows.h提供的LoadLibrary函数就可以了。具体可以查看下说明。&lt;/p&gt;

&lt;p&gt;　　下边我提供代码作为一个示例：&lt;/p&gt;

&lt;p&gt;　　首先创建一个实验的动态链接库，比如我这里的LynxArrayList。 &lt;img src="http://stirp.github.io/img/lynxarrylist.png" alt="" title=""&gt;其中的main.c如下：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token comment" spellcheck="true"&gt;/** @brief 简单的相加
*
* @param 第一个加数
* @param 第二个加数
* @return 返回相加的和
*
*/&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;SampleAddInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i1&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i2&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; i1 &lt;span class="token operator"&gt;+&lt;/span&gt; i2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;version.h就不用看了，那个是自动更新版本号的。&lt;/p&gt;

&lt;p&gt;然后更改为release，ctrl+F9，查看release目录下边生成了3个文件。然后删除除dll以外的文件（其实删不删都一样）。&lt;/p&gt;

&lt;p&gt;新建一个普通的console application，在构造选项的链接器设置中添加刚才的.dll文件。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://stirp.github.io/img/lynxtest.png" alt="" title=""&gt;&lt;/p&gt;

&lt;p&gt;之后在代码中声明SampleAddInt函数就行：&lt;/p&gt;

&lt;p&gt;LynxArrayList.h文件：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token property"&gt;#ifndef LYNXARRAYLIST_H_INCLUDED&lt;/span&gt;
&lt;span class="token property"&gt;#define LYNXARRAYLIST_H_INCLUDED&lt;/span&gt;
&lt;span class="token property"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="token keyword"&gt;extern&lt;/span&gt; &lt;span class="token string"&gt;"C"&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;
#endif
&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;SampleAddInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i1&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i2&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token property"&gt;#ifdef __cplusplus&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
#endif
#endif&lt;span class="token comment" spellcheck="true"&gt; // LYNXARRAYLIST_H_INCLUDED
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在main函数中include这个头文件，就可以使用SampleAddInt函数了。下边的主函数代码还示范了如何使用windows.h来动态加载dll，可以合理掌握dll的加载和释放时间，更加合理一些。&lt;/p&gt;

&lt;p&gt;main.c文件：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token property"&gt;#include &lt;span class="token property"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="token property"&gt;#include &lt;span class="token property"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="token property"&gt;#include &lt;span class="token property"&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="token property"&gt;#include &lt;/span&gt;&lt;span class="token string"&gt;"LynxArrayList.h"&lt;/span&gt;
&lt;span class="token comment" spellcheck="true"&gt;/** @brief 主函数
*
* @return int
*
*/&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;main&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    HINSTANCE hinstDLL&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;myfunc&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    hinstDLL &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;LoadLibrary&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"libLynxArrayList.dll"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;hinstDLL &lt;span class="token operator"&gt;!=&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
        myfunc &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token function"&gt;GetProcAddress&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;hinstDLL&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;"SampleAddInt"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token punctuation"&gt;}&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token function"&gt;myfunc&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token number"&gt;2&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token function"&gt;FreeLibrary&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;hinstDLL&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token function"&gt;SampleAddInt&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token number"&gt;2&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token number"&gt;3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;</content:encoded><guid>http://blog.shrp.me//codeblocks-dynamically-load-dll-in-windows.html</guid></item><item><title>http client 对于优酷和土豆的api调用</title><link>http://blog.shrp.me//using-http-client-for-api-of-youku-and-tudou.html</link><pubdate>2011-05-16</pubdate><content:encoded>&lt;p&gt;今天下午研究了一下午的土豆api调用，心得如下：&lt;/p&gt;

&lt;p&gt;优酷api返回结果是text/html，可以直接使用httpentity的getcontent方法，并且通过其getcontentlength方法不为-1，得知返回结果是否有效。&lt;/p&gt;

&lt;p&gt;土豆返回结果是text/plain，必须使用&lt;/p&gt;

&lt;pre class=" language-java"&gt;&lt;code class=" language-java"&gt;HttpEntity entity &lt;span class="token operator"&gt;=&lt;/span&gt; response&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token function"&gt;getEntity&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过HttpEntity#getContent()绑定到bytearrayinputstream，然后再tostring转为字符串保存使用。&lt;/p&gt;

&lt;p&gt;两者都是json结果，用jsondecode就得到了视频的详细信息了&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//using-http-client-for-api-of-youku-and-tudou.html</guid></item><item><title>一个设想的创业点</title><link>http://blog.shrp.me//A-Creation-of-Thinking.html</link><pubdate>2011-05-07</pubdate><content:encoded>&lt;p&gt;　　可以用触摸屏替换触摸板。&lt;/p&gt;

&lt;p&gt;　　首先写一个iPhone程序和xp程序，让iPhone作为xp的多点触摸设备。&lt;/p&gt;

&lt;p&gt;　　然后宣传这个理念，然后把公司并入硬件生产厂商，比如神舟，联想。触摸屏可以实现不开机的邮件、聊天，可以实现xp的程序快速启动等好处。还可以让它自己本身可以自由拆卸作为mp4使用。&lt;/p&gt;</content:encoded><guid>http://blog.shrp.me//A-Creation-of-Thinking.html</guid></item><item><title>重新学习C的领悟</title><link>http://blog.shrp.me//Understanding-Of-Restudy-C.html</link><pubdate>2011-04-25</pubdate><content:encoded>&lt;h4 id="1scanfcchr"&gt;1. 为了跳过之前的回车，可以使用&lt;code&gt;scanf(“空格%c”,&amp;amp;chr);&lt;/code&gt;，其中的空格可以跳过零个或者若干个空白字符，包括换行、换页、行制表符、列制表符、空格&lt;/h4&gt;

&lt;h4 id="22fg"&gt;2. 为了打印出小数点后两位数字，"%.2f"来输出。为了打印出自然书写格式的的浮点数字，可以用%g。&lt;/h4&gt;

&lt;h4 id="3001770x0x7fffintlu"&gt;3. 整型常量：八进制和十六进制没有负数常量。书写为：八进制：0开头，如0177；十六进制：0x开头，如0x7fff。默认属于int型，可以在后边添加L、U表示长整型、无符号型。为了输出负数八进制或十六进制，可以用下列方法：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt; i &lt;span class="token operator"&gt;&amp;lt;&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"-%x"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;-&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%x"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="4fllongdoubledoublelfflongdoublelf"&gt;4. 浮点型常量：默认以双精度浮点形式存储。后缀F、L表示单精度浮点型或者long double型。在读取double型时用%lf，输出时%f；读取或者输出long double型时用%Lf。&lt;/h4&gt;

&lt;h4 id="533033escx1bx"&gt;5. 转义序列：连续的??要用\?来输出问号，否则会认为是三字符序列。八进制转义序列用\33或者\033表示ESC；十六进制转义序列用\x1B。x必须小写。&lt;/h4&gt;

&lt;h4 id="6charsignedunsigned128"&gt;6. 如果用char来存储较小的整型时，必须用signed或者unsigned来声明是否带有符号位。（否则会在自动扩展时出现问题，比如大于128的数字变成负数）&lt;/h4&gt;

&lt;h4 id="7"&gt;7.&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;getchar&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;!=&lt;/span&gt; &lt;span class="token string"&gt;'\n'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;/*来跳过一行的输入*/&lt;/span&gt;

&lt;span class="token keyword"&gt;while&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;getchar&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token string"&gt;' '&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;/*来跳过空格的输入*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scanf()后边如果再使用getchar时要注意，scanf后边输入的\n是会被getchar所读取的，一般是所不希望的。&lt;/p&gt;

&lt;h4 id="8sizeofsizeof"&gt;8. sizeof()运算符一定要将所求目标用括号选中，否则容易出错。（sizeof运算符的优先等级高于二元运算符）。另一方面，返回值为无符号整型，容易在赋值到整型时溢出。&lt;/h4&gt;

&lt;h4 id="910unsignedint10"&gt;9. 同样，-10&amp;lt;(unsigned int) 10的结果是假。&lt;/h4&gt;

&lt;h4 id="10"&gt;10. 运算时溢出，即便结果是由更大范围的类型来保存依然会溢出。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;long&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; j &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token number"&gt;1000&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
i &lt;span class="token operator"&gt;=&lt;/span&gt; j &lt;span class="token operator"&gt;*&lt;/span&gt; j&lt;span class="token comment" spellcheck="true"&gt;;//先溢出，再转换类型
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="11100"&gt;11. 使用数组的时候一定要避免从1开始。能从0开始就一定要从0开始，否则容易产生难以察觉的错误。&lt;/h4&gt;

&lt;h4 id="12aibib1a2"&gt;12. 数组下标使用++等带有作用的运算时要小心。如a[i] = b[i++]在不同电脑的实现是不同的，可能会成为b[1] = a[2]。&lt;/h4&gt;

&lt;h4 id="13memcpyabsizeofastringh"&gt;13. 数组间的赋值：&lt;code&gt;memcpy(a, b, sizeof(a));&lt;/code&gt;它比循环速度快。来自&lt;string.h&gt;。&lt;/string.h&gt;&lt;/h4&gt;

&lt;h4 id="14"&gt;14. 函数不能返回数组。&lt;/h4&gt;

&lt;h4 id="15unsignedlongint"&gt;15. 如果函数返回的类型非常长（如unsigned long int），那么有必要把返回类型单独放在一行&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;unsigned&lt;/span&gt; &lt;span class="token keyword"&gt;long&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt;
&lt;span class="token function"&gt;average&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;float&lt;/span&gt; a&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;float&lt;/span&gt; b&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt; a &lt;span class="token operator"&gt;+&lt;/span&gt; b&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;/&lt;/span&gt; &lt;span class="token number"&gt;2&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="16voidprintfhimmmmn"&gt;16. 在有返回值的函数需要丢弃返回值时，可以强制转换来明确表示丢弃，比如&lt;code&gt;(void) printf(”Hi,MMMM……\n“);&lt;/code&gt;来表示丢弃返回值。&lt;/h4&gt;

&lt;h4 id="17voidreturn"&gt;17. 在void 引导的函数中可以用&lt;code&gt;return;&lt;/code&gt;来随时退出函数。&lt;/h4&gt;

&lt;h4 id="18"&gt;18. 每个函数定义前都要有盒型注释，要求给出函数名、函数的目的、讨论每个形式参数的含义、描述返回值和罗列任何的副作用。（如会改变某个参数等）&lt;/h4&gt;

&lt;h4 id="19constconstvoidfconstintppvoidfintconstpppvoidfconstintconstpconstvoidfintaa"&gt;19. 函数中用const来保护不需要修改的参数。在指针、数组类型中使用const要注意，如&lt;code&gt;void f(const int *p)&lt;/code&gt;表示p所指向的数字不能改变。如果是&lt;code&gt;void f(int * const p)&lt;/code&gt;则表示p指向的数字可以改变，但是p不可以改变。可以出现void f(const int * const p)来表示指针和指针指向的数字都不可变。如果不用const，即便是void f(int a[])中a也相当于指针，也可以改变的。&lt;/h4&gt;

&lt;h4 id="20pa10p5a5"&gt;20. 指针可以当作数组名使用。如&lt;code&gt;*p = a[10]&lt;/code&gt;,则p[5] 等价于 a[5]；&lt;/h4&gt;

&lt;h4 id="21a1010aa"&gt;21. 多维数组名作为指针时要小心。如a[10][10]中a相当于 **a。&lt;/h4&gt;

&lt;h4 id="22inta10i5aiiaaaa"&gt;22. Int a[10],i = 5；使用时a[i]和i[a]是一样的，但是千万别混着使用。函数参数中a[]和*a是一样的，但是*a更为通用。&lt;/h4&gt;

&lt;h4 id="23printfppp"&gt;23. 可以用printf("%p",p);来显示p指针地址。&lt;/h4&gt;

&lt;h4 id="2412341234316"&gt;24. 字符串里面的转义序列要小心使用。比如八进制的转义序列在三个数字或者第一个非八进制数字处结束，\1234 实际是\123和4。十六进制数的转义序列不限制为3个数字，而是到第一个非16进制数字截至。&lt;/h4&gt;

&lt;h4 id="25"&gt;25.  如果字符串太长，不能在一行内放置，可以使用\来延长。\要求之后没有除回车外的字符，下一行要顶头开始。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;“Put a \
disk into drive a\n”&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过会打乱缩进。还好C语言标准规定，只要两个字符串中间都是空白字符，则将两个字符串合并，如：&lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Put a "&lt;/span&gt;

    &lt;span class="token string"&gt;"disk into drive a\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="26cabc1"&gt;26. C语言允许对字符串加下标，如"abc"[1]。这个特性使得字符串常量也可能改变，如&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;p &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"abc"&lt;/span&gt;&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token operator"&gt;*&lt;/span&gt;p &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;'x'&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这种特性会对程序造成不可预知的后果（如果编译器对同样的字符串是压缩存储，这将导致其它字符串可能变化）。但是下标还有一个很好的使用方法，如：&lt;code&gt;return "0123456789ABCDEF"[digit];&lt;/code&gt;这句话可以简单地将十进制的数字转化为十六进制的字符。&lt;/p&gt;

&lt;h4 id="270charstr7srpsrpch"&gt;27. 如果初始化字符串的长度和其本身长度一致时，编译器不会在后边加上'0'，也就不会破坏之后的数据。如：&lt;code&gt;Char str[7] = "srpsrp!",ch;&lt;/code&gt;中，&lt;/h4&gt;

&lt;p&gt;Ch的值是不确定的，而不是'\0'。这条仅知道即可。&lt;/p&gt;

&lt;h4 id="28xs"&gt;28. 如果只显示字符串的一部分，则使用%.xs。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; str&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"123456789"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"%.3s"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;str&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将显示123。&lt;/p&gt;

&lt;h4 id="29putsstr"&gt;29. &lt;code&gt;puts(str);&lt;/code&gt;将在输出字符串后强制输出一个换行。&lt;/h4&gt;

&lt;h4 id="30scanfgets"&gt;30. 用scanf输入的字符永远不包括空白字符(空格、回车、换行、换页、换表格等)。gets则到回车才停止，并忽略回车。&lt;/h4&gt;

&lt;h4 id="31scanfnsn"&gt;31. scanf天生不是安全的，它可能会溢出数组。使用％ns会更安全，n指读入的最大字符数。&lt;/h4&gt;

&lt;h4 id="32strcpystrcpystr2strcpystr11234"&gt;32. strcpy 的返回值在较大的表达式中比较有用。如strcpy(str2,strcpy(str1,”1234”));&lt;/h4&gt;

&lt;h4 id="33charplanetsmercuryvenusearthmarsjupitersaturnuranusneptuneplutoplanets981mars"&gt;33. 在空间敏感的程序中使用字符数组，可以使用&lt;code&gt;char *planets[] = {"Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Pluto"},&lt;/code&gt;这样里面每一个字符串都只有本身的长度，而不是定长的。如果是定长数组（planets[9][81]），那会浪费不少空间，如Mars后边会空很多。&lt;/h4&gt;

&lt;h4 id="34cargvargc"&gt;34. C程序的命令行中始终有一个空指针，即argv[argc]。&lt;/h4&gt;

&lt;h4 id="35printfscanf"&gt;35. printf和scanf的第一个参数是字符串，并不只是字符串常量。因此可以实现下面的代码：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; fmt &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"%d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; i &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;fmt&lt;span class="token punctuation"&gt;,&lt;/span&gt;i&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此可以读入fmt，然后再用fmt作为格式化串输入。&lt;/p&gt;

&lt;h4 id="36"&gt;36. #运算符在预处理时可以将宏的参数转换为字符串字面量。比如:&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;#define PRINT_INT(x)  printf(#x " = %d\n",x)&lt;/code&gt;,将使PRINT_INT(var)输出为&lt;code&gt;var = 13\n&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id="37definemk_idninintmk_id1mk_id2inti1i2"&gt;37. ##运算符在预处理时可以将两个记号合成一个记号。如&lt;code&gt;#define MK_ID(n) i##n&lt;/code&gt;在&lt;code&gt;int MK_ID(1), MK_ID(2)&lt;/code&gt;中等同于&lt;code&gt;int i1, i2&lt;/code&gt;。&lt;/h4&gt;

&lt;h4 id="38c"&gt;38. 在宏定义中缺少圆括号会导致C语言中最让人讨厌的错误。程序通常仍然可以编译通过，而且宏似乎也可以正常工作，但在某些情况下会出错。&lt;/h4&gt;

&lt;h4 id="39"&gt;39. 一些预定义的宏：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;__LINE__    被编译的文件的行数

__FILE__    被编译的文件的名字

__DATE__    编译的日期

__TIME__    编译的时间

__STDC__    如果编译器接受标准C，那么为1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="40defined10ififdefineddebugendif"&gt;40. defined运算符引用于标识符时，如果标识符是一个定义过的宏返回1，否则返回0。通常与if结合使用，如 &lt;code&gt;#if defined(DEBUG)…#endif&lt;/code&gt;。条件编译常用于保护头文件以避免重复包含。&lt;/h4&gt;

&lt;h4 id="41linelinenn132767linen__line__"&gt;41. #line指令用来给程序代码编号。如&lt;code&gt;#line n&lt;/code&gt;(n介于1和32767)，&lt;code&gt;#line n "文件名"&lt;/code&gt;。它可以改变&lt;code&gt;__LINE__&lt;/code&gt;宏。&lt;/h4&gt;

&lt;h4 id="42"&gt;42. 宏的使用必须谨慎小心，建议仅在常量不止一次使用，或者常量可能的使用方式变化的时候使用。&lt;/h4&gt;

&lt;h4 id="43defineconcatxyxyconcatabconcataconcatbcaconcatbcabcaconcat"&gt;43. ##运算符不能嵌套使用。比如&lt;code&gt;#define CONCAT(x,y) x##y&lt;/code&gt;在&lt;code&gt;CONCAT(a,b)&lt;/code&gt;时可以用，但是在&lt;code&gt;CONCAT(a,CONCAT(b,c));&lt;/code&gt;时将成为&lt;code&gt;aCONCAT(b,c)&lt;/code&gt;,而不是abc，因为没有名为&lt;code&gt;aCONCAT&lt;/code&gt;的宏。&lt;/h4&gt;

&lt;h4 id="44externintiii"&gt;44. &lt;code&gt;extern int i;&lt;/code&gt;提示编译器i是程序中其他位置定义的，因此不为i分配空间。&lt;/h4&gt;

&lt;h4 id="45ifndefendif"&gt;45. 为了防止头文件多次包含，用&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;把文件的内容括起来，来保护。如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;boolean&lt;span class="token punctuation"&gt;.&lt;/span&gt;h
&lt;span class="token property"&gt;#ifndef    BOOLEAN_H&lt;/span&gt;
&lt;span class="token property"&gt;#define    BOOLEAN_H&lt;/span&gt;
&lt;span class="token property"&gt;#define    TRUE    1&lt;/span&gt;
&lt;span class="token property"&gt;#define    FALSE   0&lt;/span&gt;
&lt;span class="token keyword"&gt;typedef&lt;/span&gt;    &lt;span class="token keyword"&gt;int&lt;/span&gt; Bool&lt;span class="token punctuation"&gt;;&lt;/span&gt;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="46"&gt;46. 划分源文件的规则：&lt;/h4&gt;

&lt;p&gt;把每组函数的集合放入单独的源文件，在与源文件同名的头文件中放置函数原型（以及使用这些函数所需要的定义和头文件），每个调用源文件的文件都要包括相应的头文件，这样编译器就可以检验原型和定义是否一致。&lt;/p&gt;

&lt;h4 id="47structpart2part1"&gt;47. Struct可以使用赋值运算：&lt;code&gt;part2 = part1&lt;/code&gt;。通常利用这个特性来实现数组的赋值：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt;a1&lt;span class="token punctuation"&gt;,&lt;/span&gt;a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;&lt;span class="token punctuation"&gt;.&lt;/span&gt;
a1 &lt;span class="token operator"&gt;=&lt;/span&gt; a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是不能使用a1 == a2来判断两者是否相等。&lt;/p&gt;

&lt;h4 id="48"&gt;48. 为了能对两个结构使用=赋值，两者不仅仅需要定义一致，还需要结构标记一致或者使用共同的类型。比如&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt; example&lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; a1&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
&lt;span class="token keyword"&gt;struct&lt;/span&gt; example a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者 &lt;/p&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;typedef&lt;/span&gt; &lt;span class="token keyword"&gt;struct&lt;/span&gt; &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; example&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
example a1&lt;span class="token punctuation"&gt;;&lt;/span&gt; 
example a2&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（a1 和 a2可以是出现在不同位置的结构，如两个函数中。为了使用=，但是定义位置不同，所以要用上述两种方法解决问题）。&lt;/p&gt;

&lt;h4 id="49"&gt;49.&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt; Struct part &lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; a&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token number"&gt;10&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; a1&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;int&lt;/span&gt; part&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;是合法的，但是为了避免结构体part和整型变量part混淆，尽量不要使用。

####50. 在结构中使用联合可以节省大量空间。比如同一个数组保存三类不同物品的信息时，可以将三类物品的定义整合为联合。为了区别表示其中保存的物品，可以在结构定义一个枚举变量来表明联合中存储的类型。如

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;struct&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;
&lt;span class="token keyword"&gt;enum&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;INT_KIND&lt;span class="token punctuation"&gt;,&lt;/span&gt;FLOAT_KIND&lt;span class="token punctuation"&gt;)&lt;/span&gt; kind&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;union&lt;/span&gt;&lt;span class="token punctuation"&gt;{&lt;/span&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; i&lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token keyword"&gt;float&lt;/span&gt; t&lt;span class="token punctuation"&gt;;&lt;/span&gt;&lt;span class="token punctuation"&gt;}&lt;/span&gt; u&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt; number&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过number.kind确定存储的是整形还是实型变量，再提取number.u.i或者number.u.t。&lt;/p&gt;

&lt;h4 id="51mallocmallocsizeofmallocsizeofstruct"&gt;51. 使用malloc来动态分配结构时，不要使用&lt;code&gt;malloc(sizeof(结构指针))&lt;/code&gt;，而是&lt;code&gt;malloc(sizeof(struct 名字))&lt;/code&gt;；&lt;/h4&gt;

&lt;h4 id="52"&gt;52. 对于结构体不能使用==的一点补充，就是不可以对结构体按字节来对比。因为结构内部可能有空洞，对于它们而言，内部可以储存不同的数字。因此相同的结构按字节对比的结果可能不同，必须使用按成员的方式对比。&lt;/h4&gt;

&lt;h4 id="53pelementpp"&gt;53. 使用结构联合和枚举类型的指针时，访问子元素时一定要用(*p).element。包括当被指向的单元自增时使用(*p)++，指针自加使用p++。&lt;/h4&gt;

&lt;h4 id="54callocmalloccalloc1calloc"&gt;54. calloc函数会清除分配的内存，而malloc不会。有时需要用calloc为非空数组分配空间。通过调用1为第一个实际参数的calloc函数，可以为任何类型数据项分配空间：&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;p = calloc(1，sizeof(struct point));&lt;/code&gt;&lt;/p&gt;

&lt;h4 id="55reallocmalloccallocrealloc"&gt;55. realloc的指针参数必须是来自malloc，calloc或者realloc生成的指针。如果不是这样，程序可能会行为异常。&lt;/h4&gt;

&lt;h4 id="56realloc"&gt;56. realloc的准则：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;realloc不会初始化扩展的内存空间。&lt;/li&gt;
&lt;li&gt;如果realloc不能扩展，原指针会变空指针。&lt;/li&gt;
&lt;li&gt;如果realloc函数调用时以空指针作为第一个实际参数，那么行为就像malloc。&lt;/li&gt;
&lt;li&gt;realloc函数的第二个参数如果是0，那么行为如同free。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="57reallocrealloc"&gt;57. 一旦realloc函数返回，需要将指向本内存块的所有指针进行更新，因为realloc函数可能把原内存空间移动到了其他地方的内存。&lt;/h4&gt;

&lt;h4 id="58"&gt;58. 释放内存块时一定要谨慎小心，避免几个指针都指向同一个内存块，此时很容易有悬空指针。&lt;/h4&gt;

&lt;h4 id="59structnodenew_nodenew_nodemallocsizeofstructnodenew_nodemallocsizeofnew_node"&gt;59. 如果有&lt;code&gt;struct node *new_node;&lt;/code&gt;要分配空间时要使用&lt;code&gt;new_node = malloc(sizeof (struct node));&lt;/code&gt;而不是&lt;code&gt;new_node = malloc(sizeof (new_node));&lt;/code&gt;,后者只分配了一个指针的空间，而不是一个结构的空间。&lt;/h4&gt;

&lt;h4 id="60intpintpppp"&gt;60.&lt;code&gt;int *p(...)&lt;/code&gt;和&lt;code&gt;int (*p)(....)&lt;/code&gt;不同，前者是返回指针的函数，后者是指向函数的指针。需要后者指向某个函数时，简单的使用&lt;code&gt;p= 函数名&lt;/code&gt;（当函数名后边没有括号时，编译器将产生指向函数的指针来代替函数。）;调用时，可以用&lt;code&gt;(*p)(参数)&lt;/code&gt;，或者&lt;code&gt;p(参数)&lt;/code&gt;。&lt;/h4&gt;

&lt;h4 id="61voidfile_cmdvoidnew_cmdopen_cmdclose_cmdexit_cmdfile_cmd"&gt;61. 利用指向函数的指针可以用来产生菜单项。&lt;code&gt;void(*file_cmd[])(void) = {new_cmd,open_cmd,close_cmd,exit_cmd};&lt;/code&gt;就是一个菜单函数的封装实例。通过对file_cmd进行下标操作就可以调用相应的函数。&lt;/h4&gt;

&lt;h4 id="62qsortstrcmp"&gt;62. qsort不可以直接调用strcmp进行排序，因此需要下列函数进行辅助：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;Int &lt;span class="token function"&gt;compare_strings&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;p&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;q&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    Return &lt;span class="token function"&gt;strcmp&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; p&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;q&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="63static"&gt;63. static有三个用法：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;声明变量和函数当前文件内有效；&lt;/li&gt;
&lt;li&gt;函数内的变量得以保留并在下次调用时使用；&lt;/li&gt;
&lt;li&gt;使变量初始化为0。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="64externinttoupperinttoupper"&gt;64. 可以用&lt;code&gt;extern int toupper(int);&lt;/code&gt;来强制使用函数版本的toupper。&lt;/h4&gt;

&lt;h4 id="65malloccallocfreefree"&gt;65. malloc、calloc要和free封装在一个函数内，否则容易在free的时候跳出&lt;/h4&gt;

&lt;h4 id="66assertassertdebugrelease"&gt;66. assert用在函数检查参数的时候非常方便。如果该函数需要保证参数输入的条件，用assert，这样保证输入参数有问题的时候可以在debug的时候发现，而release版又不会产生性能上的影响。&lt;/h4&gt;

&lt;h4 id="67autostatic"&gt;67. 函数不能返回auto型的变量，但是可以返回static声明的静态变量。&lt;/h4&gt;

&lt;h4 id="68rigister"&gt;68. rigister类型只对块内的变量有效，由于没有地址，因此取地址运算符&amp;amp;是无效的。&lt;/h4&gt;

&lt;h4 id="69externstatic"&gt;69. 函数的类型只有extern 和static两种，前者加与不加是一样的，后者使得函数只能在本文件内调用。&lt;/h4&gt;

&lt;h4 id="70externintii"&gt;70. 对于某个文件内的全局变量，在另一个文件的函数内可以使用extern int i来获得之前的定义的变量。但是此时i在该文件中只有该函数的作用域。&lt;/h4&gt;

&lt;h4 id="71intx10void"&gt;71. 处理复杂的声明时：始终从内向外读声明；做选择时，始终先[]和（）后是*，越先选取的，就越是它的本质。如：&lt;code&gt;int *(*x[10])(void);&lt;/code&gt;是&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;x[10],数组；&lt;/li&gt;
&lt;li&gt;*，指向函数的指针数组；&lt;/li&gt;
&lt;li&gt;void，指向无参数函数的指针数组；&lt;/li&gt;
&lt;li&gt;int *，指向返回整型指针的无参数函数的指针数组。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以利用typedef来定义中间类型，简化理解过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;typedef int *Fcn(void);&lt;/li&gt;
&lt;li&gt;typedef Fcn *Fcn_ptr;&lt;/li&gt;
&lt;li&gt;typedef Fcn_ptr Fcn_ptr_array[10];&lt;/li&gt;
&lt;li&gt;Fcn_ptr_array x;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意不能出现以下情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;int f(int)[];(函数不能返回数组)&lt;/li&gt;
&lt;li&gt;int g(int)(int);（函数不能返回函数）&lt;/li&gt;
&lt;li&gt;int a[10](int);（函数型数组不存在）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="72"&gt;72. 可以用下列技巧来在一个工程中合理的分配公有私有的函数：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token property"&gt;#define PUBLIC &lt;/span&gt;&lt;span class="token comment" spellcheck="true"&gt;/*empty*/&lt;/span&gt;
&lt;span class="token property"&gt;#define PRIVATE static&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以在声明函数的时候用上述修饰符来声明函数的定义范围了。&lt;/p&gt;

&lt;h4 id="73ijiji0i"&gt;73. i&amp;gt;&amp;gt;j的值是i右移j位的结果。如果i是无符号数或非负值，左端补0；i是负值，则由实现定义的。因此最好仅对无符号数移位。&lt;/h4&gt;

&lt;h4 id="74t01"&gt;74. ~0可以得到一个全部数位为1的数字。&lt;/h4&gt;

&lt;h4 id="75"&gt;75. &amp;amp;^|优先级低于判等和关系运算符，因此一般使用位运算符都用括号。&lt;/h4&gt;

&lt;h4 id="76"&gt;76. 位运算惯用法：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置位 &lt;code&gt;i |= 0x0010&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;位清0 &lt;code&gt;i &amp;amp;= ~0x0010&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;测试位 &lt;code&gt;if (i &amp;amp; 0x0010)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id="77structdateunsignedintday5month4year7scanf0"&gt;77. 结构体中可以在变量声明的时候在后边加冒号和数字来声明一个位域，如&lt;code&gt;struct date { unsigned int day:5 ,month: 4, year:7}&lt;/code&gt;.但是使用的时候位域不可以使用&amp;amp;来取地址，因此scanf要先读入到普通变量后再赋值。也可以在位域声明的时候不起名字，起到占位的作用。长度为0的位域则强制下一个位域放在一个存储单元的起始位置(用于对齐)。&lt;/h4&gt;

&lt;h4 id="78unionint_dateunsignedintistructdatefddatesizeintdateiint"&gt;78. 联合常常用来用多种形式显示数字。比如&lt;code&gt;union int_date {unsigned int i; struct date fd;};&lt;/code&gt;其中date结构体是代码中已经声明过的，size等同int。这样按照date类型存储后可以通过i得到一个int型的数字。&lt;/h4&gt;

&lt;h4 id="79byteppbyte0x1000dosbytefarppmk_fpsegmentoffset"&gt;79. 指定一个指针的地址：如果计算机的指针和长整型一致，则可以直接赋值：&lt;code&gt;BYTE *p; p = (BYTE*) 0x1000;&lt;/code&gt;如果是实模式的dos程序，则使用&lt;code&gt;BYTE far *p; p = MK_FP(segment, offset);&lt;/code&gt;&lt;/h4&gt;

&lt;h4 id="80volatilevolatilep"&gt;80. 对于直接从用户输入缓冲得到的字符，需要用volatile 限定符声明中间变量。否则循环中中间变量没有变化过，可能被编译器优化后，使得每次读取中间变量时都是读取第一次的值。用volatile声明后编译器就会强制每次读取p的值时都从内存中重新获取。如：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;while (缓冲区未满) 
{
 等待输入;
 buffer[i] = *p;
 if (buffer[i++] == '\n') break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处的p就需要用volatile 声明。&lt;/p&gt;

&lt;h4 id="81isprintdefineisprintcundefisprintc"&gt;81. 系统库里的很多函数都用宏重新封装过，如isprint()函数被重新定义为&lt;code&gt;#define isprint(c)&lt;/code&gt;宏。要使用函数版本而不是宏的时候（比如函数指针），可以用#undef 宏名来取消它的宏定义；也可以用(isprint)(c)来强制个别调用时是函数。&lt;/h4&gt;

&lt;h4 id="82offsetofstructscharaintb2floatcoffsetstructsa0"&gt;82. 宏offsetof参数是类型、指定成员，会计算起点到指定成员的字节数。如&lt;code&gt;struct s {char a;int b[2]; float c;} offset(struct s,a)&lt;/code&gt;的结果为0。&lt;/h4&gt;

&lt;h4 id="83fflushfpfpcommitfflushnullcommit0eoffp12"&gt;83. 可以用fflush(fp)来强制让fp指针的状态commit到硬盘。fflush(NULL)可以把所有的文件指针commit。没有错误返回0，有错返回EOF。fp必须处于（1）输出打开（2）为更新打开并且流的最后操作不是读，也就是说，是用来“清理”输出流的。&lt;/h4&gt;

&lt;h4 id="84setvbufstream"&gt;84. 使用setvbuf函数必须在stream的任何操作之前使用。&lt;/h4&gt;

&lt;h4 id="85rawfflush"&gt;85. r+、a+、w+在转换读或者写的时候，必须用文件定位函数将读转为写，或者用fflush或文件定位函数将写转为读。&lt;/h4&gt;

&lt;h4 id="86filenametmpnamnulltmpnamfilename"&gt;86. &lt;code&gt;filename = tmpnam(NULL);&lt;/code&gt;或者 &lt;code&gt;tmpnam(filename)&lt;/code&gt;都可以生成临时的文件名。&lt;/h4&gt;

&lt;h4 id="87printf"&gt;87. Printf类函数完整说明：&lt;/h4&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt; &lt;/td&gt;&lt;td&gt;标志&lt;/td&gt;&lt;td&gt;最小字段宽度&lt;/td&gt;&lt;td&gt;精度&lt;/td&gt;&lt;td&gt;长度修饰符&lt;/td&gt;&lt;td&gt;转换说明符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;#0&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;.5&lt;/td&gt;&lt;td&gt;L&lt;/td&gt;&lt;td&gt;g&lt;/td&gt;
&lt;/tr&gt;   
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;标志&lt;/em&gt;：可选项，允许多余一个。所有标志如下：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;标志&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;&lt;td&gt;在字段内左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;&lt;td&gt;以+开头的正符号数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空格&lt;/td&gt;&lt;td&gt;空格取代正符号数的+号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;&lt;td&gt;以0开头的八进制数，以0x开头的16进制数。浮点数始终是十进制。不能删除g或者G输出数的尾部0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0(零)&lt;/td&gt;&lt;td&gt;用前导0填充宽度。如果是制定了精度的d、i、o、u、x，则忽略前导0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;最小字段宽度&lt;/em&gt;：可选项。如果字符数太少达不到字段宽度最小值，则对字符数量扩充（默认在左侧添加空格）。如果超过字段宽度，则完整的显示。如果宽度是*，则宽度由下一个参数决定。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;精度&lt;/em&gt;：可选项。精度含义依赖于转换说明符：如果转换说明符是d、i、o、u、x、X，则精度表示最少数字位数，少于时左侧加0；如果是e、E、f，那么精度是小数点后的数位；如果是g、G，则表示最大有效位数；如果是s，则表示最大字符数；如果只有小数点，则精度为0；如果是*，则由下一个参数决定。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;长度修饰符&lt;/em&gt;：可选项，h说明是short型的，l是long型的，L说明是long double型的。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;转换说明符&lt;/em&gt;：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明符&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d、i&lt;/td&gt;&lt;td&gt;有符号整数的十进制形式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O、u、x、X&lt;/td&gt;&lt;td&gt;8进制、10进制、或16进制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;&lt;td&gt;十进制double型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E、e&lt;/td&gt;&lt;td&gt;科学计数法的double型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G、g&lt;/td&gt;&lt;td&gt;自动选择f还是e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;&lt;td&gt;自动选择f还是e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;&lt;td&gt;字符串输出，达到精度时或者遇到结尾时停止。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;&lt;td&gt;void *型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;&lt;td&gt;匹配的实参必须是指向int的指针。可以和h和l搭配。会将输出的字符数量存储到指针指向的地址而不输出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;字符%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;：（。表示空格）&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对123的结果&lt;/td&gt;&lt;td&gt;对-123的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8d&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-8d&lt;/td&gt;&lt;td&gt;123。。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%+8d&lt;/td&gt;&lt;td&gt;。。。。+123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;% 8d&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;&lt;td&gt;。。。。-123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%08d&lt;/td&gt;&lt;td&gt;00000123&lt;/td&gt;&lt;td&gt;-。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-+8d&lt;/td&gt;&lt;td&gt;+123。。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%- 8d&lt;/td&gt;&lt;td&gt;。123。。。。&lt;/td&gt;&lt;td&gt;-123。。。。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%+08d&lt;/td&gt;&lt;td&gt;+0000123&lt;/td&gt;&lt;td&gt;-0000123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;% 08d&lt;/td&gt;&lt;td&gt;。0000123&lt;/td&gt;&lt;td&gt;-0000123&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对123的结果&lt;/td&gt;&lt;td&gt;对123.0的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8o&lt;/td&gt;&lt;td&gt;。。。。。173&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8o&lt;/td&gt;&lt;td&gt;。。。。0173&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8x&lt;/td&gt;&lt;td&gt;。。。。。。7b&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8x&lt;/td&gt;&lt;td&gt;。。。。0x7b&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8X&lt;/td&gt;&lt;td&gt;。。。。。。7B&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8X&lt;/td&gt;&lt;td&gt;。。。。0X7B&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8g&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8g&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。123。000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%8G&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。。。。。123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%#8G&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;。123。000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明&lt;/td&gt;&lt;td&gt;对"bogus"的结果&lt;/td&gt;&lt;td&gt;对"buzzword"的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%6s&lt;/td&gt;&lt;td&gt;。bogus&lt;/td&gt;&lt;td&gt;buzzword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-6s&lt;/td&gt;&lt;td&gt;bogus。&lt;/td&gt;&lt;td&gt;buzzword&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%.4s&lt;/td&gt;&lt;td&gt;bogu&lt;/td&gt;&lt;td&gt;buzz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%6.4s&lt;/td&gt;&lt;td&gt;。。bogu&lt;/td&gt;&lt;td&gt;。。buzz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%-6.4s&lt;/td&gt;&lt;td&gt;bogu。。&lt;/td&gt;&lt;td&gt;buzz。。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;数&lt;/td&gt;&lt;td&gt;对%.4g产生的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;123456&lt;/td&gt;&lt;td&gt;1.235e+05&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12345.6&lt;/td&gt;&lt;td&gt;1.235e+04&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1234.56&lt;/td&gt;&lt;td&gt;1235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;123.456&lt;/td&gt;&lt;td&gt;123.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12.3456&lt;/td&gt;&lt;td&gt;12.35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1.23456&lt;/td&gt;&lt;td&gt;1.235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.123456&lt;/td&gt;&lt;td&gt;0.1235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0123456&lt;/td&gt;&lt;td&gt;0.01235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.00123456&lt;/td&gt;&lt;td&gt;0.001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.000123456&lt;/td&gt;&lt;td&gt;0.0001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0000123456&lt;/td&gt;&lt;td&gt;0.00001235&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.00000123456&lt;/td&gt;&lt;td&gt;0.000001235&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;其它&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;printf("%6.4d",i)等价于printf("%*.4d",6,i);printf("%6.*d",4,i);printf("%*.*d",6,4,i);&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;printf("%d%n",123,&amp;amp;len);&lt;/td&gt;&lt;td&gt;输出123&lt;/td&gt;&lt;td&gt;输出后len==3&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;h4 id="88scanf"&gt;88. scanf类完整说明：&lt;/h4&gt;

&lt;p&gt;scanf类函数在输入失败或者匹配失败的时候会提前返回。返回值是读入并赋值给实参的数据数量。因此可以用&lt;code&gt;while (scanf("%d",&amp;amp;i) == 1){...}&lt;/code&gt;来循环读取，直到读取失败为止。&lt;/p&gt;

&lt;p&gt;格式化串的组成：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;字符*&lt;/em&gt;：可选项。*出现意味着赋值屏蔽：读入此项，但是不赋值。*匹配的数据项不计入scanf类函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;最大字段宽度&lt;/em&gt;：可选项。限制了输入项字符的数量。如果开始时跳过了空白字符，对空白字符不进行统计。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;h、l和L&lt;/em&gt;：同printf类函数的含义。&lt;/p&gt;

&lt;p&gt;转换说明符：&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;转换说明符&lt;/td&gt;&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;&lt;td&gt;匹配十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;&lt;td&gt;匹配整数，假定数是十进制的，除非0开头（8进制），或0x开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;&lt;td&gt;匹配八进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;&lt;td&gt;匹配十进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X、x&lt;/td&gt;&lt;td&gt;匹配十六进制数，实参为unsigned int 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E、e、f、g、G&lt;/td&gt;&lt;td&gt;匹配float型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;&lt;td&gt;匹配一序列非空字符串，并在末尾加'\0'&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[&lt;/td&gt;&lt;td&gt;匹配来自扫描集合的非空字符序列，然后在末尾添'\0'。可以是%[集合]或者%[^集合]，前者匹配集合内的字符，后者匹配集合外的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;&lt;td&gt;匹配其字段宽度的字符数，如果没有字段宽度，则匹配1个&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;&lt;td&gt;匹配printf输出相同的指针值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;&lt;td&gt;将目前为止的读入字符数存入此int指针指向的变量，没有输入会匹配，scanf的返回值也不受影响。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;&lt;td&gt;匹配%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;示例：（。表示空格）&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;scanf的调用&lt;/td&gt;&lt;td&gt;输入&lt;/td&gt;&lt;td&gt;变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。&lt;/del&gt;，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d,%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12&lt;/del&gt;。，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d。,%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。，。34&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%d,。%d",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12&lt;/del&gt;。，。34'\n'&lt;/td&gt;&lt;td&gt;n:1;i:12;j:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*d%d",&amp;amp;i);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。34&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:1;i:34&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*s%s", str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;My。Fair&lt;/del&gt;。Lady'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"Fair"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%1d%2d%3d",&amp;amp;i,&amp;amp;j,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12345&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:1;j:23;k:45;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%2d%2s%2d",&amp;amp;i,str,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;123456&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:12;str:"34";k:56;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%i%i%i",&amp;amp;i,&amp;amp;j,&amp;amp;k);&lt;/td&gt;&lt;td&gt;&lt;del&gt;12。012。0x12&lt;/del&gt;'\n'&lt;/td&gt;&lt;td&gt;n:3;i:12;j:10;k:18;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[0123456789]",str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;123&lt;/del&gt;abc'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"123";&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[0123456789]",str);&lt;/td&gt;&lt;td&gt;abc123'\n'&lt;/td&gt;&lt;td&gt;n:0;str:?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%[^0123456789]",str);&lt;/td&gt;&lt;td&gt;&lt;del&gt;abc&lt;/del&gt;123'\n'&lt;/td&gt;&lt;td&gt;n:1;str:"abc";&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n = scanf ("%*d%d%n",&amp;amp;i,&amp;amp;j);&lt;/td&gt;&lt;td&gt;&lt;del&gt;10。20&lt;/del&gt;。30'\n'&lt;/td&gt;&lt;td&gt;n:1;i:20;j:5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h4 id="89scanfnstr"&gt;89. 如上所述，&lt;code&gt;scanf ("%[^\n]",str);&lt;/code&gt;可以轻松得到一行文字。&lt;/h4&gt;

&lt;h4 id="90ungetcchfpgetcungetcgetcintchgetcfpeof"&gt;90. &lt;code&gt;ungetc(ch,fp);&lt;/code&gt;可以轻松回退一次上次的getc操作，只保证第一次ungetc的调用是成功的。注意，getc所保存的应当是int型数据，否则&lt;code&gt;(ch = getc(fp)) ！= EOF&lt;/code&gt; 可能会导致错误的结果。&lt;/h4&gt;

&lt;h4 id="91ftellfpfp"&gt;91. ftell(fp)函数中fp如果是文本流，则返回的值不一定是字节计数，因此最好不要进行算术运算。&lt;/h4&gt;

&lt;h4 id="92sprintfsscanfsprintfstrdisscanf"&gt;92. 可以用sprintf和sscanf对字符串进行读写操作。比如&lt;code&gt;sprintf(str,"%d",i);&lt;/code&gt;sscanf则实现了对一次输入的多重检测读取，如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;if&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;sscanf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"%d /%d/%d"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token number"&gt;3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Month: %d, day: %d, year: %d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;sscanf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;"%d -%d -%d"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token operator"&gt;&amp;amp;&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token number"&gt;3&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Month: %d, day: %d, year: %d\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;month&lt;span class="token punctuation"&gt;,&lt;/span&gt;day&lt;span class="token punctuation"&gt;,&lt;/span&gt;year&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;else&lt;/span&gt;
    &lt;span class="token function"&gt;printf&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token string"&gt;"Date not in the proper form.\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="93printfnum1dapplesdapplenum"&gt;93. 可以将格式化串和问号表达式一起用，比如printf(num &amp;gt; 1 ? "%d apples.":"%d apple.",num);&lt;/h4&gt;

&lt;h4 id="94ltfloathgtltlimitshgtltmathhgterrnofmod552211"&gt;94. 库的宏定义范围：&amp;lt;float.h&amp;gt;浮点型的特性；&amp;lt;limits.h&amp;gt;整值类型的大小；&amp;lt;math.h&amp;gt;数学计算（出错时多数会写入errno变量中），其中包含fmod（5.5,2.2） = 1.1；&lt;/h4&gt;

&lt;h4 id="95size_tstrxfrmchars1constchars2size_tns2s1"&gt;95. size_t strxfrm(char *s1, const char *s2, size_t n);该函数将s2转换后存在s1，返回转换后的字符数量。一般都是用两次：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;size_t len&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;transformed&lt;span class="token punctuation"&gt;;&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strxfrm&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt; original&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
transformed &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;malloc&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;len&lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token function"&gt;strxfrm&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;transformed&lt;span class="token punctuation"&gt;,&lt;/span&gt; original&lt;span class="token punctuation"&gt;,&lt;/span&gt; len&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="96strpbrkstrspnstrcspnsize_tstrspnstrcspn"&gt;96. strpbrk函数用来查找第一个参数中与第二个参数中任意一个字符相匹配的最左边的一个字符；strspn和strcspn会返回一个表示字符串中特定位置的整数(size_t类型)，strspn返回第一个不属于给定字符集的字符下标；strcspn函数返回第一个属于给定字符集中的字符下标，如：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;size_t len&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;char&lt;/span&gt; str&lt;span class="token punctuation"&gt;[&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token string"&gt;"Form follows function."&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;"morF"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=4*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token string"&gt;" \t\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=0*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strcspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;"morF"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=0*/&lt;/span&gt;
len &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;strcspn&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;str&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token string"&gt;" \t\n"&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;    &lt;span class="token comment" spellcheck="true"&gt;/*len=4*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="97memset0memset0"&gt;97. memset可以将数组全初始化为0，但是对于浮点数、结构体等，不是memset可以完全置0；&lt;/h4&gt;

&lt;h4 id="98ltasserthgtdefinenodebugassert"&gt;98. &amp;lt;assert.h&amp;gt;可以使用#define NODEBUG禁用assert&lt;/h4&gt;

&lt;h4 id="99lterrnohgterrnoedomerange"&gt;99. &amp;lt;errno.h&amp;gt;errno变量用来存储数学函数错误。EDOM表示定义域错误，ERANGE表示值域错误，通常是太大。&lt;/h4&gt;

&lt;h4 id="100ltsignalhgtvoidsignalintsigvoidfuncintintfuncsigabortraisesignalsigabrtsigfpesignalsigsegv"&gt;100. &amp;lt;signal.h&amp;gt;&lt;code&gt;void (*signal(int sig, void (*func)(int)))(int);&lt;/code&gt;作用是用自定义的func函数替换原先与sig相对性的函数。返回值是原先的函数指针。除非是abort或者raise函数引发的signal，否则不要用库函数，或者试图使用一个静态存储期限的变量。从处理函数返回时程序将从信号发生点继续运行，除了信号SIGABRT（终止程序），和SIGFPE（未定义）。信号处理完毕后，除非处理函数重新安装，否则该信号不会被同一函数再次处理。因此可以在返回之前再用signal函数重新安装。SIGSEGV表示段错误，调试时应该很有用。&lt;/h4&gt;

&lt;h4 id="101"&gt;101. 在字符串中小心放置??。如果要放置??，可以用?\?来代替。否则会被认为是三字符序列。&lt;/h4&gt;

&lt;h4 id="102setlocalelc_allcsetlocalelc_allnullllabc"&gt;102. 任意程序开始时都隐含执行&lt;code&gt;setlocale(LC_ALL,"C");&lt;/code&gt;如果运行&lt;code&gt;setlocale(LC_ALL,NULL);&lt;/code&gt;则会返回当前区域设置。对于宽字符常量需要用L修饰，如L"abc"。&lt;/h4&gt;

&lt;h4 id="103"&gt;103. 用来检测多字符和宽字符：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;mbcheck&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;char&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;s&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;for&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token function"&gt;mblen&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; s &lt;span class="token operator"&gt;+&lt;/span&gt;&lt;span class="token operator"&gt;=&lt;/span&gt; n&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;n &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;mblen&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;s&lt;span class="token punctuation"&gt;,&lt;/span&gt; MB_CUR_MAX&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
    &lt;span class="token keyword"&gt;return&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;

&lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token function"&gt;wccheck&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;wchar_t &lt;span class="token operator"&gt;*&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;
&lt;span class="token punctuation"&gt;{&lt;/span&gt;
    &lt;span class="token keyword"&gt;char&lt;/span&gt; buf&lt;span class="token punctuation"&gt;[&lt;/span&gt;MB_LEN_MAX&lt;span class="token punctuation"&gt;]&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;int&lt;/span&gt; n&lt;span class="token punctuation"&gt;;&lt;/span&gt;
    &lt;span class="token keyword"&gt;for&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;wctomb &lt;span class="token punctuation"&gt;(&lt;/span&gt;NULL&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token punctuation"&gt;;&lt;/span&gt; &lt;span class="token operator"&gt;++&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;
        &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;n &lt;span class="token operator"&gt;=&lt;/span&gt; &lt;span class="token function"&gt;wactomb&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;buf&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;wcs&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt; &lt;span class="token operator"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
        &lt;span class="token keyword"&gt;else&lt;/span&gt; &lt;span class="token keyword"&gt;if&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;buf&lt;span class="token punctuation"&gt;[&lt;/span&gt;n &lt;span class="token operator"&gt;-&lt;/span&gt;&lt;span class="token number"&gt;1&lt;/span&gt;&lt;span class="token punctuation"&gt;]&lt;/span&gt; &lt;span class="token operator"&gt;==&lt;/span&gt; &lt;span class="token string"&gt;'\0'&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;
            &lt;span class="token keyword"&gt;return&lt;/span&gt; &lt;span class="token number"&gt;0&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token punctuation"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;wctomb (NULL,0)&lt;/code&gt;这个函数是用来初始化多字符状态的。&lt;/p&gt;

&lt;p&gt;mbstowcs和wcstombs可以转换字符串，返回修改字符串的个数。&lt;/p&gt;

&lt;h4 id="104ltstdarghgt"&gt;104. &amp;lt;stdarg.h&amp;gt;提供的三种宏可以视为三个函数：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;va_start&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;,&lt;/span&gt; parmN&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
类型 &lt;span class="token function"&gt;va_arg&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;,&lt;/span&gt; 类型&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token function"&gt;va_end&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;va_list ap&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过第一个函数设置valist的可变参数是从哪里开始；第二个函数是从valist中返回下一个参数（不必手动增加，每次调用会自增），其类型为指定类型；第三个参数结束参数的调用，此时方可返回。声明函数时使用&lt;code&gt;int max(int n,...)&lt;/code&gt;即可。&lt;/p&gt;

&lt;h4 id="105ltstdlibhgtsrandrand1"&gt;105. &amp;lt;stdlib.h&amp;gt;对于相同的种子，srand()将生成相同的随机数列。rand()函数获得随机数列的下一个值。选择1作为种子值和没有指明种子值是一样的。&lt;/h4&gt;

&lt;h4 id="106atexit"&gt;106. 可以通过atexit(函数名)来指定退出时自动调用的方法。&lt;/h4&gt;

&lt;h4 id="107getenvpathsystem0"&gt;107. getenv函数会返回指定字串在操作系统中某个字符串的意义，比如PATH。该结果储存在静态空间中，稍后函数调用时会改变。system用来执行外部命令，如果命令为空指针，则对命令环境测试，如果命令处理程序有效，则返回非0值。&lt;/h4&gt;

&lt;h4 id="108"&gt;108. 搜索和排序：&lt;/h4&gt;

&lt;pre class=" language-c"&gt;&lt;code class=" language-c"&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token function"&gt;bsearch&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;key&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;base&lt;span class="token punctuation"&gt;,&lt;/span&gt;size_t nmemb&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t size&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;compar&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;

&lt;span class="token keyword"&gt;void&lt;/span&gt; qsort &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;base&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t nmemb&lt;span class="token punctuation"&gt;,&lt;/span&gt; size_t size&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;int&lt;/span&gt; &lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token operator"&gt;*&lt;/span&gt;compar&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;(&lt;/span&gt;&lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;,&lt;/span&gt; &lt;span class="token keyword"&gt;const&lt;/span&gt; &lt;span class="token keyword"&gt;void&lt;/span&gt; &lt;span class="token operator"&gt;*&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;)&lt;/span&gt;&lt;span class="token punctuation"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="109divldivdiv_tquotrem"&gt;109. /和%与实现有关，因此可以用div和ldiv代替，前者用于整型，后者用于长整型。返回div_t类型，可用quot和rem求商和余数。效率是使用它们而不是/和%的原因，因为可以在一个指令里计算出两个结果。&lt;/h4&gt;</content:encoded><guid>http://blog.shrp.me//Understanding-Of-Restudy-C.html</guid></item></channel>
</rss>